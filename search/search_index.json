{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyTabular","text":""},{"location":"#what-is-it","title":"What is it?","text":"<p>PyTabular (python-tabular in pypi) is a python package that allows for programmatic execution on your tabular models! This is possible thanks to Pythonnet and Microsoft's .Net APIs on Azure Analysis Services. Currently, this build is tested and working on Windows Operating System only. Help is needed to expand this for another os. See the Documentation Here. PyTabular is still considered alpha. Please send bugs my way! Preferably in the issues section in Github.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the Pypi project for available versions.</p> <p>Before 0.3.5</p> <p>To become PEP8 compliant with naming conventions, serious name changes were made in 0.3.5. Install v. 0.3.4 or lower to get the older naming conventions.</p> Install Example<pre><code>python3 -m pip install python-tabular\n\n#install specific version\npython3 -m pip install python-tabular==0.3.4\n</code></pre> <p>In your python environment, import pytabular and call the main Tabular Class. The only parameter needed is a solid connection string.</p> Connecting to Model<pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR) # (1)\n</code></pre> <ol> <li>That's it. A solid connection string.</li> </ol> <p>You may have noticed some logging into your console. I'm a big fan of logging, if you don't want any just get the logger and disable it.</p> Logging Example<pre><code>import pytabular\npytabular.logger.disabled = True\n</code></pre> <p>You can query your models with the <code>query()</code> method from your tabular class. For Dax Queries, it will need the full Dax syntax. See EVALUATE example. This will return a Pandas DataFrame. If you are looking to return a single value, see below. Simply wrap your query in the curly brackets. The method will take that single-cell table and just return the individual value. You can also query your DMV. See below for example.</p> Query Examples<pre><code>#Run basic queries\nDAX_QUERY = \"EVALUATE TOPN(100, 'Table1')\"\nmodel.query(DAX_QUERY) # (1)\n\n#or...\nDMV_QUERY = \"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\"\nmodel.query(DMV_QUERY) # (2)\n\n#or...\nSINGLE_VALUE_QUERY_EX = \"EVALUATE {1}\"\nmodel.query(SINGLE_VALUE_QUERY_EX) # (3)\n\n#or...\nFILE_PATH = 'C:\\\\FILEPATHEXAMPLE\\\\file.dax'\nmodel.query(FILE_PATH) # (4)\n</code></pre> <ol> <li>Returns a <code>pd.DataFrame()</code>.</li> <li>Returns a <code>pd.DataFrame()</code>.</li> <li>This will return a single value. Example, <code>1</code> or <code>'string'</code>.</li> <li>This will return the same logic as above, single values if possible else will return <code>pd.DataFrame()</code>. Supply any file type.</li> </ol> <p>You can also explore your tables, partitions, columns, etc. via the attributes of your <code>Tabular</code> class.</p> Usage Examples<pre><code>model.Tables['Table Name'].refresh() # (1)\n\n#or\nmodel.Tables['Table Name'].Partitions['Partition Name'].refresh() # (2)\n\n#or\nmodel.Tables['Table Name'].Partitions[4].last_refresh() # (3)\n\n#or\nmodel.Tables['Table Name'].row_count() # (4)\n\n#or\nmodel.Tables['Table Name'].Columns['Column Name'].distinct_count() # (5)\n</code></pre> <ol> <li>Refresh a specific table. The <code>.Tables</code> is your attribute to gain access to your <code>PyTables</code> class. From that, you can iterate into specific <code>PyTable</code> classes.</li> <li>Refresh a specific partition.</li> <li>Get the last refresh time of a specific partition. Notice this time that instead of the partition name, an <code>int</code> was used to index into the specific <code>PyPartition</code>.</li> <li>Get the row count of a table.</li> <li>Get a distinct count of a column.</li> </ol> <p>Use the <code>refresh()</code> method to handle refreshes on your model. This is synchronous. Should be flexible enough to handle a variety of inputs. See PyTabular Docs for Refreshing Tables and Partitions. The most basic way to refresh is to input the table name string. The method will search for the table and output exception if unable to find it. For partitions, you will need a key, and value combination. Example, <code>{'Table1':'Partition1'}</code>. You can also take the key-value pair and iterate through a group of partitions. Example, <code>{'Table1':['Partition1','Partition2']}</code>. Rather than providing a string, you can also input the actual class. See below for those examples. You can access them from the built-in attributes <code>self.Tables</code>, <code>self.Partitions</code>.</p> Refresh Examples<pre><code>model.refresh('Table Name') # (1)\n\nmodel.refresh(['Table1','Table2','Table3']) # (2)\n\n#or...\nmodel.refresh(&lt;PyTable Class&gt;) # (3)\n\n#or...\nmodel.refresh(&lt;PyPartition Class&gt;) # (4)\n\n#or...\nmodel.refresh({'Table Name':'Partition Name'}) # (5)\n\n#or...\nmodel.refresh(\n    [\n        {\n            &lt;PyTable Class&gt;:&lt;PyPartition Class&gt;,\n            'Table Name':['Partition1','Partition2']\n        },\n        'Table Name',\n        'Table Name2'\n    ]\n) # (6)\n\n#or...\nmodel.Tables['Table Name'].refresh() # (7)\n\n#or...\nmodel.Tables['Table Name'].Partitions['Partition Name'].refresh() # (8)\n\n#or...\nmodel.refresh(['Table1','Table2'], trace = None) # (9)\n</code></pre> <ol> <li>Basic refresh of a specific table by table name string.</li> <li>Basic refresh of a group of tables by table name strings. An example is with a list, but as long as it's iterable you should be fine.</li> <li>Refresh a table by passing the <code>PyTable</code> class.</li> <li>Refresh a partition by passing the <code>PyPartition</code> class.</li> <li>Refresh a specific partition by passing a dictionary with the table name as the key and the partition name as the value.</li> <li>Get crazy. Pass all kinds of weird combinations.</li> <li>Basic refresh from a <code>PyTable</code> class.</li> <li>Basic refresh from a <code>PyPartition</code> class.</li> <li>By default, a <code>RefreshTrace</code> is started during refresh. It can be disabled by setting <code>trace = None</code>.</li> </ol>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#if-a-blank-table-then-refresh-the-table","title":"If a blank table, then refresh the table.","text":"<p>This will use the function find_zero_rows and the method refresh from the Tabular class.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ntables = model.Tables.find_zero_rows()\nif len(tables) &gt; 0:\n    tables.refresh()\n</code></pre> <p>Maybe you only want to check a subset of tables? Like <code>find()</code> tables with 'fact' in the name, then check if any facts are blank.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ntables = model.Tables.find('fact').find_zero_rows()\nif len(tables) &gt; 0:\n    tables.refresh()\n</code></pre>"},{"location":"#sneak-in-a-refresh","title":"Sneak in a refresh.","text":"<p>This will use the method is_process and the method refresh from the Tabular class. It will check the DMV to see if any jobs are currently running and classified as processing.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\nif model.is_process():\n    #do what you want if there is a refresh happening\nelse:\n    model.refresh(TABLES_OR_PARTITIONS_TO_REFRESH)\n</code></pre>"},{"location":"#show-refresh-times-in-the-model","title":"Show refresh times in the model.","text":"<p>This will use the function last_refresh and the method create_table from the Tabular class. It will search through the model for all tables and partitions and pull the 'RefreshedTime' property from it. It will return results into a pandas data frame, which will then be converted into an M expression used for a new table.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ndf = model.Tables.last_refresh()\nmodel.create_table(df, 'Refresh Times')\n</code></pre>"},{"location":"#if-bpa-violation-then-reverts-deployment","title":"If BPA Violation, then reverts deployment.","text":"<p>This uses a few things. First the BPA Class, then the TE2 Class, and will finish with the analyze_bpa method. Did not want to reinvent the wheel with the amazing work done with Tabular Editor and its BPA capabilities.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\n# Feel free to input your TE2 File path or this will download for you.\nte2 = pytabular.TabularEditor()\n# Feel free to input your own BPA file or this will download for you from:\n# https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\nbpa = pytabular.BPA()\nresults = model.analyze_bpa(te2.exe,bpa.location)\n\nif len(results) &gt; 0:\n    #Revert deployment here!\n</code></pre>"},{"location":"#loop-through-and-query-dax-files","title":"Loop through and query DAX files","text":"<p>Let's say you have multiple DAX queries you would like to store and run through as checks. The query method on the Tabular class can also take file paths. It can be any file type as it's just checking <code>os.path.isfile()</code>. But would suggest <code>.dax</code> or <code>.txt</code>. It will read the file and use that as the new <code>query_str</code> argument.</p> <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\nLIST_OF_FILE_PATHS = [\n    'C:\\\\FilePath\\\\file1.dax',\n    'C:\\\\FilePath\\\\file1.txt',\n    'C:\\\\FilePath\\\\file2.dax',\n    'C:\\\\FilePath\\\\file2.txt'\n]\nfor file_path in LIST_OF_FILE_PATHS:\n    model.query(file_path)\n</code></pre>"},{"location":"#advanced-refreshing-with-pre-and-post-checks","title":"Advanced Refreshing with Pre and Post Checks","text":"<p>Maybe you are introducing new logic to a fact table, and you need to ensure that a measure checking last month's values never changes. To do that you can take advantage of the <code>RefreshCheck</code> and <code>RefreshCheckCollection</code> classes. But using those you can build out something that would first check the results of the measure, then refresh, then check the results of the measure after the refresh, and lastly perform your desired check. In this case, the <code>pre</code> value matches the <code>post</code> value. When refreshing, if your pre does not equal post, it would fail and give an assertion error in your logging.</p> <pre><code>from pytabular import Tabular\nfrom pytabular.refresh import RefreshCheck, RefreshCheckCollection\n\nmodel = Tabular(CONNECTION_STR)\n\n# This is our custom check that we want to run after refresh.\n# Does the pre refresh value match the post refresh value.\ndef sum_of_sales_assertion(pre, post):\n    return pre == post\n\n# This is where we put it all together into the `RefreshCheck` class. Give it a name, give it a query to run, and give it the assertion you want to make.\nsum_of_last_month_sales = RefreshCheck(\n    'Last Month Sales',\n    lambda: model.query(\"EVALUATE {[Last Month Sales]}\")\n    ,sum_of_sales_assertion\n)\n\n# Here we are adding it to a `RefreshCheckCollection` because you can have more than on `Refresh_Check` to run.\nall_refresh_check = RefreshCheckCollection([sum_of_last_month_sales])\n\nmodel.Refresh(\n    'Fact Table Name',\n    refresh_checks = RefreshCheckCollection([sum_of_last_month_sales])\n\n)\n</code></pre>"},{"location":"#query-as-another-user","title":"Query as Another User","text":"<p>There are plenty of tools that allow you to query as an 'Effective User' inheriting their security when querying. This is an extremely valuable concept built natively into the .Net APIs. My only gripe is they were all UI based. This allows you to programmatically connect as an effective user and query in Python. You could easily loop through all your users to run tests on their security.</p> <pre><code>import pytabular as p\n\n#Connect to your model like usual...\nmodel = p.Tabular(CONNECTION_STR)\n\n#This will be the query I run...\nquery_str = '''\nEVALUATE\nSUMMARIZE(\n    'Product Dimension',\n    'Product Dimension'[Product Name],\n    \"Total Product Sales\", [Total Sales]\n)\n'''\n#This will be the user I want to query as...\nuser_email = 'user1@company.com'\n\n#Base line, to query as the user connecting to the model.\nmodel.query(query_str)\n\n#Option 1, Connect via connection class...\nuser1 = p.Connection(model.Server, effective_user = user_email)\nuser1.query(query_str)\n\n#Option 2, Just add Effective_User\nmodel.query(query_str, effective_user = user_email)\n\n#PyTabular will do it's best to handle multiple accounts...\n#So you won't have to reconnect on every query\n</code></pre>"},{"location":"#refresh-related-tables","title":"Refresh Related Tables","text":"<p>Ever need to refresh related tables of a Fact? Now should be a lot easier.</p> <pre><code>import pytabular as p\n\n#Connect to model\nmodel = p.Tabular(CONNECTION_STR)\n\n#Get related tables\ntables = model.Tables[TABLE_NAME].related()\n\n#Now just refresh like usual...\ntables.refresh()\n</code></pre>"},{"location":"#documenting-a-model","title":"Documenting a Model","text":"<p>The Tabular model contains a lot of information (meta-data) that can be used to generate documentation if filled in. Currently, the markdown files are generated with the Docusaurs heading in place, but this will be changed in the future to support multiple documentation platforms.</p> <p>Tip: With Tabular Editor 2 (Free) or 3 (Paid) you can easily add Descriptions, Translations (Cultures) and other additional information that can later be used for generating the documentation.</p> <p>Args:</p> <ul> <li>model: Tabular</li> <li>friendly_name: Default &gt; No Value</li> </ul> <p>To specify the location of the docs, just supply the location of where you want to store the files (=<code>save_location</code>).</p> <ul> <li>save_location: Default &gt; docs</li> </ul> <p>Each page in the generation process has its own specific name, with these arguments you can rename them to your liking.</p> <ul> <li>general_page_url: Default &gt; index.md</li> <li>measure_page_url: Default &gt; measures.md</li> <li>table_folder: Default &gt; tables</li> <li>column_page_url: Default &gt; 4-columns.md</li> </ul> <p>Folder structure</p> <pre><code>adventure-works &gt; Model Name\n\u2514\u2500\u2500\u2500 index.md &gt; General Information\n\u2514\u2500\u2500\u2500 measures.md &gt; Page with all measures in the model.\n\u2514\u2500\u2500\u2500 tables\n\u2502   \u2514\u2500\u2500\u2500 index.md &gt; Overview page with all tables in the model and a summary per table.\n|   \u2514\u2500\u2500\u2500 technical_table_name.md &gt; Details of a specific table with all columns and attributes.\n|   \u2514\u2500\u2500\u2500 ......md\n|   \u2514\u2500\u2500\u2500 ......md\n</code></pre>"},{"location":"#documenting-a-model_1","title":"Documenting a Model","text":"<p>The simplest way to document a tabular model is to connect to the model, initialize the documentation and execute <code>save_documentation()</code>.</p> <pre><code>import pytabular\n\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n\n# Initiate the Docs\ndocs = pytabular.ModelDocumenter(model)\n\n# Generate the pages.\ndocs.generate_documentation_pages()\n\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre>"},{"location":"#documenting-a-model-with-cultures","title":"Documenting a Model with Cultures","text":"<p>Some model creators choose to add cultures to a tabular model for different kinds of reasons. We can leverage those cultures to use the translation names instead of the original object names. To enable this, you can set translations to <code>True</code> and specify the culture you want to use (e.g. <code>'en-US'</code>).</p> <pre><code>import pytabular\n\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n\n# Initiate the Docs\ndocs = pytabular.ModelDocumenter(model)\n\n# Set the translation for documentation to an available culture.\n# By setting the Tranlsations to `True` it will check if it exists and if it does,\n# it will start using the translations for the docs\ndocs.set_translations(\n        enable_translations = True,\n        culture = 'en-US'\n    )\n\n# Generate the pages.\ndocs.generate_documentation_pages()\n\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre>"},{"location":"#documenting-a-power-bi-local-model","title":"Documenting a Power BI &gt; Local Model.","text":"<p>The Local model doesn't have a \"name\", only an Id. So we need to Supply a \"Friendly Name\", which will be used to store the markdown files.</p> <pre><code>import pytabular\n\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n\n# Initiate the Docs and set a friendly name to store the markdown files.\ndocs = pytabular.ModelDocumenter(\n    model = model,\n    friendly_name = \"Adventure Works\"\n)\n\n# Generate the pages.\ndocs.generate_documentation_pages()\n\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>See contributing.md</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guidelines","text":""},{"location":"CONTRIBUTING/#goal","title":"Goal","text":"<ul> <li>Make Python a first class citizen for interacting with Tabular models.</li> </ul>"},{"location":"CONTRIBUTING/#some-rules","title":"Some rules","text":"<ul> <li>See github actions for checks run on pull request.</li> <li>We <code>docstring-coverage</code> to check for 100% docstring coverage.</li> <li><code>flake8</code> also runs, but with a few extra packages. (pep8-naming, flake8-docstrings).</li> <li>Updates of any kind are welcome! Even just letting me know of the issues. Or updating docstrings...</li> <li>Limit any extra packages, see <code>pyproject.toml</code> for dependencies</li> <li>Install pre-commit. Pre-commit will run pytest, flake8, and docstr-coverage before push. <pre><code>pip install pre-commit\npre-commit install --hook-type pre-push\n</code></pre></li> <li>This will take a while... pytest will open a PBIX file in repository and run tests on it... Eventually these tests will be run on a model that is not local.</li> </ul>"},{"location":"CONTRIBUTING/#documentation-help","title":"Documentation help","text":"<ul> <li>Docstrings follow the google docstring convention. See Example.</li> <li>The <code>flake8-docstrings</code> will check that google docstring format is followed.</li> <li>Docstrings get converted to markdown with the <code>mkdocstring</code> package.</li> <li>Then gets converted to a site with the <code>mkdocs</code> package.</li> </ul>"},{"location":"CONTRIBUTING/#misc","title":"Misc","text":"<ul> <li>Work will be distributed under a MIT license.</li> </ul>"},{"location":"PyColumn/","title":"PyColumn","text":"<p>             Bases: <code>PyObject</code></p> <p>The main class to work with your columns.</p> <p>Notice the <code>PyObject</code> magic method <code>__getattr__()</code> will search in <code>self._object</code> if it is unable to find it in the default attributes. This let's you also easily check the default .Net properties. See methods for extra functionality.</p> Source code in <code>pytabular/column.py</code> <pre><code>class PyColumn(PyObject):\n    \"\"\"The main class to work with your columns.\n\n    Notice the `PyObject` magic method `__getattr__()` will search in `self._object`\n    if it is unable to find it in the default attributes.\n    This let's you also easily check the default .Net properties.\n    See methods for extra functionality.\n    \"\"\"\n\n    def __init__(self, object, table) -&gt; None:\n        \"\"\"Init that connects your column to parent table.\n\n        It will also build custom rows for your `rich`\n        display table.\n\n        Args:\n            object (Column): .Net column object.\n            table (Table): .Net table object.\n        \"\"\"\n        super().__init__(object)\n        self.Table = table\n        self._display.add_row(\n            \"Description\", str(self._object.Description), end_section=True\n        )\n        self._display.add_row(\"DataType\", str(self._object.DataType))\n        self._display.add_row(\"EncodingHint\", str(self._object.EncodingHint))\n        self._display.add_row(\"IsAvailableInMDX\", str(self._object.IsAvailableInMDX))\n        self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n        self._display.add_row(\"IsKey\", str(self._object.IsKey))\n        self._display.add_row(\"IsNullable\", str(self._object.IsNullable))\n        self._display.add_row(\"State\", str(self._object.State))\n        self._display.add_row(\"DisplayFolder\", str(self._object.DisplayFolder))\n\n    def get_dependencies(self) -&gt; pd.DataFrame:\n        \"\"\"Returns the dependant columns of a measure.\"\"\"\n        dmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where [OBJECT] = \\\n            '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\n        return self.Table.Model.query(dmv_query)\n\n    def get_sample_values(self, top_n: int = 3) -&gt; pd.DataFrame:\n        \"\"\"Get sample values of column.\"\"\"\n        column_to_sample = f\"'{self.Table.Name}'[{self.Name}]\"\n        try:\n            # adding temporary try except. TOPNSKIP will not work for directquery mode.\n            # Need an efficient way to identify if query is direct query or not.\n            dax_query = f\"\"\"EVALUATE\n                                TOPNSKIP(\n                                    {top_n},\n                                    0,\n                                    FILTER(\n                                        VALUES({column_to_sample}),\n                                        NOT ISBLANK({column_to_sample})\n                                        &amp;&amp; LEN({column_to_sample}) &gt; 0\n                                    ),\n                                    1\n                                )\n                                ORDER BY {column_to_sample}\n                        \"\"\"\n            return self.Table.Model.query(dax_query)\n        except Exception:\n            # This is really tech debt anyways and should be replaced...\n            dax_query = f\"\"\"\n            EVALUATE\n                TOPN(\n                    {top_n},\n                    FILTER(\n                        VALUES({column_to_sample}),\n                        NOT ISBLANK({column_to_sample}) &amp;&amp; LEN({column_to_sample}) &gt; 0\n                    )\n                )\n            \"\"\"\n            return self.Table.Model.query(dax_query)\n\n    def distinct_count(self, no_blank=False) -&gt; int:\n        \"\"\"Get the `DISTINCTCOUNT` of a column.\n\n        Args:\n            no_blank (bool, optional): If `True`, will call `DISTINCTCOUNTNOBLANK`.\n                Defaults to `False`.\n\n        Returns:\n            int: Number of Distinct Count from column.\n                If `no_blank == True` then will return number of distinct count no blanks.\n        \"\"\"\n        func = \"DISTINCTCOUNT\"\n        if no_blank:\n            func += \"NOBLANK\"\n        return self.Table.Model.Adomd.query(\n            f\"EVALUATE {{{func}('{self.Table.Name}'[{self.Name}])}}\"\n        )\n\n    def values(self) -&gt; pd.DataFrame:\n        \"\"\"Get single column DataFrame of values in column.\n\n        Similar to `get_sample_values()` but will return **all**.\n\n        Returns:\n            pd.DataFrame: Single column DataFrame of values.\n        \"\"\"\n        return self.Table.Model.Adomd.query(\n            f\"EVALUATE VALUES('{self.Table.Name}'[{self.Name}])\"\n        )\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Init that connects your column to parent table.</p> <p>It will also build custom rows for your <code>rich</code> display table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Column</code> <p>.Net column object.</p> required <code>table</code> <code>Table</code> <p>.Net table object.</p> required Source code in <code>pytabular/column.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n    \"\"\"Init that connects your column to parent table.\n\n    It will also build custom rows for your `rich`\n    display table.\n\n    Args:\n        object (Column): .Net column object.\n        table (Table): .Net table object.\n    \"\"\"\n    super().__init__(object)\n    self.Table = table\n    self._display.add_row(\n        \"Description\", str(self._object.Description), end_section=True\n    )\n    self._display.add_row(\"DataType\", str(self._object.DataType))\n    self._display.add_row(\"EncodingHint\", str(self._object.EncodingHint))\n    self._display.add_row(\"IsAvailableInMDX\", str(self._object.IsAvailableInMDX))\n    self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n    self._display.add_row(\"IsKey\", str(self._object.IsKey))\n    self._display.add_row(\"IsNullable\", str(self._object.IsNullable))\n    self._display.add_row(\"State\", str(self._object.State))\n    self._display.add_row(\"DisplayFolder\", str(self._object.DisplayFolder))\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Returns the dependant columns of a measure.</p> Source code in <code>pytabular/column.py</code> <pre><code>def get_dependencies(self) -&gt; pd.DataFrame:\n    \"\"\"Returns the dependant columns of a measure.\"\"\"\n    dmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where [OBJECT] = \\\n        '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\n    return self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.get_sample_values","title":"<code>get_sample_values(top_n=3)</code>","text":"<p>Get sample values of column.</p> Source code in <code>pytabular/column.py</code> <pre><code>def get_sample_values(self, top_n: int = 3) -&gt; pd.DataFrame:\n    \"\"\"Get sample values of column.\"\"\"\n    column_to_sample = f\"'{self.Table.Name}'[{self.Name}]\"\n    try:\n        # adding temporary try except. TOPNSKIP will not work for directquery mode.\n        # Need an efficient way to identify if query is direct query or not.\n        dax_query = f\"\"\"EVALUATE\n                            TOPNSKIP(\n                                {top_n},\n                                0,\n                                FILTER(\n                                    VALUES({column_to_sample}),\n                                    NOT ISBLANK({column_to_sample})\n                                    &amp;&amp; LEN({column_to_sample}) &gt; 0\n                                ),\n                                1\n                            )\n                            ORDER BY {column_to_sample}\n                    \"\"\"\n        return self.Table.Model.query(dax_query)\n    except Exception:\n        # This is really tech debt anyways and should be replaced...\n        dax_query = f\"\"\"\n        EVALUATE\n            TOPN(\n                {top_n},\n                FILTER(\n                    VALUES({column_to_sample}),\n                    NOT ISBLANK({column_to_sample}) &amp;&amp; LEN({column_to_sample}) &gt; 0\n                )\n            )\n        \"\"\"\n        return self.Table.Model.query(dax_query)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.distinct_count","title":"<code>distinct_count(no_blank=False)</code>","text":"<p>Get the <code>DISTINCTCOUNT</code> of a column.</p> <p>Parameters:</p> Name Type Description Default <code>no_blank</code> <code>bool</code> <p>If <code>True</code>, will call <code>DISTINCTCOUNTNOBLANK</code>. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of Distinct Count from column. If <code>no_blank == True</code> then will return number of distinct count no blanks.</p> Source code in <code>pytabular/column.py</code> <pre><code>def distinct_count(self, no_blank=False) -&gt; int:\n    \"\"\"Get the `DISTINCTCOUNT` of a column.\n\n    Args:\n        no_blank (bool, optional): If `True`, will call `DISTINCTCOUNTNOBLANK`.\n            Defaults to `False`.\n\n    Returns:\n        int: Number of Distinct Count from column.\n            If `no_blank == True` then will return number of distinct count no blanks.\n    \"\"\"\n    func = \"DISTINCTCOUNT\"\n    if no_blank:\n        func += \"NOBLANK\"\n    return self.Table.Model.Adomd.query(\n        f\"EVALUATE {{{func}('{self.Table.Name}'[{self.Name}])}}\"\n    )\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.values","title":"<code>values()</code>","text":"<p>Get single column DataFrame of values in column.</p> <p>Similar to <code>get_sample_values()</code> but will return all.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Single column DataFrame of values.</p> Source code in <code>pytabular/column.py</code> <pre><code>def values(self) -&gt; pd.DataFrame:\n    \"\"\"Get single column DataFrame of values in column.\n\n    Similar to `get_sample_values()` but will return **all**.\n\n    Returns:\n        pd.DataFrame: Single column DataFrame of values.\n    \"\"\"\n    return self.Table.Model.Adomd.query(\n        f\"EVALUATE VALUES('{self.Table.Name}'[{self.Name}])\"\n    )\n</code></pre>"},{"location":"PyColumns/","title":"PyColumns","text":"<p>             Bases: <code>PyObjects</code></p> <p>Groups together multiple <code>PyColumn()</code>.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyColumns</code> straight from model. For ex: <code>model.Columns</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Columns</code>. You can even filter down with <code>.Find()</code>. For example find all columns with <code>Key</code> in name. <code>model.Columns.Find('Key')</code>.</p> Source code in <code>pytabular/column.py</code> <pre><code>class PyColumns(PyObjects):\n    \"\"\"Groups together multiple `PyColumn()`.\n\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyColumns` straight from model. For ex: `model.Columns`.\n    Or through individual tables `model.Tables[TABLE_NAME].Columns`.\n    You can even filter down with `.Find()`.\n    For example find all columns with `Key` in name.\n    `model.Columns.Find('Key')`.\n    \"\"\"\n\n    def __init__(self, objects) -&gt; None:\n        \"\"\"Init extends through to the `PyObjects()` init.\"\"\"\n        super().__init__(objects)\n\n    def query_all(self, query_function: str = \"COUNTROWS(VALUES(_))\") -&gt; pd.DataFrame:\n        \"\"\"This will dynamically all columns in `PyColumns()` class.\n\n        It will replace the `_` with the column to run\n        whatever the given `query_function` value is.\n\n        Args:\n                query_function (str, optional): Default is `COUNTROWS(VALUES(_))`.\n                        The `_` gets replaced with the column in question.\n                        Method will take whatever DAX query is given.\n\n        Returns:\n                pd.DataFrame: Returns dataframe with results.\n        \"\"\"\n        logger.info(\"Beginning execution of querying every column...\")\n        logger.debug(f\"Function to be run: {query_function}\")\n        logger.debug(\"Dynamically creating DAX query...\")\n        query_str = \"EVALUATE UNION(\\n\"\n        columns = [column for column in self]\n        for column in columns:\n            if column.Type != ColumnType.RowNumber:\n                table_name = column.Table.get_Name()\n                column_name = column.get_Name()\n                dax_identifier = f\"'{table_name}'[{column_name}]\"\n                query_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\n                    \\\"Column\\\",\\\"{column_name}\\\",\\\"{query_function}\\\",\\\n                    {query_function.replace('_',dax_identifier)}),\\n\"  # noqa: E231, E261\n        query_str = f\"{query_str[:-2]})\"\n        return self[0].Table.Model.query(query_str)\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n    \"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\n\n    def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n        \"\"\"Initialization of `PyObjects`.\n\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n\n        Args:\n            objects(list[PyObject]): .Net objects.\n            parent: Parent Object. Defaults to `None`.\n        \"\"\"\n        self._objects = objects\n        self.parent = parent\n        self._display = Table(title=str(self.__class__.mro()[0]))\n        for index, obj in enumerate(self._objects):\n            self._display.add_row(str(index), obj.Name)\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getitem__(self, object):\n        \"\"\"Get item from `PyObjects`.\n\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\n        if isinstance(object, str):\n            return [pyobject for pyobject in self._objects if object == pyobject.Name][\n                -1\n            ]\n        elif isinstance(object, slice):\n            cls = type(self)\n            return cls(self._objects[object])\n        else:\n            return self._objects[object]\n\n    def __iter__(self):\n        \"\"\"Iterate through `PyObjects`.\"\"\"\n        yield from self._objects\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get length of `PyObjects`.\n\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\n        return len(self._objects)\n\n    def __iadd__(self, obj):\n        \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\n        if isinstance(obj, Iterable):\n            self._objects.__iadd__(obj._objects)\n        else:\n            self._objects.__iadd__([obj])\n\n        self.__init__(self._objects)\n        return self\n\n    def _first_visible_object(self):\n        \"\"\"Does what the method is called. Get's first `object.IsHidden is False`.\"\"\"\n        for object in self:\n            if object.IsHidden is False:\n                return object\n        return None\n\n    def find(self, object_str: str):\n        \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n        It is case insensitive.\n\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\n        items = [\n            object\n            for object in self._objects\n            if object_str.lower() in object.Name.lower()\n        ]\n        return self.__class__.mro()[0](items)\n\n    def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n        \"\"\"Gets the object based on str.\n\n        If the object isnt found, then an alternate result\n        can be supplied as an argument.\n\n        Args:\n            object_str (str): str to lookup object\n            alt_result (str): str to return when value isn't found.\n\n        Returns:\n            str: Result of the lookup, or the alternate result.\n        \"\"\"\n        try:\n            return self.__getitem__(object_str)\n        except Exception as e:\n            Console().print(e)\n\n        return alt_result\n</code></pre>"},{"location":"PyColumns/#pytabular.column.PyColumns.__init__","title":"<code>__init__(objects)</code>","text":"<p>Init extends through to the <code>PyObjects()</code> init.</p> Source code in <code>pytabular/column.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n    \"\"\"Init extends through to the `PyObjects()` init.\"\"\"\n    super().__init__(objects)\n</code></pre>"},{"location":"PyColumns/#pytabular.column.PyColumns.query_all","title":"<code>query_all(query_function='COUNTROWS(VALUES(_))')</code>","text":"<p>This will dynamically all columns in <code>PyColumns()</code> class.</p> <p>It will replace the <code>_</code> with the column to run whatever the given <code>query_function</code> value is.</p> <p>Parameters:</p> Name Type Description Default <code>query_function</code> <code>str</code> <p>Default is <code>COUNTROWS(VALUES(_))</code>. The <code>_</code> gets replaced with the column in question. Method will take whatever DAX query is given.</p> <code>'COUNTROWS(VALUES(_))'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Returns dataframe with results.</p> Source code in <code>pytabular/column.py</code> <pre><code>def query_all(self, query_function: str = \"COUNTROWS(VALUES(_))\") -&gt; pd.DataFrame:\n    \"\"\"This will dynamically all columns in `PyColumns()` class.\n\n    It will replace the `_` with the column to run\n    whatever the given `query_function` value is.\n\n    Args:\n            query_function (str, optional): Default is `COUNTROWS(VALUES(_))`.\n                    The `_` gets replaced with the column in question.\n                    Method will take whatever DAX query is given.\n\n    Returns:\n            pd.DataFrame: Returns dataframe with results.\n    \"\"\"\n    logger.info(\"Beginning execution of querying every column...\")\n    logger.debug(f\"Function to be run: {query_function}\")\n    logger.debug(\"Dynamically creating DAX query...\")\n    query_str = \"EVALUATE UNION(\\n\"\n    columns = [column for column in self]\n    for column in columns:\n        if column.Type != ColumnType.RowNumber:\n            table_name = column.Table.get_Name()\n            column_name = column.get_Name()\n            dax_identifier = f\"'{table_name}'[{column_name}]\"\n            query_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\n                \\\"Column\\\",\\\"{column_name}\\\",\\\"{query_function}\\\",\\\n                {query_function.replace('_',dax_identifier)}),\\n\"  # noqa: E231, E261\n    query_str = f\"{query_str[:-2]})\"\n    return self[0].Table.Model.query(query_str)\n</code></pre>"},{"location":"PyColumns/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n    \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n    It is case insensitive.\n\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\n    items = [\n        object\n        for object in self._objects\n        if object_str.lower() in object.Name.lower()\n    ]\n    return self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyMeasure/","title":"PyMeasure","text":"<p>             Bases: <code>PyObject</code></p> <p>Main class for interacting with measures.</p> <p>See methods for available functionality.</p> Source code in <code>pytabular/measure.py</code> <pre><code>class PyMeasure(PyObject):\n    \"\"\"Main class for interacting with measures.\n\n    See methods for available functionality.\n    \"\"\"\n\n    def __init__(self, object, table) -&gt; None:\n        \"\"\"Connects measure to parent `PyTable`.\n\n        It will also add some custom rows for the `rich`\n        table display.\n\n        Args:\n            object (object.PyObject): The .Net measure object.\n            table (table.PyTable): The parent `PyTable`.\n        \"\"\"\n        super().__init__(object)\n        self.Table = table\n        self._display.add_row(\"Expression\", self._object.Expression, end_section=True)\n        self._display.add_row(\"DisplayFolder\", self._object.DisplayFolder)\n        self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n        self._display.add_row(\"FormatString\", self._object.FormatString)\n\n    def get_dependencies(self) -&gt; pd.DataFrame:\n        \"\"\"Get the dependant objects of a measure.\n\n        Returns:\n            pd.DataFrame: The Return Value is a Pandas dataframe\n                            which displays all the dependancies\n                            of the object.\n\n        \"\"\"\n        dmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where \\\n            [OBJECT] = '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\n        return self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyMeasure/#pytabular.measure.PyMeasure.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Connects measure to parent <code>PyTable</code>.</p> <p>It will also add some custom rows for the <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyObject</code> <p>The .Net measure object.</p> required <code>table</code> <code>PyTable</code> <p>The parent <code>PyTable</code>.</p> required Source code in <code>pytabular/measure.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n    \"\"\"Connects measure to parent `PyTable`.\n\n    It will also add some custom rows for the `rich`\n    table display.\n\n    Args:\n        object (object.PyObject): The .Net measure object.\n        table (table.PyTable): The parent `PyTable`.\n    \"\"\"\n    super().__init__(object)\n    self.Table = table\n    self._display.add_row(\"Expression\", self._object.Expression, end_section=True)\n    self._display.add_row(\"DisplayFolder\", self._object.DisplayFolder)\n    self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n    self._display.add_row(\"FormatString\", self._object.FormatString)\n</code></pre>"},{"location":"PyMeasure/#pytabular.measure.PyMeasure.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get the dependant objects of a measure.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The Return Value is a Pandas dataframe             which displays all the dependancies             of the object.</p> Source code in <code>pytabular/measure.py</code> <pre><code>def get_dependencies(self) -&gt; pd.DataFrame:\n    \"\"\"Get the dependant objects of a measure.\n\n    Returns:\n        pd.DataFrame: The Return Value is a Pandas dataframe\n                        which displays all the dependancies\n                        of the object.\n\n    \"\"\"\n    dmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where \\\n        [OBJECT] = '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\n    return self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyMeasures/","title":"PyMeasures","text":"<p>             Bases: <code>PyObjects</code></p> <p>Groups together multiple measures.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyMeasures</code> straight from model. For ex: <code>model.Measures</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Measures</code>. You can even filter down with <code>.find()</code>. For example find all measures with <code>ratio</code> in name. <code>model.Measures.find('ratio')</code>.</p> Source code in <code>pytabular/measure.py</code> <pre><code>class PyMeasures(PyObjects):\n    \"\"\"Groups together multiple measures.\n\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyMeasures` straight from model. For ex: `model.Measures`.\n    Or through individual tables `model.Tables[TABLE_NAME].Measures`.\n    You can even filter down with `.find()`.\n    For example find all measures with `ratio` in name.\n    `model.Measures.find('ratio')`.\n    \"\"\"\n\n    def __init__(self, objects, parent=None) -&gt; None:\n        \"\"\"Extends init from `PyObjects`.\"\"\"\n        super().__init__(objects, parent)\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Made `PyMeasures` just sends args through to `add_measure`.\"\"\"\n        return self.add_measure(*args, **kwargs)\n\n    def add_measure(\n        self, name: str, expression: str, auto_save: bool = True, **kwargs\n    ) -&gt; PyMeasure:\n        \"\"\"Add or replace measures from `PyMeasures` class.\n\n        Required is just `name` and `expression`.\n        But you can pass through any properties you wish to update as a kwarg.\n        This method is also used when calling the class,\n        so you can create a new measure that way.\n        kwargs will be set via the `settr` built in function.\n        Anything in the .Net Measures properties should be viable.\n        [Measure Class](https://learn.microsoft.com/en-us/dotnet/api/microsoft.analysisservices.measure?#properties) # noqa: E501\n\n        Example:\n            ```\n            expr = \"SUM('Orders'[Amount])\"\n            model.Measures.add_measure(\"Orders Total\", expr)\n            ```\n\n            ```\n            expr = \"SUM('Orders'[Amount])\"\n            model.Measures.add_measure(\"Orders Total\", expr, Folder = 'Measures')\n            ```\n\n            ```\n            expr = \"SUM('Orders'[Amount])\"\n            model.Tables['Sales'].Measures('Total Sales', expr, Folder = 'Measures')\n            ```\n\n        Args:\n            name (str): Name of the measure. Brackets ARE NOT required.\n            expression (str): DAX expression for the measure.\n            auto_save (bool, optional): Automatically save changes after measure creations.\n                Defaults to `True`\n        \"\"\"\n        if isinstance(self.parent._object, Table):\n            table = self.parent\n            model = self.parent.Model\n        else:\n            table = self.parent.Tables._first_visible_object()\n            model = self.parent\n\n        logger.debug(f\"Creating measure in {table.Name}\")\n\n        new = True\n\n        try:\n            logger.debug(f\"Measure {name} exists... Overwriting...\")\n            new_measure = self.parent.Measures[name]._object\n            new = False\n        except IndexError:\n            logger.debug(f\"Creating new measure {name}\")\n            new_measure = Measure()\n\n        new_measure.set_Name(name)\n        new_measure.set_Expression(expression)\n\n        for key, value in kwargs.items():\n            logger.debug(f\"Setting '{key}'='{value}' for {new_measure.Name}\")\n            setattr(new_measure, key, value)\n\n        if new:\n            measures = table.get_Measures()\n            measures.Add(new_measure)\n        if auto_save:\n            model.save_changes()\n            return model.Measures[new_measure.Name]\n        else:\n            return True\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n    \"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\n\n    def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n        \"\"\"Initialization of `PyObjects`.\n\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n\n        Args:\n            objects(list[PyObject]): .Net objects.\n            parent: Parent Object. Defaults to `None`.\n        \"\"\"\n        self._objects = objects\n        self.parent = parent\n        self._display = Table(title=str(self.__class__.mro()[0]))\n        for index, obj in enumerate(self._objects):\n            self._display.add_row(str(index), obj.Name)\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getitem__(self, object):\n        \"\"\"Get item from `PyObjects`.\n\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\n        if isinstance(object, str):\n            return [pyobject for pyobject in self._objects if object == pyobject.Name][\n                -1\n            ]\n        elif isinstance(object, slice):\n            cls = type(self)\n            return cls(self._objects[object])\n        else:\n            return self._objects[object]\n\n    def __iter__(self):\n        \"\"\"Iterate through `PyObjects`.\"\"\"\n        yield from self._objects\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get length of `PyObjects`.\n\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\n        return len(self._objects)\n\n    def __iadd__(self, obj):\n        \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\n        if isinstance(obj, Iterable):\n            self._objects.__iadd__(obj._objects)\n        else:\n            self._objects.__iadd__([obj])\n\n        self.__init__(self._objects)\n        return self\n\n    def _first_visible_object(self):\n        \"\"\"Does what the method is called. Get's first `object.IsHidden is False`.\"\"\"\n        for object in self:\n            if object.IsHidden is False:\n                return object\n        return None\n\n    def find(self, object_str: str):\n        \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n        It is case insensitive.\n\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\n        items = [\n            object\n            for object in self._objects\n            if object_str.lower() in object.Name.lower()\n        ]\n        return self.__class__.mro()[0](items)\n\n    def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n        \"\"\"Gets the object based on str.\n\n        If the object isnt found, then an alternate result\n        can be supplied as an argument.\n\n        Args:\n            object_str (str): str to lookup object\n            alt_result (str): str to return when value isn't found.\n\n        Returns:\n            str: Result of the lookup, or the alternate result.\n        \"\"\"\n        try:\n            return self.__getitem__(object_str)\n        except Exception as e:\n            Console().print(e)\n\n        return alt_result\n</code></pre>"},{"location":"PyMeasures/#pytabular.measure.PyMeasures.__init__","title":"<code>__init__(objects, parent=None)</code>","text":"<p>Extends init from <code>PyObjects</code>.</p> Source code in <code>pytabular/measure.py</code> <pre><code>def __init__(self, objects, parent=None) -&gt; None:\n    \"\"\"Extends init from `PyObjects`.\"\"\"\n    super().__init__(objects, parent)\n</code></pre>"},{"location":"PyMeasures/#pytabular.measure.PyMeasures.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Made <code>PyMeasures</code> just sends args through to <code>add_measure</code>.</p> Source code in <code>pytabular/measure.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    \"\"\"Made `PyMeasures` just sends args through to `add_measure`.\"\"\"\n    return self.add_measure(*args, **kwargs)\n</code></pre>"},{"location":"PyMeasures/#pytabular.measure.PyMeasures.add_measure","title":"<code>add_measure(name, expression, auto_save=True, **kwargs)</code>","text":"<p>Add or replace measures from <code>PyMeasures</code> class.</p> <p>Required is just <code>name</code> and <code>expression</code>. But you can pass through any properties you wish to update as a kwarg. This method is also used when calling the class, so you can create a new measure that way. kwargs will be set via the <code>settr</code> built in function. Anything in the .Net Measures properties should be viable. Measure Class # noqa: E501</p> Example <pre><code>expr = \"SUM('Orders'[Amount])\"\nmodel.Measures.add_measure(\"Orders Total\", expr)\n</code></pre> <pre><code>expr = \"SUM('Orders'[Amount])\"\nmodel.Measures.add_measure(\"Orders Total\", expr, Folder = 'Measures')\n</code></pre> <pre><code>expr = \"SUM('Orders'[Amount])\"\nmodel.Tables['Sales'].Measures('Total Sales', expr, Folder = 'Measures')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the measure. Brackets ARE NOT required.</p> required <code>expression</code> <code>str</code> <p>DAX expression for the measure.</p> required <code>auto_save</code> <code>bool</code> <p>Automatically save changes after measure creations. Defaults to <code>True</code></p> <code>True</code> Source code in <code>pytabular/measure.py</code> <pre><code>def add_measure(\n    self, name: str, expression: str, auto_save: bool = True, **kwargs\n) -&gt; PyMeasure:\n    \"\"\"Add or replace measures from `PyMeasures` class.\n\n    Required is just `name` and `expression`.\n    But you can pass through any properties you wish to update as a kwarg.\n    This method is also used when calling the class,\n    so you can create a new measure that way.\n    kwargs will be set via the `settr` built in function.\n    Anything in the .Net Measures properties should be viable.\n    [Measure Class](https://learn.microsoft.com/en-us/dotnet/api/microsoft.analysisservices.measure?#properties) # noqa: E501\n\n    Example:\n        ```\n        expr = \"SUM('Orders'[Amount])\"\n        model.Measures.add_measure(\"Orders Total\", expr)\n        ```\n\n        ```\n        expr = \"SUM('Orders'[Amount])\"\n        model.Measures.add_measure(\"Orders Total\", expr, Folder = 'Measures')\n        ```\n\n        ```\n        expr = \"SUM('Orders'[Amount])\"\n        model.Tables['Sales'].Measures('Total Sales', expr, Folder = 'Measures')\n        ```\n\n    Args:\n        name (str): Name of the measure. Brackets ARE NOT required.\n        expression (str): DAX expression for the measure.\n        auto_save (bool, optional): Automatically save changes after measure creations.\n            Defaults to `True`\n    \"\"\"\n    if isinstance(self.parent._object, Table):\n        table = self.parent\n        model = self.parent.Model\n    else:\n        table = self.parent.Tables._first_visible_object()\n        model = self.parent\n\n    logger.debug(f\"Creating measure in {table.Name}\")\n\n    new = True\n\n    try:\n        logger.debug(f\"Measure {name} exists... Overwriting...\")\n        new_measure = self.parent.Measures[name]._object\n        new = False\n    except IndexError:\n        logger.debug(f\"Creating new measure {name}\")\n        new_measure = Measure()\n\n    new_measure.set_Name(name)\n    new_measure.set_Expression(expression)\n\n    for key, value in kwargs.items():\n        logger.debug(f\"Setting '{key}'='{value}' for {new_measure.Name}\")\n        setattr(new_measure, key, value)\n\n    if new:\n        measures = table.get_Measures()\n        measures.Add(new_measure)\n    if auto_save:\n        model.save_changes()\n        return model.Measures[new_measure.Name]\n    else:\n        return True\n</code></pre>"},{"location":"PyMeasures/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n    \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n    It is case insensitive.\n\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\n    items = [\n        object\n        for object in self._objects\n        if object_str.lower() in object.Name.lower()\n    ]\n    return self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyObject/","title":"PyObject","text":"<p>             Bases: <code>ABC</code></p> <p>The main parent class for your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. <code>__getattr__()</code> will check in <code>self._object</code>, if unable to find anything in <code>self</code>. This will let you pull properties from the main .Net class.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObject(ABC):\n    \"\"\"The main parent class for your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    `__getattr__()` will check in `self._object`, if unable to find anything in `self`.\n    This will let you pull properties from the main .Net class.\n    \"\"\"\n\n    def __init__(self, object) -&gt; None:\n        \"\"\"Init to create your PyObject.\n\n        This will take the `object` and\n        set as an attribute to the `self._object`.\n        You can use that if you want to interact directly with the .Net object.\n        It will also begin to build out a default `rich` table display.\n\n        Args:\n            object (.Net object): A .Net object.\n        \"\"\"\n        self._object = object\n        self._display = Table(title=self.Name)\n        self._display.add_column(\n            \"Properties\", justify=\"right\", style=\"cyan\", no_wrap=True\n        )\n        self._display.add_column(\"\", justify=\"left\", style=\"magenta\", no_wrap=False)\n\n        self._display.add_row(\"Name\", self.Name)\n        self._display.add_row(\"ObjectType\", str(self.ObjectType))\n        if str(self.ObjectType) not in \"Model\":\n            self._display.add_row(\"ParentName\", self.Parent.Name)\n            self._display.add_row(\n                \"ParentObjectType\",\n                str(self.Parent.ObjectType),\n                end_section=True,\n            )\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getattr__(self, attr):\n        \"\"\"Searches in `self._object`.\"\"\"\n        return getattr(self._object, attr)\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__init__","title":"<code>__init__(object)</code>","text":"<p>Init to create your PyObject.</p> <p>This will take the <code>object</code> and set as an attribute to the <code>self._object</code>. You can use that if you want to interact directly with the .Net object. It will also begin to build out a default <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>.Net object</code> <p>A .Net object.</p> required Source code in <code>pytabular/object.py</code> <pre><code>def __init__(self, object) -&gt; None:\n    \"\"\"Init to create your PyObject.\n\n    This will take the `object` and\n    set as an attribute to the `self._object`.\n    You can use that if you want to interact directly with the .Net object.\n    It will also begin to build out a default `rich` table display.\n\n    Args:\n        object (.Net object): A .Net object.\n    \"\"\"\n    self._object = object\n    self._display = Table(title=self.Name)\n    self._display.add_column(\n        \"Properties\", justify=\"right\", style=\"cyan\", no_wrap=True\n    )\n    self._display.add_column(\"\", justify=\"left\", style=\"magenta\", no_wrap=False)\n\n    self._display.add_row(\"Name\", self.Name)\n    self._display.add_row(\"ObjectType\", str(self.ObjectType))\n    if str(self.ObjectType) not in \"Model\":\n        self._display.add_row(\"ParentName\", self.Parent.Name)\n        self._display.add_row(\n            \"ParentObjectType\",\n            str(self.Parent.ObjectType),\n            end_section=True,\n        )\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>See Rich Repr.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __rich_repr__(self) -&gt; str:\n    \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n    Console().print(self._display)\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Searches in <code>self._object</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __getattr__(self, attr):\n    \"\"\"Searches in `self._object`.\"\"\"\n    return getattr(self._object, attr)\n</code></pre>"},{"location":"PyObjects/","title":"PyObjects","text":"<p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n    \"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\n\n    def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n        \"\"\"Initialization of `PyObjects`.\n\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n\n        Args:\n            objects(list[PyObject]): .Net objects.\n            parent: Parent Object. Defaults to `None`.\n        \"\"\"\n        self._objects = objects\n        self.parent = parent\n        self._display = Table(title=str(self.__class__.mro()[0]))\n        for index, obj in enumerate(self._objects):\n            self._display.add_row(str(index), obj.Name)\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getitem__(self, object):\n        \"\"\"Get item from `PyObjects`.\n\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\n        if isinstance(object, str):\n            return [pyobject for pyobject in self._objects if object == pyobject.Name][\n                -1\n            ]\n        elif isinstance(object, slice):\n            cls = type(self)\n            return cls(self._objects[object])\n        else:\n            return self._objects[object]\n\n    def __iter__(self):\n        \"\"\"Iterate through `PyObjects`.\"\"\"\n        yield from self._objects\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get length of `PyObjects`.\n\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\n        return len(self._objects)\n\n    def __iadd__(self, obj):\n        \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\n        if isinstance(obj, Iterable):\n            self._objects.__iadd__(obj._objects)\n        else:\n            self._objects.__iadd__([obj])\n\n        self.__init__(self._objects)\n        return self\n\n    def _first_visible_object(self):\n        \"\"\"Does what the method is called. Get's first `object.IsHidden is False`.\"\"\"\n        for object in self:\n            if object.IsHidden is False:\n                return object\n        return None\n\n    def find(self, object_str: str):\n        \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n        It is case insensitive.\n\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\n        items = [\n            object\n            for object in self._objects\n            if object_str.lower() in object.Name.lower()\n        ]\n        return self.__class__.mro()[0](items)\n\n    def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n        \"\"\"Gets the object based on str.\n\n        If the object isnt found, then an alternate result\n        can be supplied as an argument.\n\n        Args:\n            object_str (str): str to lookup object\n            alt_result (str): str to return when value isn't found.\n\n        Returns:\n            str: Result of the lookup, or the alternate result.\n        \"\"\"\n        try:\n            return self.__getitem__(object_str)\n        except Exception as e:\n            Console().print(e)\n\n        return alt_result\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__init__","title":"<code>__init__(objects, parent=None)</code>","text":"<p>Initialization of <code>PyObjects</code>.</p> <p>Takes the objects in something that is iterable. Then will build a default <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>objects(list[PyObject])</code> <p>.Net objects.</p> required <code>parent</code> <p>Parent Object. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>pytabular/object.py</code> <pre><code>def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n    \"\"\"Initialization of `PyObjects`.\n\n    Takes the objects in something that is iterable.\n    Then will build a default `rich` table display.\n\n    Args:\n        objects(list[PyObject]): .Net objects.\n        parent: Parent Object. Defaults to `None`.\n    \"\"\"\n    self._objects = objects\n    self.parent = parent\n    self._display = Table(title=str(self.__class__.mro()[0]))\n    for index, obj in enumerate(self._objects):\n        self._display.add_row(str(index), obj.Name)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>See Rich Repr.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __rich_repr__(self) -&gt; str:\n    \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n    Console().print(self._display)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__getitem__","title":"<code>__getitem__(object)</code>","text":"<p>Get item from <code>PyObjects</code>.</p> <p>Checks if item is str or int. If string will iterate through and try to find matching name. Otherwise, will call into <code>self._objects[int]</code> to retrieve item.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __getitem__(self, object):\n    \"\"\"Get item from `PyObjects`.\n\n    Checks if item is str or int.\n    If string will iterate through and try to find matching name.\n    Otherwise, will call into `self._objects[int]` to retrieve item.\n    \"\"\"\n    if isinstance(object, str):\n        return [pyobject for pyobject in self._objects if object == pyobject.Name][\n            -1\n        ]\n    elif isinstance(object, slice):\n        cls = type(self)\n        return cls(self._objects[object])\n    else:\n        return self._objects[object]\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through <code>PyObjects</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate through `PyObjects`.\"\"\"\n    yield from self._objects\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__len__","title":"<code>__len__()</code>","text":"<p>Get length of <code>PyObjects</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of PyObject in PyObjects</p> Source code in <code>pytabular/object.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get length of `PyObjects`.\n\n    Returns:\n        int: Number of PyObject in PyObjects\n    \"\"\"\n    return len(self._objects)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__iadd__","title":"<code>__iadd__(obj)</code>","text":"<p>Add a <code>PyObject</code> or <code>PyObjects</code> to your current <code>PyObjects</code> class.</p> <p>This is useful for building out a custom <code>PyObjects</code> class to work with.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __iadd__(self, obj):\n    \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n    This is useful for building out a custom `PyObjects` class to work with.\n    \"\"\"\n    if isinstance(obj, Iterable):\n        self._objects.__iadd__(obj._objects)\n    else:\n        self._objects.__iadd__([obj])\n\n    self.__init__(self._objects)\n    return self\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n    \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n    It is case insensitive.\n\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\n    items = [\n        object\n        for object in self._objects\n        if object_str.lower() in object.Name.lower()\n    ]\n    return self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.get","title":"<code>get(object_str, alt_result='')</code>","text":"<p>Gets the object based on str.</p> <p>If the object isnt found, then an alternate result can be supplied as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup object</p> required <code>alt_result</code> <code>str</code> <p>str to return when value isn't found.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Result of the lookup, or the alternate result.</p> Source code in <code>pytabular/object.py</code> <pre><code>def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n    \"\"\"Gets the object based on str.\n\n    If the object isnt found, then an alternate result\n    can be supplied as an argument.\n\n    Args:\n        object_str (str): str to lookup object\n        alt_result (str): str to return when value isn't found.\n\n    Returns:\n        str: Result of the lookup, or the alternate result.\n    \"\"\"\n    try:\n        return self.__getitem__(object_str)\n    except Exception as e:\n        Console().print(e)\n\n    return alt_result\n</code></pre>"},{"location":"PyPartition/","title":"PyPartition","text":"<p>             Bases: <code>PyObject</code></p> <p>Main class for interacting with partitions.</p> <p>See methods for available uses.</p> Source code in <code>pytabular/partition.py</code> <pre><code>class PyPartition(PyObject):\n    \"\"\"Main class for interacting with partitions.\n\n    See methods for available uses.\n    \"\"\"\n\n    def __init__(self, object, table) -&gt; None:\n        \"\"\"Extends from `PyObject` class.\n\n        Adds a few custom rows to `rich` table for the partition.\n\n        Args:\n            object (Partition): .Net Partition object.\n            table (PyTable): Parent table of the partition in question.\n        \"\"\"\n        super().__init__(object)\n        self.Table = table\n        self._display.add_row(\"Mode\", str(self._object.Mode))\n        self._display.add_row(\"State\", str(self._object.State))\n        self._display.add_row(\n            \"SourceType\", str(self._object.SourceType), end_section=True\n        )\n        self._display.add_row(\n            \"RefreshedTime\", self.last_refresh().strftime(\"%m/%d/%Y, %H:%M:%S\")\n        )\n\n    def last_refresh(self) -&gt; datetime:\n        \"\"\"Queries `RefreshedTime` attribute in the partition.\n\n        Converts from C# Ticks to Python datetime.\n\n        Returns:\n            datetime.datetime: Last Refreshed time of Partition in datetime format\n        \"\"\"\n        return ticks_to_datetime(self.RefreshedTime.Ticks)\n\n    def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n        \"\"\"Same method from Model Refresh.\n\n        You can pass through any extra parameters. For example:\n        `Tabular().Tables['Table Name'].Partitions[0].refresh()`\n\n        Returns:\n            pd.DataFrame: Returns pandas dataframe with some refresh details\n        \"\"\"\n        return self.Table.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Extends from <code>PyObject</code> class.</p> <p>Adds a few custom rows to <code>rich</code> table for the partition.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Partition</code> <p>.Net Partition object.</p> required <code>table</code> <code>PyTable</code> <p>Parent table of the partition in question.</p> required Source code in <code>pytabular/partition.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n    \"\"\"Extends from `PyObject` class.\n\n    Adds a few custom rows to `rich` table for the partition.\n\n    Args:\n        object (Partition): .Net Partition object.\n        table (PyTable): Parent table of the partition in question.\n    \"\"\"\n    super().__init__(object)\n    self.Table = table\n    self._display.add_row(\"Mode\", str(self._object.Mode))\n    self._display.add_row(\"State\", str(self._object.State))\n    self._display.add_row(\n        \"SourceType\", str(self._object.SourceType), end_section=True\n    )\n    self._display.add_row(\n        \"RefreshedTime\", self.last_refresh().strftime(\"%m/%d/%Y, %H:%M:%S\")\n    )\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.last_refresh","title":"<code>last_refresh()</code>","text":"<p>Queries <code>RefreshedTime</code> attribute in the partition.</p> <p>Converts from C# Ticks to Python datetime.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: Last Refreshed time of Partition in datetime format</p> Source code in <code>pytabular/partition.py</code> <pre><code>def last_refresh(self) -&gt; datetime:\n    \"\"\"Queries `RefreshedTime` attribute in the partition.\n\n    Converts from C# Ticks to Python datetime.\n\n    Returns:\n        datetime.datetime: Last Refreshed time of Partition in datetime format\n    \"\"\"\n    return ticks_to_datetime(self.RefreshedTime.Ticks)\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Same method from Model Refresh.</p> <p>You can pass through any extra parameters. For example: <code>Tabular().Tables['Table Name'].Partitions[0].refresh()</code></p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Returns pandas dataframe with some refresh details</p> Source code in <code>pytabular/partition.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"Same method from Model Refresh.\n\n    You can pass through any extra parameters. For example:\n    `Tabular().Tables['Table Name'].Partitions[0].refresh()`\n\n    Returns:\n        pd.DataFrame: Returns pandas dataframe with some refresh details\n    \"\"\"\n    return self.Table.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartitions/","title":"PyPartitions","text":"<p>             Bases: <code>PyObjects</code></p> <p>Groups together multiple partitions.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyPartitions</code> straight from model. For ex: <code>model.Partitions</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Partitions</code>. You can even filter down with <code>.find()</code>. For example find partitions with <code>prev-year</code> in name. <code>model.Partitions.find('prev-year')</code>.</p> Source code in <code>pytabular/partition.py</code> <pre><code>class PyPartitions(PyObjects):\n    \"\"\"Groups together multiple partitions.\n\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyPartitions` straight from model.\n    For ex: `model.Partitions`.\n    Or through individual tables `model.Tables[TABLE_NAME].Partitions`.\n    You can even filter down with `.find()`. For example find partitions with `prev-year` in name.\n    `model.Partitions.find('prev-year')`.\n    \"\"\"\n\n    def __init__(self, objects) -&gt; None:\n        \"\"\"Extends through to `PyObjects`.\"\"\"\n        super().__init__(objects)\n\n    def refresh(self, *args, **kwargs):\n        \"\"\"Refreshes all `PyPartition`(s) in class.\"\"\"\n        model = self[0].Table.Model\n        return model.refresh(self, *args, **kwargs)\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n    \"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\n\n    def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n        \"\"\"Initialization of `PyObjects`.\n\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n\n        Args:\n            objects(list[PyObject]): .Net objects.\n            parent: Parent Object. Defaults to `None`.\n        \"\"\"\n        self._objects = objects\n        self.parent = parent\n        self._display = Table(title=str(self.__class__.mro()[0]))\n        for index, obj in enumerate(self._objects):\n            self._display.add_row(str(index), obj.Name)\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getitem__(self, object):\n        \"\"\"Get item from `PyObjects`.\n\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\n        if isinstance(object, str):\n            return [pyobject for pyobject in self._objects if object == pyobject.Name][\n                -1\n            ]\n        elif isinstance(object, slice):\n            cls = type(self)\n            return cls(self._objects[object])\n        else:\n            return self._objects[object]\n\n    def __iter__(self):\n        \"\"\"Iterate through `PyObjects`.\"\"\"\n        yield from self._objects\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get length of `PyObjects`.\n\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\n        return len(self._objects)\n\n    def __iadd__(self, obj):\n        \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\n        if isinstance(obj, Iterable):\n            self._objects.__iadd__(obj._objects)\n        else:\n            self._objects.__iadd__([obj])\n\n        self.__init__(self._objects)\n        return self\n\n    def _first_visible_object(self):\n        \"\"\"Does what the method is called. Get's first `object.IsHidden is False`.\"\"\"\n        for object in self:\n            if object.IsHidden is False:\n                return object\n        return None\n\n    def find(self, object_str: str):\n        \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n        It is case insensitive.\n\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\n        items = [\n            object\n            for object in self._objects\n            if object_str.lower() in object.Name.lower()\n        ]\n        return self.__class__.mro()[0](items)\n\n    def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n        \"\"\"Gets the object based on str.\n\n        If the object isnt found, then an alternate result\n        can be supplied as an argument.\n\n        Args:\n            object_str (str): str to lookup object\n            alt_result (str): str to return when value isn't found.\n\n        Returns:\n            str: Result of the lookup, or the alternate result.\n        \"\"\"\n        try:\n            return self.__getitem__(object_str)\n        except Exception as e:\n            Console().print(e)\n\n        return alt_result\n</code></pre>"},{"location":"PyPartitions/#pytabular.partition.PyPartitions.__init__","title":"<code>__init__(objects)</code>","text":"<p>Extends through to <code>PyObjects</code>.</p> Source code in <code>pytabular/partition.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n    \"\"\"Extends through to `PyObjects`.\"\"\"\n    super().__init__(objects)\n</code></pre>"},{"location":"PyPartitions/#pytabular.partition.PyPartitions.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Refreshes all <code>PyPartition</code>(s) in class.</p> Source code in <code>pytabular/partition.py</code> <pre><code>def refresh(self, *args, **kwargs):\n    \"\"\"Refreshes all `PyPartition`(s) in class.\"\"\"\n    model = self[0].Table.Model\n    return model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartitions/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n    \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n    It is case insensitive.\n\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\n    items = [\n        object\n        for object in self._objects\n        if object_str.lower() in object.Name.lower()\n    ]\n    return self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyTable/","title":"PyTable","text":"<p>             Bases: <code>PyObject</code></p> <p>The main PyTable class to interact with the tables in model.</p> <p>Attributes:</p> Name Type Description <code>Name</code> <code>str</code> <p>Name of table.</p> <code>IsHidden</code> <code>bool</code> <p>Is the table hidden.</p> <code>Description</code> <code>str</code> <p>The description of the table.</p> <code>Model</code> <code>Tabular</code> <p>The parent <code>Tabular()</code> class.</p> <code>Partitions</code> <code>PyPartitions</code> <p>The <code>PyPartitions()</code> in the table.</p> <code>Columns</code> <code>PyColumns</code> <p>The <code>PyColumns()</code> in the table.</p> <code>Measures</code> <code>PyMeasures</code> <p>The <code>PyMeasures()</code> in the table.</p> Example Passing through PyTable to PyPartition<pre><code>model.Tables[0].Partitions['Last Year'].refresh() # (1)\n</code></pre> <ol> <li>This shows the ability to travel through your model to a specific partition and then running a refresh for that specific partition. <code>model</code> -&gt; <code>PyTables</code> -&gt; <code>PyTable</code> (1st index) -&gt; <code>PyPartitions</code> -&gt; <code>PyPartition</code> (.Name == 'Last Year') -&gt; <code>.refresh()</code></li> </ol> Source code in <code>pytabular/table.py</code> <pre><code>class PyTable(PyObject):\n    \"\"\"The main PyTable class to interact with the tables in model.\n\n    Attributes:\n        Name (str): Name of table.\n        IsHidden (bool): Is the table hidden.\n        Description (str): The description of the table.\n        Model (Tabular): The parent `Tabular()` class.\n        Partitions (PyPartitions): The `PyPartitions()` in the table.\n        Columns (PyColumns): The `PyColumns()` in the table.\n        Measures (PyMeasures): The `PyMeasures()` in the table.\n\n    Example:\n        ```python title=\"Passing through PyTable to PyPartition\"\n\n        model.Tables[0].Partitions['Last Year'].refresh() # (1)\n        ```\n\n        1. This shows the ability to travel through your model\n        to a specific partition and then running a refresh\n        for that specific partition.\n        `model` -&gt; `PyTables` -&gt; `PyTable` (1st index) -&gt; `PyPartitions`\n        -&gt; `PyPartition` (.Name == 'Last Year') -&gt; `.refresh()`\n    \"\"\"\n\n    def __init__(self, object, model) -&gt; None:\n        \"\"\"Init extends from `PyObject` class.\n\n        Also adds a few specific rows to the `rich`\n        table.\n\n        Args:\n            object (Table): The actual .Net table.\n            model (Tabular): The model that the table is in.\n        \"\"\"\n        super().__init__(object)\n        self.Model = model\n        self.Partitions: PyPartitions = PyPartitions(\n            [\n                PyPartition(partition, self)\n                for partition in self._object.Partitions.GetEnumerator()\n            ]\n        )\n        self.Columns: PyColumns = PyColumns(\n            [PyColumn(column, self) for column in self._object.Columns.GetEnumerator()]\n        )\n        self.Measures: PyMeasures = PyMeasures(\n            [\n                PyMeasure(measure, self)\n                for measure in self._object.Measures.GetEnumerator()\n            ],\n            self,\n        )\n        self._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\n        self._display.add_row(\"# of Columns\", str(len(self.Columns)))\n        self._display.add_row(\n            \"# of Measures\", str(len(self.Measures)), end_section=True\n        )\n        self._display.add_row(\"Description\", self._object.Description, end_section=True)\n        self._display.add_row(\"DataCategory\", str(self._object.DataCategory))\n        self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n        self._display.add_row(\"IsPrivate\", str(self._object.IsPrivate))\n        self._display.add_row(\n            \"ModifiedTime\",\n            ticks_to_datetime(self._object.ModifiedTime.Ticks).strftime(\n                \"%m/%d/%Y, %H:%M:%S\"\n            ),\n        )\n\n    def row_count(self) -&gt; int:\n        \"\"\"Method to return count of rows.\n\n        Simple Dax Query: `EVALUATE {COUNTROWS('Table Name')}`.\n\n        Returns:\n            int: Number of rows using `COUNTROWS`.\n\n        Example:\n            ```python\n            model.Tables['Table Name'].row_count()\n            ```\n        \"\"\"\n        return self.Model.Adomd.query(f\"EVALUATE {{COUNTROWS('{self.Name}')}}\")\n\n    def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n        \"\"\"Use this to refresh the PyTable.\n\n        Returns:\n            pd.DataFrame: Returns pandas dataframe with some refresh details.\n\n        Example:\n            ```python\n            model.Tables['Table Name'].refresh()\n\n            model.Tables['Table Name'].refresh(trace = None) # (1)\n            ```\n\n            1. You can pass through arguments to `PyRefresh`, like removing trace.\n        \"\"\"\n        return self.Model.refresh(self, *args, **kwargs)\n\n    def last_refresh(self) -&gt; datetime:\n        \"\"\"Will query each partition for the last refresh time.\n\n        Then will select the max value to return.\n\n        Returns:\n            datetime: Last refresh time in datetime format\n        \"\"\"\n        partition_refreshes = [\n            partition.last_refresh() for partition in self.Partitions\n        ]\n        return max(partition_refreshes)\n\n    def related(self):\n        \"\"\"Returns tables with a relationship with the table in question.\"\"\"\n        return self.Model.Relationships.related(self)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.__init__","title":"<code>__init__(object, model)</code>","text":"<p>Init extends from <code>PyObject</code> class.</p> <p>Also adds a few specific rows to the <code>rich</code> table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Table</code> <p>The actual .Net table.</p> required <code>model</code> <code>Tabular</code> <p>The model that the table is in.</p> required Source code in <code>pytabular/table.py</code> <pre><code>def __init__(self, object, model) -&gt; None:\n    \"\"\"Init extends from `PyObject` class.\n\n    Also adds a few specific rows to the `rich`\n    table.\n\n    Args:\n        object (Table): The actual .Net table.\n        model (Tabular): The model that the table is in.\n    \"\"\"\n    super().__init__(object)\n    self.Model = model\n    self.Partitions: PyPartitions = PyPartitions(\n        [\n            PyPartition(partition, self)\n            for partition in self._object.Partitions.GetEnumerator()\n        ]\n    )\n    self.Columns: PyColumns = PyColumns(\n        [PyColumn(column, self) for column in self._object.Columns.GetEnumerator()]\n    )\n    self.Measures: PyMeasures = PyMeasures(\n        [\n            PyMeasure(measure, self)\n            for measure in self._object.Measures.GetEnumerator()\n        ],\n        self,\n    )\n    self._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\n    self._display.add_row(\"# of Columns\", str(len(self.Columns)))\n    self._display.add_row(\n        \"# of Measures\", str(len(self.Measures)), end_section=True\n    )\n    self._display.add_row(\"Description\", self._object.Description, end_section=True)\n    self._display.add_row(\"DataCategory\", str(self._object.DataCategory))\n    self._display.add_row(\"IsHidden\", str(self._object.IsHidden))\n    self._display.add_row(\"IsPrivate\", str(self._object.IsPrivate))\n    self._display.add_row(\n        \"ModifiedTime\",\n        ticks_to_datetime(self._object.ModifiedTime.Ticks).strftime(\n            \"%m/%d/%Y, %H:%M:%S\"\n        ),\n    )\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.row_count","title":"<code>row_count()</code>","text":"<p>Method to return count of rows.</p> <p>Simple Dax Query: <code>EVALUATE {COUNTROWS('Table Name')}</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of rows using <code>COUNTROWS</code>.</p> Example <pre><code>model.Tables['Table Name'].row_count()\n</code></pre> Source code in <code>pytabular/table.py</code> <pre><code>def row_count(self) -&gt; int:\n    \"\"\"Method to return count of rows.\n\n    Simple Dax Query: `EVALUATE {COUNTROWS('Table Name')}`.\n\n    Returns:\n        int: Number of rows using `COUNTROWS`.\n\n    Example:\n        ```python\n        model.Tables['Table Name'].row_count()\n        ```\n    \"\"\"\n    return self.Model.Adomd.query(f\"EVALUATE {{COUNTROWS('{self.Name}')}}\")\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Use this to refresh the PyTable.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Returns pandas dataframe with some refresh details.</p> Example <pre><code>model.Tables['Table Name'].refresh()\n\nmodel.Tables['Table Name'].refresh(trace = None) # (1)\n</code></pre> <ol> <li>You can pass through arguments to <code>PyRefresh</code>, like removing trace.</li> </ol> Source code in <code>pytabular/table.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"Use this to refresh the PyTable.\n\n    Returns:\n        pd.DataFrame: Returns pandas dataframe with some refresh details.\n\n    Example:\n        ```python\n        model.Tables['Table Name'].refresh()\n\n        model.Tables['Table Name'].refresh(trace = None) # (1)\n        ```\n\n        1. You can pass through arguments to `PyRefresh`, like removing trace.\n    \"\"\"\n    return self.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.last_refresh","title":"<code>last_refresh()</code>","text":"<p>Will query each partition for the last refresh time.</p> <p>Then will select the max value to return.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Last refresh time in datetime format</p> Source code in <code>pytabular/table.py</code> <pre><code>def last_refresh(self) -&gt; datetime:\n    \"\"\"Will query each partition for the last refresh time.\n\n    Then will select the max value to return.\n\n    Returns:\n        datetime: Last refresh time in datetime format\n    \"\"\"\n    partition_refreshes = [\n        partition.last_refresh() for partition in self.Partitions\n    ]\n    return max(partition_refreshes)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.related","title":"<code>related()</code>","text":"<p>Returns tables with a relationship with the table in question.</p> Source code in <code>pytabular/table.py</code> <pre><code>def related(self):\n    \"\"\"Returns tables with a relationship with the table in question.\"\"\"\n    return self.Model.Relationships.related(self)\n</code></pre>"},{"location":"PyTables/","title":"PyTables","text":"<p>             Bases: <code>PyObjects</code></p> <p>Groups together multiple tables.</p> <p>You can interact with <code>PyTables</code> straight from model. You can even filter down with <code>.find()</code>.</p> Source code in <code>pytabular/table.py</code> <pre><code>class PyTables(PyObjects):\n    \"\"\"Groups together multiple tables.\n\n    You can interact with `PyTables` straight from model.\n    You can even filter down with `.find()`.\n    \"\"\"\n\n    def __init__(self, objects) -&gt; None:\n        \"\"\"Init just extends from the main `PyObjects` class.\"\"\"\n        super().__init__(objects)\n\n    def refresh(self, *args, **kwargs):\n        \"\"\"Refreshes all `PyTable`(s) in class.\"\"\"\n        model = self._objects[0].Model\n        return model.refresh(self, *args, **kwargs)\n\n    def query_all(self, query_function: str = \"COUNTROWS(_)\") -&gt; pd.DataFrame:\n        \"\"\"Dynamically query all tables.\n\n        It will replace the `_` with the `query_function` arg\n        to build out the query to run.\n\n        Args:\n                query_function (str, optional): Dax query is\n                        dynamically building a query with the\n                        `UNION` &amp; `ROW` DAX Functions. Defaults to 'COUNTROWS(_)'.\n\n        Returns:\n                pd.DataFrame: Returns dataframe with results\n\n        Example:\n            ```python\n            model.Tables.find('fact').query_all() # (1)\n            ```\n\n            1. Because `.find()` will return the `PyObjects` you are searching in,\n            another `PyTables` is returned, but reduced to just\n            the `PyTable`(s) with the 'fact' in the name. Then will\n            get the # of rows for each table.\n        \"\"\"\n        logger.info(\"Querying every table in PyTables...\")\n        logger.debug(f\"Function to be run: {query_function}\")\n        logger.debug(\"Dynamically creating DAX query...\")\n        query_str = \"EVALUATE UNION(\\n\"\n        for table in self:\n            table_name = table.get_Name()\n            dax_table_identifier = f\"'{table_name}'\"\n            query_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\"{query_function}\\\",\\\n                {query_function.replace('_',dax_table_identifier)}),\\n\"  # noqa: E231, E261\n        query_str = f\"{query_str[:-2]})\"\n        return self[0].Model.query(query_str)\n\n    def find_zero_rows(self) -&gt; \"PyTables\":\n        \"\"\"Returns PyTables class of tables with zero rows queried.\n\n        Returns:\n            PyTables: A subset of the `PyTables` that contains zero rows.\n        \"\"\"\n        query_function: str = \"COUNTROWS(_)\"\n        df = self.query_all(query_function)\n\n        table_names = df[df[f\"[{query_function}]\"].isna()][\"[Table]\"].to_list()\n        logger.debug(f\"Found {table_names}\")\n        tables = [self[name] for name in table_names]\n        return self.__class__(tables)\n\n    def last_refresh(self, group_partition: bool = True) -&gt; pd.DataFrame:\n        \"\"\"Returns `pd.DataFrame` of tables with their latest refresh time.\n\n        Optional 'group_partition' variable, default is True.\n        If False an extra column will be include to\n        have the last refresh time to the grain of the partition\n        Example to add to model\n        `model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')`.\n\n        Args:\n            group_partition (bool, optional): Whether or not you want\n                the grain of the dataframe to be by table or by partition.\n                Defaults to True.\n\n        Returns:\n            pd.DataFrame: pd dataframe with the RefreshedTime property\n                If group_partition == True and the table has\n                multiple partitions, then df.groupby(by[\"tables\"]).max()\n        \"\"\"\n        data = {\n            \"Tables\": [\n                partition.Table.Name for table in self for partition in table.Partitions\n            ],\n            \"Partitions\": [\n                partition.Name for table in self for partition in table.Partitions\n            ],\n            \"RefreshedTime\": [\n                partition.last_refresh()\n                for table in self\n                for partition in table.Partitions\n            ],\n        }\n        df = pd.DataFrame(data)\n        if group_partition:\n            logger.debug(\"Grouping together to grain of Table\")\n            return (\n                df[[\"Tables\", \"RefreshedTime\"]]\n                .groupby(by=[\"Tables\"])\n                .max()\n                .reset_index(drop=False)\n            )\n        else:\n            logger.debug(\"Returning DF\")\n            return df\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n    \"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\n\n    def __init__(self, objects: list[PyObject], parent=None) -&gt; None:\n        \"\"\"Initialization of `PyObjects`.\n\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n\n        Args:\n            objects(list[PyObject]): .Net objects.\n            parent: Parent Object. Defaults to `None`.\n        \"\"\"\n        self._objects = objects\n        self.parent = parent\n        self._display = Table(title=str(self.__class__.mro()[0]))\n        for index, obj in enumerate(self._objects):\n            self._display.add_row(str(index), obj.Name)\n\n    def __rich_repr__(self) -&gt; str:\n        \"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\n        Console().print(self._display)\n\n    def __getitem__(self, object):\n        \"\"\"Get item from `PyObjects`.\n\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\n        if isinstance(object, str):\n            return [pyobject for pyobject in self._objects if object == pyobject.Name][\n                -1\n            ]\n        elif isinstance(object, slice):\n            cls = type(self)\n            return cls(self._objects[object])\n        else:\n            return self._objects[object]\n\n    def __iter__(self):\n        \"\"\"Iterate through `PyObjects`.\"\"\"\n        yield from self._objects\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get length of `PyObjects`.\n\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\n        return len(self._objects)\n\n    def __iadd__(self, obj):\n        \"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\n        if isinstance(obj, Iterable):\n            self._objects.__iadd__(obj._objects)\n        else:\n            self._objects.__iadd__([obj])\n\n        self.__init__(self._objects)\n        return self\n\n    def _first_visible_object(self):\n        \"\"\"Does what the method is called. Get's first `object.IsHidden is False`.\"\"\"\n        for object in self:\n            if object.IsHidden is False:\n                return object\n        return None\n\n    def find(self, object_str: str):\n        \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n        It is case insensitive.\n\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\n        items = [\n            object\n            for object in self._objects\n            if object_str.lower() in object.Name.lower()\n        ]\n        return self.__class__.mro()[0](items)\n\n    def get(self, object_str: str, alt_result: str = \"\") -&gt; str:\n        \"\"\"Gets the object based on str.\n\n        If the object isnt found, then an alternate result\n        can be supplied as an argument.\n\n        Args:\n            object_str (str): str to lookup object\n            alt_result (str): str to return when value isn't found.\n\n        Returns:\n            str: Result of the lookup, or the alternate result.\n        \"\"\"\n        try:\n            return self.__getitem__(object_str)\n        except Exception as e:\n            Console().print(e)\n\n        return alt_result\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.__init__","title":"<code>__init__(objects)</code>","text":"<p>Init just extends from the main <code>PyObjects</code> class.</p> Source code in <code>pytabular/table.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n    \"\"\"Init just extends from the main `PyObjects` class.\"\"\"\n    super().__init__(objects)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Refreshes all <code>PyTable</code>(s) in class.</p> Source code in <code>pytabular/table.py</code> <pre><code>def refresh(self, *args, **kwargs):\n    \"\"\"Refreshes all `PyTable`(s) in class.\"\"\"\n    model = self._objects[0].Model\n    return model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.query_all","title":"<code>query_all(query_function='COUNTROWS(_)')</code>","text":"<p>Dynamically query all tables.</p> <p>It will replace the <code>_</code> with the <code>query_function</code> arg to build out the query to run.</p> <p>Parameters:</p> Name Type Description Default <code>query_function</code> <code>str</code> <p>Dax query is dynamically building a query with the <code>UNION</code> &amp; <code>ROW</code> DAX Functions. Defaults to 'COUNTROWS(_)'.</p> <code>'COUNTROWS(_)'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Returns dataframe with results</p> Example <pre><code>model.Tables.find('fact').query_all() # (1)\n</code></pre> <ol> <li>Because <code>.find()</code> will return the <code>PyObjects</code> you are searching in, another <code>PyTables</code> is returned, but reduced to just the <code>PyTable</code>(s) with the 'fact' in the name. Then will get the # of rows for each table.</li> </ol> Source code in <code>pytabular/table.py</code> <pre><code>def query_all(self, query_function: str = \"COUNTROWS(_)\") -&gt; pd.DataFrame:\n    \"\"\"Dynamically query all tables.\n\n    It will replace the `_` with the `query_function` arg\n    to build out the query to run.\n\n    Args:\n            query_function (str, optional): Dax query is\n                    dynamically building a query with the\n                    `UNION` &amp; `ROW` DAX Functions. Defaults to 'COUNTROWS(_)'.\n\n    Returns:\n            pd.DataFrame: Returns dataframe with results\n\n    Example:\n        ```python\n        model.Tables.find('fact').query_all() # (1)\n        ```\n\n        1. Because `.find()` will return the `PyObjects` you are searching in,\n        another `PyTables` is returned, but reduced to just\n        the `PyTable`(s) with the 'fact' in the name. Then will\n        get the # of rows for each table.\n    \"\"\"\n    logger.info(\"Querying every table in PyTables...\")\n    logger.debug(f\"Function to be run: {query_function}\")\n    logger.debug(\"Dynamically creating DAX query...\")\n    query_str = \"EVALUATE UNION(\\n\"\n    for table in self:\n        table_name = table.get_Name()\n        dax_table_identifier = f\"'{table_name}'\"\n        query_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\"{query_function}\\\",\\\n            {query_function.replace('_',dax_table_identifier)}),\\n\"  # noqa: E231, E261\n    query_str = f\"{query_str[:-2]})\"\n    return self[0].Model.query(query_str)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.find_zero_rows","title":"<code>find_zero_rows()</code>","text":"<p>Returns PyTables class of tables with zero rows queried.</p> <p>Returns:</p> Name Type Description <code>PyTables</code> <code>PyTables</code> <p>A subset of the <code>PyTables</code> that contains zero rows.</p> Source code in <code>pytabular/table.py</code> <pre><code>def find_zero_rows(self) -&gt; \"PyTables\":\n    \"\"\"Returns PyTables class of tables with zero rows queried.\n\n    Returns:\n        PyTables: A subset of the `PyTables` that contains zero rows.\n    \"\"\"\n    query_function: str = \"COUNTROWS(_)\"\n    df = self.query_all(query_function)\n\n    table_names = df[df[f\"[{query_function}]\"].isna()][\"[Table]\"].to_list()\n    logger.debug(f\"Found {table_names}\")\n    tables = [self[name] for name in table_names]\n    return self.__class__(tables)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.last_refresh","title":"<code>last_refresh(group_partition=True)</code>","text":"<p>Returns <code>pd.DataFrame</code> of tables with their latest refresh time.</p> <p>Optional 'group_partition' variable, default is True. If False an extra column will be include to have the last refresh time to the grain of the partition Example to add to model <code>model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_partition</code> <code>bool</code> <p>Whether or not you want the grain of the dataframe to be by table or by partition. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: pd dataframe with the RefreshedTime property If group_partition == True and the table has multiple partitions, then df.groupby(by[\"tables\"]).max()</p> Source code in <code>pytabular/table.py</code> <pre><code>def last_refresh(self, group_partition: bool = True) -&gt; pd.DataFrame:\n    \"\"\"Returns `pd.DataFrame` of tables with their latest refresh time.\n\n    Optional 'group_partition' variable, default is True.\n    If False an extra column will be include to\n    have the last refresh time to the grain of the partition\n    Example to add to model\n    `model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')`.\n\n    Args:\n        group_partition (bool, optional): Whether or not you want\n            the grain of the dataframe to be by table or by partition.\n            Defaults to True.\n\n    Returns:\n        pd.DataFrame: pd dataframe with the RefreshedTime property\n            If group_partition == True and the table has\n            multiple partitions, then df.groupby(by[\"tables\"]).max()\n    \"\"\"\n    data = {\n        \"Tables\": [\n            partition.Table.Name for table in self for partition in table.Partitions\n        ],\n        \"Partitions\": [\n            partition.Name for table in self for partition in table.Partitions\n        ],\n        \"RefreshedTime\": [\n            partition.last_refresh()\n            for table in self\n            for partition in table.Partitions\n        ],\n    }\n    df = pd.DataFrame(data)\n    if group_partition:\n        logger.debug(\"Grouping together to grain of Table\")\n        return (\n            df[[\"Tables\", \"RefreshedTime\"]]\n            .groupby(by=[\"Tables\"])\n            .max()\n            .reset_index(drop=False)\n        )\n    else:\n        logger.debug(\"Returning DF\")\n        return df\n</code></pre>"},{"location":"PyTables/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n    \"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n\n    It is case insensitive.\n\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\n    items = [\n        object\n        for object in self._objects\n        if object_str.lower() in object.Name.lower()\n    ]\n    return self.__class__.mro()[0](items)\n</code></pre>"},{"location":"Tabular/","title":"Main Tabular Class","text":"<p>             Bases: <code>PyObject</code></p> <p>This is the Tabular Class to perform operations.</p> <p>This is the main class to work with in PyTabular. You can connect to the other classes via the supplied attributes.</p> <p>Parameters:</p> Name Type Description Default <code>connection_str</code> <code>str</code> <p>Need a valid connection string: link</p> required <p>Attributes:</p> Name Type Description <code>Adomd</code> <code>Connection</code> <p>For querying. This is the <code>Connection</code> class.</p> <code>Tables</code> <code>PyTables</code> <p>See <code>PyTables</code> for more information. Iterate through your tables in your model.</p> <code>Columns</code> <code>PyColumns</code> <p>See <code>PyColumns</code> for more information.</p> <code>Partitions</code> <code>PyPartitions</code> <p>See <code>PyPartitions</code> for more information.</p> <code>Measures</code> <code>PyMeasures</code> <p>See <code>PyMeasures</code> for more information.</p> <code>PyRefresh</code> <code>PyRefresh</code> <p>See <code>PyRefresh</code> for more information.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>class Tabular(PyObject):\n    \"\"\"This is the Tabular Class to perform operations.\n\n    This is the main class to work with in PyTabular.\n    You can connect to the other classes via the supplied attributes.\n\n    Args:\n            connection_str (str): Need a valid connection string:\n                    [link](https://learn.microsoft.com/en-us/analysis-services/instances/connection-string-properties-analysis-services)\n\n    Attributes:\n        Adomd (Connection): For querying.\n            This is the `Connection` class.\n        Tables (PyTables): See `PyTables` for more information.\n            Iterate through your tables in your model.\n        Columns (PyColumns): See `PyColumns` for more information.\n        Partitions (PyPartitions): See `PyPartitions` for more information.\n        Measures (PyMeasures): See `PyMeasures` for more information.\n        PyRefresh (PyRefresh): See `PyRefresh` for more information.\n    \"\"\"\n\n    def __init__(self, connection_str: str):\n        \"\"\"Connect to model. Just supply a solid connection string.\"\"\"\n        # Connecting to model...\n        logger.debug(\"Initializing Tabular Class\")\n        self.Server = Server()\n        self.Server.Connect(connection_str)\n        logger.info(f\"Connected to Server - {self.Server.Name}\")\n        self.Catalog = self.Server.ConnectionInfo.Catalog\n        logger.debug(f\"Received Catalog - {self.Catalog}\")\n        try:\n            self.Database = [\n                database\n                for database in self.Server.Databases.GetEnumerator()\n                if database.Name == self.Catalog or self.Catalog is None\n            ][0]\n        except Exception:\n            err_msg = f\"Unable to find Database... {self.Catalog}\"\n            logger.error(err_msg)\n            raise Exception(err_msg)\n        logger.info(f\"Connected to Database - {self.Database.Name}\")\n        self.CompatibilityLevel: int = self.Database.CompatibilityLevel\n        self.CompatibilityMode: int = self.Database.CompatibilityMode.value__\n        self.Model = self.Database.Model\n        logger.info(f\"Connected to Model - {self.Model.Name}\")\n        self.Adomd: Connection = Connection(self.Server)\n        self.effective_users: dict = {}\n        self.PyRefresh: PyRefresh = PyRefresh\n\n        # Build PyObjects\n        self.reload_model_info()\n\n        # Run subclass init\n        super().__init__(self.Model)\n\n        # Building rich table display for repr\n        self._display.add_row(\n            \"EstimatedSize\",\n            f\"{round(self.Database.EstimatedSize / 1000000000, 2)} GB\",\n            end_section=True,\n        )\n        self._display.add_row(\"# of Tables\", str(len(self.Tables)))\n        self._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\n        self._display.add_row(\"# of Columns\", str(len(self.Columns)))\n        self._display.add_row(\n            \"# of Measures\", str(len(self.Measures)), end_section=True\n        )\n        self._display.add_row(\"Database\", self.Database.Name)\n        self._display.add_row(\"Server\", self.Server.Name)\n\n        # Finished and registering disconnect\n        logger.debug(\"Class Initialization Completed\")\n        logger.debug(\"Registering Disconnect on Termination...\")\n        atexit.register(self.disconnect)\n\n    def reload_model_info(self) -&gt; bool:\n        \"\"\"Reload your model info into the `Tabular` class.\n\n        Should be called after any model changes.\n        Called in `save_changes()` and `__init__()`.\n\n        Returns:\n                bool: True if successful\n        \"\"\"\n        self.Database.Refresh()\n\n        self.Tables = PyTables(\n            [PyTable(table, self) for table in self.Model.Tables.GetEnumerator()]\n        )\n        self.Relationships = PyRelationships(\n            [\n                PyRelationship(relationship, self)\n                for relationship in self.Model.Relationships.GetEnumerator()\n            ]\n        )\n        self.Partitions = PyPartitions(\n            [partition for table in self.Tables for partition in table.Partitions]\n        )\n        self.Columns = PyColumns(\n            [column for table in self.Tables for column in table.Columns]\n        )\n        self.Measures = PyMeasures(\n            [measure for table in self.Tables for measure in table.Measures], self\n        )\n\n        self.Cultures = PyCultures(\n            [\n                PyCulture(culture, self)\n                for culture in self.Model.Cultures.GetEnumerator()\n            ]\n        )\n        return True\n\n    def is_process(self) -&gt; bool:\n        \"\"\"Run method to check if Processing is occurring.\n\n        Will query DMV `$SYSTEM.DISCOVER_JOBS`\n        to see if any processing is happening.\n\n        Returns:\n            bool: True if DMV shows Process, False if not.\n        \"\"\"\n        _jobs_df = self.query(\"select * from $SYSTEM.DISCOVER_JOBS\")\n        return len(_jobs_df[_jobs_df[\"JOB_DESCRIPTION\"] == \"Process\"]) &gt; 0\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnects from Model.\"\"\"\n        logger.info(f\"Disconnecting from - {self.Server.Name}\")\n        atexit.unregister(self.disconnect)\n        return self.Server.Disconnect()\n\n    def reconnect(self) -&gt; None:\n        \"\"\"Reconnects to Model.\"\"\"\n        logger.info(f\"Reconnecting to {self.Server.Name}\")\n        return self.Server.Reconnect()\n\n    def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n        \"\"\"`PyRefresh` class to handle refreshes of model.\n\n        See the `PyRefresh()` class for more details on what you can do with this.\n        \"\"\"\n        return self.PyRefresh(self, *args, **kwargs).run()\n\n    def save_changes(self):\n        \"\"\"Called after refreshes or any model changes.\n\n        Currently will return a named tuple of all changes detected.\n        A ton of room for improvement on what gets returned here.\n        \"\"\"\n        if self.Server.Connected is False:\n            self.reconnect()\n\n        def property_changes(property_changes_var):\n            \"\"\"Returns any property changes.\"\"\"\n            property_change = namedtuple(\n                \"property_change\",\n                \"new_value object original_value property_name property_type\",\n            )\n            return [\n                property_change(\n                    change.NewValue,\n                    change.Object,\n                    change.OriginalValue,\n                    change.PropertyName,\n                    change.PropertyType,\n                )\n                for change in property_changes_var.GetEnumerator()\n            ]\n\n        logger.info(\"Executing save_changes()...\")\n        model_save_results = self.Model.SaveChanges()\n        if isinstance(model_save_results.Impact, type(None)):\n            logger.warning(f\"No changes detected on save for {self.Server.Name}\")\n            return None\n        else:\n            property_changes_var = model_save_results.Impact.PropertyChanges\n            added_objects = model_save_results.Impact.AddedObjects\n            added_subtree_roots = model_save_results.Impact.AddedSubtreeRoots\n            removed_objects = model_save_results.Impact.RemovedObjects\n            removed_subtree_roots = model_save_results.Impact.RemovedSubtreeRoots\n            xmla_results = model_save_results.XmlaResults\n            changes = namedtuple(\n                \"changes\",\n                \"property_changes added_objects added_subtree_roots \\\n                    removed_objects removed_subtree_Roots xmla_results\",\n            )\n            [\n                property_changes(property_changes_var),\n                added_objects,\n                added_subtree_roots,\n                removed_objects,\n                removed_subtree_roots,\n                xmla_results,\n            ]\n            self.reload_model_info()\n            return changes(\n                property_changes(property_changes_var),\n                added_objects,\n                added_subtree_roots,\n                removed_objects,\n                removed_subtree_roots,\n                xmla_results,\n            )\n\n    def backup_table(self, table_str: str) -&gt; bool:\n        \"\"\"This will be removed.\n\n        Used in conjunction with `revert_table()`.\n        \"\"\"\n        logger.info(\"Backup Beginning...\")\n        logger.debug(f\"Cloning {table_str}\")\n        table = self.Model.Tables.Find(table_str).Clone()\n        logger.info(\"Beginning Renames\")\n\n        def rename(items):\n            \"\"\"Iterates through items and requests rename.\"\"\"\n            for item in items:\n                item.RequestRename(f\"{item.Name}_backup\")\n                logger.debug(f\"Renamed - {item.Name}\")\n\n        logger.info(\"Renaming Columns\")\n        rename(table.Columns.GetEnumerator())\n        logger.info(\"Renaming Partitions\")\n        rename(table.Partitions.GetEnumerator())\n        logger.info(\"Renaming Measures\")\n        rename(table.Measures.GetEnumerator())\n        logger.info(\"Renaming Hierarchies\")\n        rename(table.Hierarchies.GetEnumerator())\n        logger.info(\"Renaming Table\")\n        table.RequestRename(f\"{table.Name}_backup\")\n        logger.info(\"Adding Table to Model as backup\")\n        self.Model.Tables.Add(table)\n        logger.info(\"Finding Necessary Relationships... Cloning...\")\n        relationships = [\n            relationship.Clone()\n            for relationship in self.Model.Relationships.GetEnumerator()\n            if relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\")\n            or relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\")\n        ]\n        logger.info(\"Renaming Relationships\")\n        rename(relationships)\n        logger.info(\"Switching Relationships to Clone Table &amp; Column\")\n        for relationship in relationships:\n            logger.debug(f\"Renaming - {relationship.Name}\")\n            if relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\"):\n                relationship.set_ToColumn(\n                    table.Columns.find(f\"{relationship.ToColumn.Name}_backup\")\n                )\n            elif relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\"):\n                relationship.set_FromColumn(\n                    table.Columns.find(f\"{relationship.FromColumn.Name}_backup\")\n                )\n            logger.debug(f\"Adding {relationship.Name} to {self.Model.Name}\")\n            self.Model.Relationships.Add(relationship)\n\n        def clone_role_permissions():\n            \"\"\"Clones the role permissions for table.\"\"\"\n            logger.info(\"Beginning to handle roles and permissions for table...\")\n            logger.debug(\"Finding Roles...\")\n            roles = [\n                role\n                for role in self.Model.Roles.GetEnumerator()\n                for tablepermission in role.TablePermissions.GetEnumerator()\n                if tablepermission.Name == table_str\n            ]\n            for role in roles:\n                logger.debug(f\"Role {role.Name} matched, looking into it...\")\n                logger.debug(\"Searching for table specific permissions\")\n                tablepermissions = [\n                    table.Clone()\n                    for table in role.TablePermissions.GetEnumerator()\n                    if table.Name == table_str\n                ]\n                for tablepermission in tablepermissions:\n                    logger.debug(\n                        f\"{tablepermission.Name} found... switching table to clone\"\n                    )\n                    tablepermission.set_Table(table)\n                    for column in tablepermission.ColumnPermissions.GetEnumerator():\n                        logger.debug(\n                            f\"Column - {column.Name} copying permissions to clone...\"\n                        )\n                        column.set_Column(\n                            self.Model.Tables.find(table.Name).Columns.find(\n                                f\"{column.Name}_backup\"\n                            )\n                        )\n                    logger.debug(f\"Adding {tablepermission.Name} to {role.Name}\")\n                    role.TablePermissions.Add(tablepermission)\n            return True\n\n        clone_role_permissions()\n        logger.info(f\"Refreshing Clone... {table.Name}\")\n        self.reload_model_info()\n        self.refresh(table.Name, default_row_count_check=False)\n        logger.info(f\"Updating Model {self.Model.Name}\")\n        self.save_changes()\n        return True\n\n    def revert_table(self, table_str: str) -&gt; bool:\n        \"\"\"This will be removed.\n\n        This is used in conjunction with `backup_table()`.\n        \"\"\"\n        logger.info(f\"Beginning Revert for {table_str}\")\n        logger.debug(f\"Finding original {table_str}\")\n        main = self.Tables.find(table_str)[0]._object\n        logger.debug(f\"Finding backup {table_str}\")\n        backup = self.Tables.find(f\"{table_str}_backup\")[0]._object\n        logger.debug(\"Finding original relationships\")\n        main_relationships = [\n            relationship\n            for relationship in self.Model.Relationships.GetEnumerator()\n            if relationship.ToTable.Name == main.Name\n            or relationship.FromTable.Name == main.Name\n        ]\n        logger.debug(\"Finding backup relationships\")\n        backup_relationships = [\n            relationship\n            for relationship in self.Model.Relationships.GetEnumerator()\n            if relationship.ToTable.Name == backup.Name\n            or relationship.FromTable.Name == backup.Name\n        ]\n\n        def remove_role_permissions():\n            \"\"\"Removes role permissions from table.\"\"\"\n            logger.debug(\n                f\"Finding table and column permission in roles to remove from {table_str}\"\n            )\n            roles = [\n                role\n                for role in self.Model.Roles.GetEnumerator()\n                for tablepermission in role.TablePermissions.GetEnumerator()\n                if tablepermission.Name == table_str\n            ]\n            for role in roles:\n                logger.debug(f\"Role {role.Name} Found\")\n                tablepermissions = [\n                    table\n                    for table in role.TablePermissions.GetEnumerator()\n                    if table.Name == table_str\n                ]\n                for tablepermission in tablepermissions:\n                    logger.debug(f\"Removing {tablepermission.Name} from {role.Name}\")\n                    role.TablePermissions.Remove(tablepermission)\n\n        for relationship in main_relationships:\n            logger.debug(\"Cleaning relationships...\")\n            if relationship.ToTable.Name == main.Name:\n                logger.debug(f\"Removing {relationship.Name}\")\n                self.Model.Relationships.Remove(relationship)\n            elif relationship.FromTable.Name == main.Name:\n                logger.debug(f\"Removing {relationship.Name}\")\n                self.Model.Relationships.Remove(relationship)\n        logger.debug(f\"Removing Original Table {main.Name}\")\n        self.Model.Tables.Remove(main)\n        remove_role_permissions()\n\n        def dename(items):\n            \"\"\"Denames all items.\"\"\"\n            for item in items:\n                logger.debug(f\"Removing Suffix for {item.Name}\")\n                item.RequestRename(remove_suffix(item.Name, \"_backup\"))\n                logger.debug(f\"Saving Changes... for {item.Name}\")\n                self.save_changes()\n\n        logger.info(\"Name changes for Columns...\")\n        dename(\n            [\n                column\n                for column in backup.Columns.GetEnumerator()\n                if column.Type != ColumnType.RowNumber\n            ]\n        )\n        logger.info(\"Name changes for Partitions...\")\n        dename(backup.Partitions.GetEnumerator())\n        logger.info(\"Name changes for Measures...\")\n        dename(backup.Measures.GetEnumerator())\n        logger.info(\"Name changes for Hierarchies...\")\n        dename(backup.Hierarchies.GetEnumerator())\n        logger.info(\"Name changes for Relationships...\")\n        dename(backup_relationships)\n        logger.info(\"Name changes for Backup Table...\")\n        backup.RequestRename(remove_suffix(backup.Name, \"_backup\"))\n        self.save_changes()\n        return True\n\n    def query(\n        self, query_str: str, effective_user: str = None\n    ) -&gt; Union[pd.DataFrame, str, int]:\n        \"\"\"Executes a query on model.\n\n        See `Connection().query()` for details on execution.\n\n        Args:\n            query_str (str): Query string to execute.\n            effective_user (str, optional): Pass through an effective user\n                if desired. It will create and store a new `Connection()` class if need,\n                which will help with speed if looping through multiple users in a row.\n                Defaults to None.\n\n        Returns:\n            Union[pd.DataFrame, str, int]: Depending on query, will return DataFrame\n                or single value.\n        Example:\n            ```python\n            model.query(\"EVALUATE {1}\")\n\n            model.query(\"EVALUATE TOPN(5, 'Customer')\")\n\n            model.query(\n                \"EVALUATE VALUES('Sales Region'[Region])\",\n                effective_user = \"user@company.com\"\n            )\n            ```\n        \"\"\"\n        if effective_user is None:\n            return self.Adomd.query(query_str)\n\n        try:\n            # This needs a public model with effective users to properly test\n            conn = self.effective_users[effective_user]\n            logger.debug(f\"Effective user found querying as... {effective_user}\")\n        except Exception:\n            logger.info(f\"Creating new connection with {effective_user}\")\n            conn = Connection(self.Server, effective_user=effective_user)\n            self.effective_users[effective_user] = conn\n\n        return conn.query(query_str)\n\n    def analyze_bpa(\n        self, tabular_editor_exe: str, best_practice_analyzer: str\n    ) -&gt; List[str]:\n        \"\"\"Takes your Tabular Model and performs TE2s BPA. Runs through Command line.\n\n        Nothing fancy hear. Really just a simple wrapper so you could\n        call BPA in the same python script.\n\n        Args:\n                tabular_editor_exe (str): TE2 Exe File path.\n                        Feel free to use class TE2().EXE_Path or provide your own.\n                best_practice_analyzer (str): BPA json file path.\n                        Feel free to use class BPA().Location or provide your own.\n\n        Returns:\n                List[str]: Assuming no failure,\n                        will return list of BPA violations.\n                        Else will return error from command line.\n        \"\"\"\n        logger.debug(\"Beginning request to talk with TE2 &amp; Find BPA...\")\n        bim_file_location = f\"{os.getcwd()}\\\\Model.bim\"\n        atexit.register(remove_file, bim_file_location)\n        cmd = f'{tabular_editor_exe} \"Provider=MSOLAP;\\\n            {self.Adomd.ConnectionString}\" {self.Database.Name} -B \"{bim_file_location}\" \\\n            -A {best_practice_analyzer} -V/?'\n        logger.debug(\"Command Generated\")\n        logger.debug(\"Submitting Command...\")\n        sp = subprocess.Popen(\n            cmd,\n            shell=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True,\n        )\n        raw_output, error = sp.communicate()\n        if len(error) &gt; 0:\n            return error\n        else:\n            return [\n                output for output in raw_output.split(\"\\n\") if \"violates rule\" in output\n            ]\n\n    def create_table(self, df: pd.DataFrame, table_name: str) -&gt; bool:\n        \"\"\"Creates table from pd.DataFrame to a table in your model.\n\n        It will convert the dataframe to M-Partition logic via the M query table constructor.\n        Then will run a refresh and update model.\n        Has some obvious limitations right now, because\n        the datframe values are hard coded into M-Partition,\n        which means you could hit limits with the size of your table.\n\n        Args:\n                df (pd.DataFrame): DataFrame to add to model.\n                table_name (str): Name of the table.\n\n        Returns:\n                bool: True if successful\n        \"\"\"\n        logger.debug(f\"Beginning to create table for {table_name}...\")\n        new_table = Table()\n        new_table.RequestRename(table_name)\n        logger.debug(\"Sorting through columns...\")\n        df_column_names = df.columns\n        dtype_conversion = pandas_datatype_to_tabular_datatype(df)\n        for df_column_name in df_column_names:\n            logger.debug(f\"Adding {df_column_name} to Table...\")\n            column = DataColumn()\n            column.RequestRename(df_column_name)\n            column.set_SourceColumn(df_column_name)\n            column.set_DataType(dtype_conversion[df_column_name])\n            new_table.Columns.Add(column)\n        logger.debug(\"Expression String Created...\")\n        logger.debug(\"Creating MPartition...\")\n        partition = Partition()\n        partition.set_Source(MPartitionSource())\n        logger.debug(\"Setting MPartition Expression...\")\n        partition.Source.set_Expression(pd_dataframe_to_m_expression(df))\n        logger.debug(\n            f\"Adding partition: {partition.Name} to {self.Server.Name}\\\n                ::{self.Database.Name}::{self.Model.Name}\"\n        )\n        new_table.Partitions.Add(partition)\n        logger.debug(\n            f\"Adding table: {new_table.Name} to {self.Server.Name}\\\n                ::{self.Database.Name}::{self.Model.Name}\"\n        )\n        self.Model.Tables.Add(new_table)\n        self.save_changes()\n        self.reload_model_info()\n        self.refresh(new_table.Name)\n        return True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.__init__","title":"<code>__init__(connection_str)</code>","text":"<p>Connect to model. Just supply a solid connection string.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def __init__(self, connection_str: str):\n    \"\"\"Connect to model. Just supply a solid connection string.\"\"\"\n    # Connecting to model...\n    logger.debug(\"Initializing Tabular Class\")\n    self.Server = Server()\n    self.Server.Connect(connection_str)\n    logger.info(f\"Connected to Server - {self.Server.Name}\")\n    self.Catalog = self.Server.ConnectionInfo.Catalog\n    logger.debug(f\"Received Catalog - {self.Catalog}\")\n    try:\n        self.Database = [\n            database\n            for database in self.Server.Databases.GetEnumerator()\n            if database.Name == self.Catalog or self.Catalog is None\n        ][0]\n    except Exception:\n        err_msg = f\"Unable to find Database... {self.Catalog}\"\n        logger.error(err_msg)\n        raise Exception(err_msg)\n    logger.info(f\"Connected to Database - {self.Database.Name}\")\n    self.CompatibilityLevel: int = self.Database.CompatibilityLevel\n    self.CompatibilityMode: int = self.Database.CompatibilityMode.value__\n    self.Model = self.Database.Model\n    logger.info(f\"Connected to Model - {self.Model.Name}\")\n    self.Adomd: Connection = Connection(self.Server)\n    self.effective_users: dict = {}\n    self.PyRefresh: PyRefresh = PyRefresh\n\n    # Build PyObjects\n    self.reload_model_info()\n\n    # Run subclass init\n    super().__init__(self.Model)\n\n    # Building rich table display for repr\n    self._display.add_row(\n        \"EstimatedSize\",\n        f\"{round(self.Database.EstimatedSize / 1000000000, 2)} GB\",\n        end_section=True,\n    )\n    self._display.add_row(\"# of Tables\", str(len(self.Tables)))\n    self._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\n    self._display.add_row(\"# of Columns\", str(len(self.Columns)))\n    self._display.add_row(\n        \"# of Measures\", str(len(self.Measures)), end_section=True\n    )\n    self._display.add_row(\"Database\", self.Database.Name)\n    self._display.add_row(\"Server\", self.Server.Name)\n\n    # Finished and registering disconnect\n    logger.debug(\"Class Initialization Completed\")\n    logger.debug(\"Registering Disconnect on Termination...\")\n    atexit.register(self.disconnect)\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.reload_model_info","title":"<code>reload_model_info()</code>","text":"<p>Reload your model info into the <code>Tabular</code> class.</p> <p>Should be called after any model changes. Called in <code>save_changes()</code> and <code>__init__()</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def reload_model_info(self) -&gt; bool:\n    \"\"\"Reload your model info into the `Tabular` class.\n\n    Should be called after any model changes.\n    Called in `save_changes()` and `__init__()`.\n\n    Returns:\n            bool: True if successful\n    \"\"\"\n    self.Database.Refresh()\n\n    self.Tables = PyTables(\n        [PyTable(table, self) for table in self.Model.Tables.GetEnumerator()]\n    )\n    self.Relationships = PyRelationships(\n        [\n            PyRelationship(relationship, self)\n            for relationship in self.Model.Relationships.GetEnumerator()\n        ]\n    )\n    self.Partitions = PyPartitions(\n        [partition for table in self.Tables for partition in table.Partitions]\n    )\n    self.Columns = PyColumns(\n        [column for table in self.Tables for column in table.Columns]\n    )\n    self.Measures = PyMeasures(\n        [measure for table in self.Tables for measure in table.Measures], self\n    )\n\n    self.Cultures = PyCultures(\n        [\n            PyCulture(culture, self)\n            for culture in self.Model.Cultures.GetEnumerator()\n        ]\n    )\n    return True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.is_process","title":"<code>is_process()</code>","text":"<p>Run method to check if Processing is occurring.</p> <p>Will query DMV <code>$SYSTEM.DISCOVER_JOBS</code> to see if any processing is happening.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if DMV shows Process, False if not.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def is_process(self) -&gt; bool:\n    \"\"\"Run method to check if Processing is occurring.\n\n    Will query DMV `$SYSTEM.DISCOVER_JOBS`\n    to see if any processing is happening.\n\n    Returns:\n        bool: True if DMV shows Process, False if not.\n    \"\"\"\n    _jobs_df = self.query(\"select * from $SYSTEM.DISCOVER_JOBS\")\n    return len(_jobs_df[_jobs_df[\"JOB_DESCRIPTION\"] == \"Process\"]) &gt; 0\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects from Model.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnects from Model.\"\"\"\n    logger.info(f\"Disconnecting from - {self.Server.Name}\")\n    atexit.unregister(self.disconnect)\n    return self.Server.Disconnect()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.reconnect","title":"<code>reconnect()</code>","text":"<p>Reconnects to Model.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def reconnect(self) -&gt; None:\n    \"\"\"Reconnects to Model.\"\"\"\n    logger.info(f\"Reconnecting to {self.Server.Name}\")\n    return self.Server.Reconnect()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p><code>PyRefresh</code> class to handle refreshes of model.</p> <p>See the <code>PyRefresh()</code> class for more details on what you can do with this.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"`PyRefresh` class to handle refreshes of model.\n\n    See the `PyRefresh()` class for more details on what you can do with this.\n    \"\"\"\n    return self.PyRefresh(self, *args, **kwargs).run()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.save_changes","title":"<code>save_changes()</code>","text":"<p>Called after refreshes or any model changes.</p> <p>Currently will return a named tuple of all changes detected. A ton of room for improvement on what gets returned here.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def save_changes(self):\n    \"\"\"Called after refreshes or any model changes.\n\n    Currently will return a named tuple of all changes detected.\n    A ton of room for improvement on what gets returned here.\n    \"\"\"\n    if self.Server.Connected is False:\n        self.reconnect()\n\n    def property_changes(property_changes_var):\n        \"\"\"Returns any property changes.\"\"\"\n        property_change = namedtuple(\n            \"property_change\",\n            \"new_value object original_value property_name property_type\",\n        )\n        return [\n            property_change(\n                change.NewValue,\n                change.Object,\n                change.OriginalValue,\n                change.PropertyName,\n                change.PropertyType,\n            )\n            for change in property_changes_var.GetEnumerator()\n        ]\n\n    logger.info(\"Executing save_changes()...\")\n    model_save_results = self.Model.SaveChanges()\n    if isinstance(model_save_results.Impact, type(None)):\n        logger.warning(f\"No changes detected on save for {self.Server.Name}\")\n        return None\n    else:\n        property_changes_var = model_save_results.Impact.PropertyChanges\n        added_objects = model_save_results.Impact.AddedObjects\n        added_subtree_roots = model_save_results.Impact.AddedSubtreeRoots\n        removed_objects = model_save_results.Impact.RemovedObjects\n        removed_subtree_roots = model_save_results.Impact.RemovedSubtreeRoots\n        xmla_results = model_save_results.XmlaResults\n        changes = namedtuple(\n            \"changes\",\n            \"property_changes added_objects added_subtree_roots \\\n                removed_objects removed_subtree_Roots xmla_results\",\n        )\n        [\n            property_changes(property_changes_var),\n            added_objects,\n            added_subtree_roots,\n            removed_objects,\n            removed_subtree_roots,\n            xmla_results,\n        ]\n        self.reload_model_info()\n        return changes(\n            property_changes(property_changes_var),\n            added_objects,\n            added_subtree_roots,\n            removed_objects,\n            removed_subtree_roots,\n            xmla_results,\n        )\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.backup_table","title":"<code>backup_table(table_str)</code>","text":"<p>This will be removed.</p> <p>Used in conjunction with <code>revert_table()</code>.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def backup_table(self, table_str: str) -&gt; bool:\n    \"\"\"This will be removed.\n\n    Used in conjunction with `revert_table()`.\n    \"\"\"\n    logger.info(\"Backup Beginning...\")\n    logger.debug(f\"Cloning {table_str}\")\n    table = self.Model.Tables.Find(table_str).Clone()\n    logger.info(\"Beginning Renames\")\n\n    def rename(items):\n        \"\"\"Iterates through items and requests rename.\"\"\"\n        for item in items:\n            item.RequestRename(f\"{item.Name}_backup\")\n            logger.debug(f\"Renamed - {item.Name}\")\n\n    logger.info(\"Renaming Columns\")\n    rename(table.Columns.GetEnumerator())\n    logger.info(\"Renaming Partitions\")\n    rename(table.Partitions.GetEnumerator())\n    logger.info(\"Renaming Measures\")\n    rename(table.Measures.GetEnumerator())\n    logger.info(\"Renaming Hierarchies\")\n    rename(table.Hierarchies.GetEnumerator())\n    logger.info(\"Renaming Table\")\n    table.RequestRename(f\"{table.Name}_backup\")\n    logger.info(\"Adding Table to Model as backup\")\n    self.Model.Tables.Add(table)\n    logger.info(\"Finding Necessary Relationships... Cloning...\")\n    relationships = [\n        relationship.Clone()\n        for relationship in self.Model.Relationships.GetEnumerator()\n        if relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\")\n        or relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\")\n    ]\n    logger.info(\"Renaming Relationships\")\n    rename(relationships)\n    logger.info(\"Switching Relationships to Clone Table &amp; Column\")\n    for relationship in relationships:\n        logger.debug(f\"Renaming - {relationship.Name}\")\n        if relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\"):\n            relationship.set_ToColumn(\n                table.Columns.find(f\"{relationship.ToColumn.Name}_backup\")\n            )\n        elif relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\"):\n            relationship.set_FromColumn(\n                table.Columns.find(f\"{relationship.FromColumn.Name}_backup\")\n            )\n        logger.debug(f\"Adding {relationship.Name} to {self.Model.Name}\")\n        self.Model.Relationships.Add(relationship)\n\n    def clone_role_permissions():\n        \"\"\"Clones the role permissions for table.\"\"\"\n        logger.info(\"Beginning to handle roles and permissions for table...\")\n        logger.debug(\"Finding Roles...\")\n        roles = [\n            role\n            for role in self.Model.Roles.GetEnumerator()\n            for tablepermission in role.TablePermissions.GetEnumerator()\n            if tablepermission.Name == table_str\n        ]\n        for role in roles:\n            logger.debug(f\"Role {role.Name} matched, looking into it...\")\n            logger.debug(\"Searching for table specific permissions\")\n            tablepermissions = [\n                table.Clone()\n                for table in role.TablePermissions.GetEnumerator()\n                if table.Name == table_str\n            ]\n            for tablepermission in tablepermissions:\n                logger.debug(\n                    f\"{tablepermission.Name} found... switching table to clone\"\n                )\n                tablepermission.set_Table(table)\n                for column in tablepermission.ColumnPermissions.GetEnumerator():\n                    logger.debug(\n                        f\"Column - {column.Name} copying permissions to clone...\"\n                    )\n                    column.set_Column(\n                        self.Model.Tables.find(table.Name).Columns.find(\n                            f\"{column.Name}_backup\"\n                        )\n                    )\n                logger.debug(f\"Adding {tablepermission.Name} to {role.Name}\")\n                role.TablePermissions.Add(tablepermission)\n        return True\n\n    clone_role_permissions()\n    logger.info(f\"Refreshing Clone... {table.Name}\")\n    self.reload_model_info()\n    self.refresh(table.Name, default_row_count_check=False)\n    logger.info(f\"Updating Model {self.Model.Name}\")\n    self.save_changes()\n    return True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.revert_table","title":"<code>revert_table(table_str)</code>","text":"<p>This will be removed.</p> <p>This is used in conjunction with <code>backup_table()</code>.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def revert_table(self, table_str: str) -&gt; bool:\n    \"\"\"This will be removed.\n\n    This is used in conjunction with `backup_table()`.\n    \"\"\"\n    logger.info(f\"Beginning Revert for {table_str}\")\n    logger.debug(f\"Finding original {table_str}\")\n    main = self.Tables.find(table_str)[0]._object\n    logger.debug(f\"Finding backup {table_str}\")\n    backup = self.Tables.find(f\"{table_str}_backup\")[0]._object\n    logger.debug(\"Finding original relationships\")\n    main_relationships = [\n        relationship\n        for relationship in self.Model.Relationships.GetEnumerator()\n        if relationship.ToTable.Name == main.Name\n        or relationship.FromTable.Name == main.Name\n    ]\n    logger.debug(\"Finding backup relationships\")\n    backup_relationships = [\n        relationship\n        for relationship in self.Model.Relationships.GetEnumerator()\n        if relationship.ToTable.Name == backup.Name\n        or relationship.FromTable.Name == backup.Name\n    ]\n\n    def remove_role_permissions():\n        \"\"\"Removes role permissions from table.\"\"\"\n        logger.debug(\n            f\"Finding table and column permission in roles to remove from {table_str}\"\n        )\n        roles = [\n            role\n            for role in self.Model.Roles.GetEnumerator()\n            for tablepermission in role.TablePermissions.GetEnumerator()\n            if tablepermission.Name == table_str\n        ]\n        for role in roles:\n            logger.debug(f\"Role {role.Name} Found\")\n            tablepermissions = [\n                table\n                for table in role.TablePermissions.GetEnumerator()\n                if table.Name == table_str\n            ]\n            for tablepermission in tablepermissions:\n                logger.debug(f\"Removing {tablepermission.Name} from {role.Name}\")\n                role.TablePermissions.Remove(tablepermission)\n\n    for relationship in main_relationships:\n        logger.debug(\"Cleaning relationships...\")\n        if relationship.ToTable.Name == main.Name:\n            logger.debug(f\"Removing {relationship.Name}\")\n            self.Model.Relationships.Remove(relationship)\n        elif relationship.FromTable.Name == main.Name:\n            logger.debug(f\"Removing {relationship.Name}\")\n            self.Model.Relationships.Remove(relationship)\n    logger.debug(f\"Removing Original Table {main.Name}\")\n    self.Model.Tables.Remove(main)\n    remove_role_permissions()\n\n    def dename(items):\n        \"\"\"Denames all items.\"\"\"\n        for item in items:\n            logger.debug(f\"Removing Suffix for {item.Name}\")\n            item.RequestRename(remove_suffix(item.Name, \"_backup\"))\n            logger.debug(f\"Saving Changes... for {item.Name}\")\n            self.save_changes()\n\n    logger.info(\"Name changes for Columns...\")\n    dename(\n        [\n            column\n            for column in backup.Columns.GetEnumerator()\n            if column.Type != ColumnType.RowNumber\n        ]\n    )\n    logger.info(\"Name changes for Partitions...\")\n    dename(backup.Partitions.GetEnumerator())\n    logger.info(\"Name changes for Measures...\")\n    dename(backup.Measures.GetEnumerator())\n    logger.info(\"Name changes for Hierarchies...\")\n    dename(backup.Hierarchies.GetEnumerator())\n    logger.info(\"Name changes for Relationships...\")\n    dename(backup_relationships)\n    logger.info(\"Name changes for Backup Table...\")\n    backup.RequestRename(remove_suffix(backup.Name, \"_backup\"))\n    self.save_changes()\n    return True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.query","title":"<code>query(query_str, effective_user=None)</code>","text":"<p>Executes a query on model.</p> <p>See <code>Connection().query()</code> for details on execution.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>Query string to execute.</p> required <code>effective_user</code> <code>str</code> <p>Pass through an effective user if desired. It will create and store a new <code>Connection()</code> class if need, which will help with speed if looping through multiple users in a row. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[DataFrame, str, int]</code> <p>Union[pd.DataFrame, str, int]: Depending on query, will return DataFrame or single value.</p> <p>Example:     <pre><code>model.query(\"EVALUATE {1}\")\n\nmodel.query(\"EVALUATE TOPN(5, 'Customer')\")\n\nmodel.query(\n    \"EVALUATE VALUES('Sales Region'[Region])\",\n    effective_user = \"user@company.com\"\n)\n</code></pre></p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def query(\n    self, query_str: str, effective_user: str = None\n) -&gt; Union[pd.DataFrame, str, int]:\n    \"\"\"Executes a query on model.\n\n    See `Connection().query()` for details on execution.\n\n    Args:\n        query_str (str): Query string to execute.\n        effective_user (str, optional): Pass through an effective user\n            if desired. It will create and store a new `Connection()` class if need,\n            which will help with speed if looping through multiple users in a row.\n            Defaults to None.\n\n    Returns:\n        Union[pd.DataFrame, str, int]: Depending on query, will return DataFrame\n            or single value.\n    Example:\n        ```python\n        model.query(\"EVALUATE {1}\")\n\n        model.query(\"EVALUATE TOPN(5, 'Customer')\")\n\n        model.query(\n            \"EVALUATE VALUES('Sales Region'[Region])\",\n            effective_user = \"user@company.com\"\n        )\n        ```\n    \"\"\"\n    if effective_user is None:\n        return self.Adomd.query(query_str)\n\n    try:\n        # This needs a public model with effective users to properly test\n        conn = self.effective_users[effective_user]\n        logger.debug(f\"Effective user found querying as... {effective_user}\")\n    except Exception:\n        logger.info(f\"Creating new connection with {effective_user}\")\n        conn = Connection(self.Server, effective_user=effective_user)\n        self.effective_users[effective_user] = conn\n\n    return conn.query(query_str)\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.analyze_bpa","title":"<code>analyze_bpa(tabular_editor_exe, best_practice_analyzer)</code>","text":"<p>Takes your Tabular Model and performs TE2s BPA. Runs through Command line.</p> <p>Nothing fancy hear. Really just a simple wrapper so you could call BPA in the same python script.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_editor_exe</code> <code>str</code> <p>TE2 Exe File path. Feel free to use class TE2().EXE_Path or provide your own.</p> required <code>best_practice_analyzer</code> <code>str</code> <p>BPA json file path. Feel free to use class BPA().Location or provide your own.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Assuming no failure, will return list of BPA violations. Else will return error from command line.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def analyze_bpa(\n    self, tabular_editor_exe: str, best_practice_analyzer: str\n) -&gt; List[str]:\n    \"\"\"Takes your Tabular Model and performs TE2s BPA. Runs through Command line.\n\n    Nothing fancy hear. Really just a simple wrapper so you could\n    call BPA in the same python script.\n\n    Args:\n            tabular_editor_exe (str): TE2 Exe File path.\n                    Feel free to use class TE2().EXE_Path or provide your own.\n            best_practice_analyzer (str): BPA json file path.\n                    Feel free to use class BPA().Location or provide your own.\n\n    Returns:\n            List[str]: Assuming no failure,\n                    will return list of BPA violations.\n                    Else will return error from command line.\n    \"\"\"\n    logger.debug(\"Beginning request to talk with TE2 &amp; Find BPA...\")\n    bim_file_location = f\"{os.getcwd()}\\\\Model.bim\"\n    atexit.register(remove_file, bim_file_location)\n    cmd = f'{tabular_editor_exe} \"Provider=MSOLAP;\\\n        {self.Adomd.ConnectionString}\" {self.Database.Name} -B \"{bim_file_location}\" \\\n        -A {best_practice_analyzer} -V/?'\n    logger.debug(\"Command Generated\")\n    logger.debug(\"Submitting Command...\")\n    sp = subprocess.Popen(\n        cmd,\n        shell=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    raw_output, error = sp.communicate()\n    if len(error) &gt; 0:\n        return error\n    else:\n        return [\n            output for output in raw_output.split(\"\\n\") if \"violates rule\" in output\n        ]\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.create_table","title":"<code>create_table(df, table_name)</code>","text":"<p>Creates table from pd.DataFrame to a table in your model.</p> <p>It will convert the dataframe to M-Partition logic via the M query table constructor. Then will run a refresh and update model. Has some obvious limitations right now, because the datframe values are hard coded into M-Partition, which means you could hit limits with the size of your table.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to add to model.</p> required <code>table_name</code> <code>str</code> <p>Name of the table.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def create_table(self, df: pd.DataFrame, table_name: str) -&gt; bool:\n    \"\"\"Creates table from pd.DataFrame to a table in your model.\n\n    It will convert the dataframe to M-Partition logic via the M query table constructor.\n    Then will run a refresh and update model.\n    Has some obvious limitations right now, because\n    the datframe values are hard coded into M-Partition,\n    which means you could hit limits with the size of your table.\n\n    Args:\n            df (pd.DataFrame): DataFrame to add to model.\n            table_name (str): Name of the table.\n\n    Returns:\n            bool: True if successful\n    \"\"\"\n    logger.debug(f\"Beginning to create table for {table_name}...\")\n    new_table = Table()\n    new_table.RequestRename(table_name)\n    logger.debug(\"Sorting through columns...\")\n    df_column_names = df.columns\n    dtype_conversion = pandas_datatype_to_tabular_datatype(df)\n    for df_column_name in df_column_names:\n        logger.debug(f\"Adding {df_column_name} to Table...\")\n        column = DataColumn()\n        column.RequestRename(df_column_name)\n        column.set_SourceColumn(df_column_name)\n        column.set_DataType(dtype_conversion[df_column_name])\n        new_table.Columns.Add(column)\n    logger.debug(\"Expression String Created...\")\n    logger.debug(\"Creating MPartition...\")\n    partition = Partition()\n    partition.set_Source(MPartitionSource())\n    logger.debug(\"Setting MPartition Expression...\")\n    partition.Source.set_Expression(pd_dataframe_to_m_expression(df))\n    logger.debug(\n        f\"Adding partition: {partition.Name} to {self.Server.Name}\\\n            ::{self.Database.Name}::{self.Model.Name}\"\n    )\n    new_table.Partitions.Add(partition)\n    logger.debug(\n        f\"Adding table: {new_table.Name} to {self.Server.Name}\\\n            ::{self.Database.Name}::{self.Model.Name}\"\n    )\n    self.Model.Tables.Add(new_table)\n    self.save_changes()\n    self.reload_model_info()\n    self.refresh(new_table.Name)\n    return True\n</code></pre>"},{"location":"best_practice_analyzer/","title":"best_practice_analyzer","text":"<p>This is currently just a POC. Handle all BPA related items.</p> <p>You can call the <code>BPA()</code> class to download or specify your own BPA file. It is used with tabular_editor.py to run BPA. I did not want to re-invent the wheel, so just letting TE2 work it's magic.</p>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.BPA","title":"<code>BPA</code>","text":"<p>Setting BPA Class for future work...</p> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>class BPA:\n    \"\"\"Setting BPA Class for future work...\"\"\"\n\n    def __init__(self, file_path: str = \"Default\") -&gt; None:\n        \"\"\"BPA class to be used with the TE2 class.\n\n        You can create the BPA class without any arguments.\n        This doesn't do much right now...\n        BPA().location is where the file path is stored.\n\n        Args:\n            file_path (str, optional): See `Download_BPA_File()`. Defaults to \"Default\".\n        \"\"\"\n        logger.debug(f\"Initializing BPA Class:: {file_path}\")\n        if file_path == \"Default\":\n            self.location: str = download_bpa_file()\n        else:\n            self.location: str = file_path\n        pass\n</code></pre>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.BPA.__init__","title":"<code>__init__(file_path='Default')</code>","text":"<p>BPA class to be used with the TE2 class.</p> <p>You can create the BPA class without any arguments. This doesn't do much right now... BPA().location is where the file path is stored.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>See <code>Download_BPA_File()</code>. Defaults to \"Default\".</p> <code>'Default'</code> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>def __init__(self, file_path: str = \"Default\") -&gt; None:\n    \"\"\"BPA class to be used with the TE2 class.\n\n    You can create the BPA class without any arguments.\n    This doesn't do much right now...\n    BPA().location is where the file path is stored.\n\n    Args:\n        file_path (str, optional): See `Download_BPA_File()`. Defaults to \"Default\".\n    \"\"\"\n    logger.debug(f\"Initializing BPA Class:: {file_path}\")\n    if file_path == \"Default\":\n        self.location: str = download_bpa_file()\n    else:\n        self.location: str = file_path\n    pass\n</code></pre>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.download_bpa_file","title":"<code>download_bpa_file(download_location='https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json', folder='Best_Practice_Analyzer', auto_remove=True)</code>","text":"<p>Download a BPA file from local or web.</p> <p>Runs a request.get() to retrieve the json file from web. Will return and store in directory. Will also register the removal of the new directory and file when exiting program.</p> <p>Parameters:</p> Name Type Description Default <code>download_location</code> <code>str</code> <p>Defaults to [BPA]'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'.</p> <code>'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'</code> <code>folder</code> <code>str</code> <p>New folder string. Defaults to 'Best_Practice_Analyzer'.</p> <code>'Best_Practice_Analyzer'</code> <code>auto_remove</code> <code>bool</code> <p>Auto Remove when script exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>File path for the newly downloaded BPA.</p> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>def download_bpa_file(\n    download_location: str = (\n        \"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\"  # noqa: E501\n    ),\n    folder: str = \"Best_Practice_Analyzer\",\n    auto_remove=True,\n) -&gt; str:\n    \"\"\"Download a BPA file from local or web.\n\n    Runs a request.get() to retrieve the json file from web.\n    Will return and store in directory.\n    Will also register the removal of the new directory and file when exiting program.\n\n    Args:\n            download_location (str, optional):  Defaults to\n                    [BPA]'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'.\n            folder (str, optional): New folder string.\n                    Defaults to 'Best_Practice_Analyzer'.\n            auto_remove (bool, optional): Auto Remove when script exits. Defaults to True.\n\n    Returns:\n            str: File path for the newly downloaded BPA.\n    \"\"\"\n    logger.info(f\"Downloading BPA from {download_location}\")\n    folder_location = os.path.join(os.getcwd(), folder)\n    if os.path.exists(folder_location) is False:\n        os.makedirs(folder_location)\n    response = r.get(download_location)\n    file_location = os.path.join(folder_location, download_location.split(\"/\")[-1])\n    with open(file_location, \"w\", encoding=\"utf-8\") as bpa:\n        json.dump(response.json(), bpa, ensure_ascii=False, indent=4)\n    if auto_remove:\n        logger.debug(f\"Registering removal on termination... For {folder_location}\")\n        atexit.register(remove_folder_and_contents, folder_location)\n    return file_location\n</code></pre>"},{"location":"document/","title":"Documenting Model","text":"<p><code>document.py</code> is where a specific part of pytabular start.</p> <p>This module can generate pages in markdown for use in Docusaurus.</p>"},{"location":"document/#pytabular.document.ModelDocumenter","title":"<code>ModelDocumenter</code>","text":"<p>The ModelDocumenter class can generate documentation.</p> <p>This is based on the tabular object model and it will generate it suitable for docusaurus. TODO: Add a General Pages template with Roles and RLS Expressions. TODO: Create a Sub Page per table for all columns, instead of one big page? TODO: Add Depencies per Measure with correct links.</p> Source code in <code>pytabular/document.py</code> <pre><code>class ModelDocumenter:\n    \"\"\"The ModelDocumenter class can generate documentation.\n\n    This is based on the tabular object model and it will generate it suitable for docusaurus.\n    TODO: Add a General Pages template with Roles and RLS Expressions.\n    TODO: Create a Sub Page per table for all columns, instead of one big page?\n    TODO: Add Depencies per Measure with correct links.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Tabular,\n        friendly_name: str = str(),\n        save_location: str = \"docs\",\n        general_page_url: str = \"index.md\",\n        measure_page_url: str = \"measures.md\",\n        roles_page_url: str = \"roles.md\",\n        table_folder: str = \"tables\",\n        # table_page_url: str = \"3-tables.md\",\n        # column_page_url: str = \"4-columns.md\",\n    ):\n        \"\"\"Init will set attributes based on arguments given.\n\n        See `generate_documentation_pages()` and `save_documentation()`\n        for info on how to execute and retrieve documentation.\n\n        Args:\n            model (Tabular): Main `Tabular()` class to pull metadata from for documentation.\n            friendly_name (str, optional): Replaces the model name to a friendly string,\n                so it can be used in an URL. Defaults to `str()`.\n            save_location (str, optional): The save location where the files will be stored.\n                Defaults to \"docs\".\n            general_page_url (str, optional): Name of the `md` file for general information.\n                Defaults to \"index.md\".\n            measure_page_url (str, optional): Name of the `md` file for measures.\n                Defaults to \"measures.md\".\n            table_folder (str, optional): Name of the folder where columns info is stored.\n                Defaults to \"table_folder\".\n            roles_page_url (str, optional): Name of the `md` file for roles.\n                Defaults to \"roles.md\".\n        \"\"\"\n        self.model = model\n        self.model_name = friendly_name or model.Catalog or model.Database.Name\n        self.friendly_name: str = str()\n        self.save_path: Path\n        self.save_location: str = save_location\n\n        # Translation information\n        self.culture_include: bool = False\n        self.culture_selected: str = \"en-US\"\n        self.culture_object: PyCulture\n\n        # Documentation Parts\n        self.general_page: str = str()\n        self.general_page_url: str = general_page_url\n\n        self.measure_page: str = str()\n        self.measure_page_url: str = measure_page_url\n\n        self.roles_page: str = str()\n        self.roles_page_url: str = roles_page_url\n\n        self.table_page: str = str()\n        self.table_folder: str = table_folder\n\n        # Generate an url friendly name for the model / folder\n        self.friendly_name: str = self.set_url_friendly_name(self.model_name)\n\n        # Initialize Save path so checks can be run against it.\n        self.save_path = self.set_save_path()\n\n    def create_object_reference(self, object: str, object_parent: str) -&gt; str:\n        \"\"\"Create a Custom ID for link sections in the docs.\n\n        This is based on the technical names in the model,\n        so not the once in the translations. This makes it\n        possible to link based on dependencies.\n        (Scope is only Docusaurus)\n\n        Args:\n            object (str): Object Name\n            object_parent (str): Object Parent (e.g. Table)\n\n        Returns:\n            str: String that can be used for custom linking\n        \"\"\"\n        url_reference = f\"{object_parent}-{object}\".replace(\" \", \"\")\n        return f\"{{#{url_reference}}}\"\n\n    def generate_documentation_pages(self) -&gt; None:\n        \"\"\"Generate Documentation for each specific part of the model.\"\"\"\n        self.measure_page = self.generate_markdown_measure_page()\n        self.table_page = self.generate_markdown_table_page()\n        self.general_page = self.generate_general_info_file()\n\n    def get_object_caption(self, object_name: str, object_parent: str) -&gt; str:\n        \"\"\"Retrieves the caption of an object, based on the translations in the culture.\n\n        If no culture is present, the object_name is returned.\n\n        Args:\n            object_name (str): Object Name\n            object_parent (str): Object Parent Name\n\n        Returns:\n            str: Translated object.\n        \"\"\"\n        if self.culture_include:\n            return str(\n                self.culture_object.get_translation(\n                    object_name=object_name, object_parent_name=object_parent\n                ).get(\"object_translation\")\n            )\n\n        return object_name\n\n    def set_translations(\n        self, enable_translations: bool = False, culture: str = \"en-US\"\n    ) -&gt; None:\n        \"\"\"Set translations to active or inactive, depending on the needs of the users.\n\n        Args:\n            enable_translations (bool, optional): Flag to enable or disable translations.\n                Defaults to False.\n            culture (str, optional): Set culture that needs to be used in the docs.\n                Defaults to \"en-US\".\n        \"\"\"\n        logger.info(f\"Using Translations set to &gt; {enable_translations}\")\n\n        if enable_translations:\n            try:\n                self.culture_object = self.model.Cultures[culture]\n                self.culture_selected = culture\n                self.culture_include = enable_translations\n            except IndexError:\n                self.culture_include = False\n                logger.warn(\n                    \"Culture not found, reverting back to orginal setting &gt; False\"\n                )\n            else:\n                logger.info(f\"Setting culture to {self.culture_selected}\")\n\n        else:\n            self.culture_include = enable_translations\n\n    def set_save_path(self) -&gt; Path:\n        \"\"\"Set the location of the documentation.\n\n        Returns:\n            Path: Path where the docs are saved.\n        \"\"\"\n        return Path(f\"{self.save_location}/{self.friendly_name}\")\n\n    def save_page(self, content: str, page_name: str, keep_file: bool = False) -&gt; None:\n        \"\"\"Save the content of the documentation to a file.\n\n        Based on the class setup.\n        - Save Location\n        - Model Friendly Name\n        - Page to be written\n\n        Args:\n            content (str): File content to write to file.\n            page_name (str): Name of the file that will be used.\n            keep_file (bool): The file will only be overwritten if\n                the keep_file is set to False.\n\n        Returns:\n            None\n        \"\"\"\n        target_file = self.save_path / page_name\n\n        if target_file.parent.exists() is False:\n            target_file.parent.mkdir(parents=True, exist_ok=True)\n\n        if keep_file and target_file.exists():\n            logger.info(f\"{page_name} already exists -&gt; file will not overwritten.\")\n        else:\n            logger.info(f\"Results are written to -&gt; {page_name}.\")\n\n            with target_file.open(\"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n                f.close()\n\n    def save_documentation(self) -&gt; None:\n        \"\"\"Generate documentation of the model, based on the meta-data in the model definitions.\n\n        This first checks if the folder exists,\n        and then starts to export the files that are needed\n        for the documentatation.\n        - General Information Page -&gt; Free format page to create.\n        - Measure Page -&gt; Describes the measures in the model.\n        - Tables Page -&gt; Describes the tables in the model.\n        - Columns Page -&gt; Describes all columns in the model per table.\n        - Roles Page -&gt; Describes the roles in the model.\n\n        Args:\n            self (ModelDocumenter): Model object for documentation.\n\n        Returns:\n            None\n        \"\"\"\n        if self.save_path.exists():\n            logger.info(\n                f\"Path exists -&gt; Generating documentation for {self.friendly_name}\"\n            )\n        else:\n            logger.info(\n                f\"Path does not exist -&gt; Creating directory for {self.friendly_name}\"\n            )\n            self.save_path.mkdir(parents=True, exist_ok=True)\n\n        if self.general_page:\n            self.save_page(\n                content=self.general_page,\n                keep_file=True,\n                page_name=self.general_page_url,\n            )\n\n        if self.measure_page:\n            self.save_page(\n                content=self.measure_page,\n                keep_file=False,\n                page_name=self.measure_page_url,\n            )\n\n        for table in self.create_markdown_for_table_and_column():\n            table = table.items()\n            page_name, page_content = list(table)[0]\n            self.save_page(\n                content=page_content,\n                keep_file=False,\n                page_name=f\"{self.table_folder}/{page_name}\",\n            )\n\n        if self.roles_page:\n            self.save_page(\n                content=self.roles_page, keep_file=False, page_name=self.roles_page_url\n            )\n\n    def create_markdown_for_measure(self, object: PyMeasure) -&gt; str:\n        \"\"\"Create Markdown for a specific measure.\n\n        That can later on be used for generating the whole measure page.\n\n        Args:\n            object (PyMeasure): The measure to document.\n\n        Returns:\n            str: Markdown section for specific Measure\n        \"\"\"\n        object_caption = (\n            self.get_object_caption(\n                object_name=object.Name, object_parent=object.Parent.Name\n            )\n            or object.Name\n        )\n\n        obj_description = (object.Description or \"No Description available\").replace(\n            \"\\\\n\", \"\"\n        )\n\n        obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n        object_properties = [\n            {\"Measure Name\": object.Name},\n            {\"Display Folder\": object.DisplayFolder},\n            {\"Format String\": object.FormatString},\n            {\"Is Hidden\": \"Yes\" if object.IsHidden else \"No\"},\n        ]\n\n        obj_text = [\n            f\"### {object_caption}\",\n            \"**Description**:\",\n            f\"&gt; {obj_description}\",\n            \"\",\n            \"\" f\"{self.generate_object_properties(object_properties)}\" \"\",\n            f'```dax title=\"Technical: {object.Name}\"',\n            f\"{object.Expression}\",\n            \"```\",\n            \"---\",\n        ]\n        return \"\\n\".join(obj_text)\n\n    def generate_markdown_measure_page(self) -&gt; str:\n        \"\"\"This function generates the meausure documation page.\n\n        Returns:\n            str: The full markdown text that is needed\n                make it compatible with Docusaurus.\n        \"\"\"\n        prev_display_folder = \"\"\n        markdown_template = [\n            \"---\",\n            \"sidebar_position: 1\",\n            \"title: Measures\",\n            \"description: This page contains all measures for \"\n            f\"the {self.model.Name} model, including the description, \"\n            \"format string, and other technical details.\",\n            \"---\",\n            \"\",\n            f\"# Measures for {self.model.Name}\",\n        ]\n\n        measures = sorted(\n            self.model.Measures, key=lambda x: x.DisplayFolder, reverse=False\n        )\n\n        for measure in measures:\n            logger.debug(f\"Creating docs for {measure.Name}\")\n            display_folder = measure.DisplayFolder or \"Other\"\n            display_folder = display_folder.split(\"\\\\\")[0]\n\n            if prev_display_folder != display_folder:\n                markdown_template.append(f\"\"\"## {display_folder}\"\"\")\n                prev_display_folder = display_folder\n\n            markdown_template.append(self.create_markdown_for_measure(measure))\n\n        return \"\\n\".join(markdown_template)\n\n    def create_markdown_for_table_and_column(self) -&gt; list:\n        \"\"\"Create Pages for Tables and Columns.\n\n        Based on the model this functions creates a general\n        overview pages for all tables and then with per\n        table a page with all column details.\n\n        Returns:\n            list: List of dicts per page.\n\n        Example:\n            ```\n                {\n                    \"Overview\": \"Content\",\n                    \"Table1\": \"Content\",\n                    \"Table2\": \"Content\",\n                }\n\n        \"\"\"\n        obj_content = [{\"index.md\": self.generate_markdown_table_page()}]\n\n        for idx, table in enumerate(self.model.Tables):\n            obj_caption = (\n                self.get_object_caption(\n                    object_name=table.Name, object_parent=table.Parent.Name\n                )\n                or table.Name\n            )\n\n            obj_caption = obj_caption.replace(\"[\", \"\").replace(\"]\", \"\")\n\n            key = f\"{self.set_url_friendly_name(obj_caption)}.md\"\n            value = self.generate_markdown_column_page(\n                object=table, object_caption=obj_caption, page_index=idx + 2\n            )\n\n            obj_content.append({key: value})\n\n        return obj_content\n\n    def create_markdown_for_table(self, object: PyTable) -&gt; str:\n        \"\"\"This functions returns the markdown for a table.\n\n        Args:\n            object (PyTable): Based on the PyTabular Package.\n\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\n        object_caption = (\n            self.get_object_caption(\n                object_name=object.Name, object_parent=object.Parent.Name\n            )\n            or object.Name\n        )\n\n        obj_description = (object.Description or \"No Description available\").replace(\n            \"\\\\n\", \"\"\n        )\n\n        object_properties = [\n            {\"Measures (#)\": len(object.Measures)},\n            {\"Columns (#)\": len(object.Columns)},\n            {\"Partiton (#)\": len(object.Partitions)},\n            {\"Data Category\": object.DataCategory or \"Regular Table\"},\n            {\"Is Hidden\": object.IsHidden},\n            {\"Table Type\": object.Partitions[0].ObjectType},\n            {\"Source Type\": object.Partitions[0].SourceType},\n        ]\n\n        obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n        partition_type = \"\"\n        partition_source = \"\"\n\n        logger.debug(f\"{object_caption} =&gt; {str(object.Partitions[0].SourceType)}\")\n\n        if str(object.Partitions[0].SourceType) == \"Calculated\":\n            partition_type = \"dax\"\n            partition_source = object.Partitions[0].Source.Expression\n        elif str(object.Partitions[0].SourceType) == \"M\":\n            partition_type = \"powerquery\"\n            partition_source = object.Partitions[0].Source.Expression\n        elif str(object.Partitions[0].SourceType) == \"CalculationGroup\":\n            partition_type = \"\"\n            partition_source = \"\"\n        else:\n            partition_type = \"sql\"\n            partition_source = object.Partitions[0].Source.Query\n\n        obj_text = [\n            f\"### {object_caption}\",\n            \"**Description**: \",\n            f\"&gt; {obj_description}\",\n            \"\",\n            f\"{self.generate_object_properties(object_properties)}\",\n            \"\",\n            f'```{partition_type} title=\"Table Source: {object.Name}\"',\n            f\"{partition_source}\",\n            \"```\",\n            \"---\",\n        ]\n\n        return \"\\n\".join(obj_text)\n\n    def generate_markdown_table_page(self) -&gt; str:\n        \"\"\"This function generates the markdown for table documentation.\n\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\n        markdown_template = [\n            \"---\",\n            \"sidebar_position: 2\",\n            \"sidebar_label: Tables\",\n            \"description: This page contains all columns with \"\n            f\"tables for {self.model.Name}, including the description, \"\n            \"and technical details.\",\n            \"---\",\n            \"\",\n            f\"# Tables {self.model.Name}\",\n        ]\n\n        markdown_template.extend(\n            self.create_markdown_for_table(table) for table in self.model.Tables\n        )\n        return \"\\n\".join(markdown_template)\n\n    def create_markdown_for_column(self, object: PyColumn) -&gt; str:\n        \"\"\"Generates the Markdown for a specifc column.\n\n        If a columns is calculated, then it also shows the expression for\n        that column in DAX.\n\n        Args:\n            object (PyColumn): Needs PyColumn objects input\n\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\n        object_caption = (\n            self.get_object_caption(\n                object_name=object.Name, object_parent=object.Parent.Name\n            )\n            or object.Name\n        )\n\n        obj_description = (\n            object.Description.replace(\"\\\\n\", \"\") or \"No Description available\"\n        )\n\n        obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n        obj_heading = f\"\"\"{object_caption}\"\"\"\n\n        object_properties = [\n            {\"Column Name\": object.Name},\n            {\"Object Type\": object.ObjectType},\n            {\"Type\": object.Type},\n            {\"Is Available In Excel\": object.IsAvailableInMDX},\n            {\"Is Hidden\": object.IsHidden},\n            {\"Data Category\": object.DataCategory},\n            {\"Data Type\": object.DataType},\n            {\"Display Folder\": object.DisplayFolder},\n        ]\n\n        obj_text = [\n            f\"### {obj_heading}\",\n            \"**Description**:\",\n            f\"&gt; {obj_description}\",\n            \"\",\n            f\"{self.generate_object_properties(object_properties)}\",\n        ]\n\n        if str(object.Type) == \"Calculated\":\n            obj_text.extend(\n                (\n                    f'```dax title=\"Technical: {object.Name}\"',\n                    f\"{object.Expression}\",\n                    \"```\",\n                )\n            )\n        obj_text.append(\"---\")\n\n        return \"\\n\".join(obj_text)\n\n    def generate_markdown_column_page(\n        self, object: PyTable, object_caption: str, page_index: int = 2\n    ) -&gt; str:\n        \"\"\"This function generates the markdown for the colums documentation.\n\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\n        markdown_template = [\n            \"---\",\n            f\"sidebar_position: {page_index}\",\n            f\"sidebar_label: {object_caption}\",\n            f\"title: {object_caption}\",\n            f\"description: This page contains all columns with \"\n            f\"Columns for {self.model.Name} \"\n            \"including the description, format string, and other technical details.\",\n            \"---\",\n            \"\",\n        ]\n\n        markdown_template.extend(\n            self.create_markdown_for_column(column)\n            for column in object.Columns\n            if \"RowNumber\" not in column.Name\n        )\n        return \"\\n\".join(markdown_template)\n\n    def generate_general_info_file(self) -&gt; str:\n        \"\"\"Index.md file for the model.\n\n        Basic text for an introduction page.\n\n        Returns:\n            str: Markdown str for info page\n        \"\"\"\n        return \"\\n\".join(\n            [\n                \"---\",\n                \"sidebar_position: 1\",\n                f\"title: {self.model_name}\",\n                \"description: This page contains all measures for the Model model,\"\n                \"including the description,\"\n                \"format string, and other technical details.\",\n                \"---\",\n                \"\",\n                \"## General information\",\n                \"### Business Owners\",\n                \"\",\n                \"## Information Sources\",\n            ]\n        )\n\n    @staticmethod\n    def generate_object_properties(properties: List[Dict[str, str]]) -&gt; str:\n        \"\"\"Generate the section for object properties.\n\n        You can select your own properties to display\n        by providing a the properties in a list of\n        dicts.\n\n        Args:\n            properties (dict): The ones you want to show.\n\n        Returns:\n            str: HTML used in the markdown.\n\n        Example:\n            ```python\n                [\n                    { \"Display Folder\": \"Sales Order Information\" },\n                    { \"Is Hidden\": \"False\" },\n                    { \"Format String\": \"#.###,## }\n                ]\n            ```\n            Returns:\n            ```\n            &lt;dl&gt;\n                &lt;dt&gt;Display Folder&lt;/dt&gt;\n                &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n\n                &lt;dt&gt;Is Hidden&lt;/dt&gt;\n                &lt;dd&gt;False&lt;/dd&gt;\n\n                &lt;dt&gt;Format String&lt;/dt&gt;\n                &lt;dd&gt;#.###,##&lt;/dd&gt;\n            &lt;/dl&gt;\n            ```\n        \"\"\"\n        obj_text = [\"&lt;dl&gt;\"]\n\n        for obj_prop in properties:\n            for caption, text in obj_prop.items():\n                save_text = str(text).replace(\"\\\\\", \" &gt; \")\n                obj_text.extend(\n                    (f\"  &lt;dt&gt;{caption}&lt;/dt&gt;\", f\"  &lt;dd&gt;{save_text}&lt;/dd&gt;\", \"\")\n                )\n        obj_text.extend((\"&lt;/dl&gt;\", \"\"))\n        return \"\\n\".join(obj_text)\n\n    @staticmethod\n    def set_url_friendly_name(page_name: str) -&gt; str:\n        \"\"\"Replaces the model name to a friendly string, so it can be used in an URL.\n\n        Returns:\n            str: Friendly model name used in url for docs.\n        \"\"\"\n        # return (self.model_name).replace(\" \", \"-\").replace(\"_\", \"-\").lower()\n        return (\n            page_name.replace(\" \", \"-\")\n            .replace(\"_\", \"-\")\n            .lower()\n            .replace(\"[\", \"\")\n            .replace(\"]\", \"\")\n        )\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.__init__","title":"<code>__init__(model, friendly_name=str(), save_location='docs', general_page_url='index.md', measure_page_url='measures.md', roles_page_url='roles.md', table_folder='tables')</code>","text":"<p>Init will set attributes based on arguments given.</p> <p>See <code>generate_documentation_pages()</code> and <code>save_documentation()</code> for info on how to execute and retrieve documentation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Tabular</code> <p>Main <code>Tabular()</code> class to pull metadata from for documentation.</p> required <code>friendly_name</code> <code>str</code> <p>Replaces the model name to a friendly string, so it can be used in an URL. Defaults to <code>str()</code>.</p> <code>str()</code> <code>save_location</code> <code>str</code> <p>The save location where the files will be stored. Defaults to \"docs\".</p> <code>'docs'</code> <code>general_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for general information. Defaults to \"index.md\".</p> <code>'index.md'</code> <code>measure_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for measures. Defaults to \"measures.md\".</p> <code>'measures.md'</code> <code>table_folder</code> <code>str</code> <p>Name of the folder where columns info is stored. Defaults to \"table_folder\".</p> <code>'tables'</code> <code>roles_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for roles. Defaults to \"roles.md\".</p> <code>'roles.md'</code> Source code in <code>pytabular/document.py</code> <pre><code>def __init__(\n    self,\n    model: Tabular,\n    friendly_name: str = str(),\n    save_location: str = \"docs\",\n    general_page_url: str = \"index.md\",\n    measure_page_url: str = \"measures.md\",\n    roles_page_url: str = \"roles.md\",\n    table_folder: str = \"tables\",\n    # table_page_url: str = \"3-tables.md\",\n    # column_page_url: str = \"4-columns.md\",\n):\n    \"\"\"Init will set attributes based on arguments given.\n\n    See `generate_documentation_pages()` and `save_documentation()`\n    for info on how to execute and retrieve documentation.\n\n    Args:\n        model (Tabular): Main `Tabular()` class to pull metadata from for documentation.\n        friendly_name (str, optional): Replaces the model name to a friendly string,\n            so it can be used in an URL. Defaults to `str()`.\n        save_location (str, optional): The save location where the files will be stored.\n            Defaults to \"docs\".\n        general_page_url (str, optional): Name of the `md` file for general information.\n            Defaults to \"index.md\".\n        measure_page_url (str, optional): Name of the `md` file for measures.\n            Defaults to \"measures.md\".\n        table_folder (str, optional): Name of the folder where columns info is stored.\n            Defaults to \"table_folder\".\n        roles_page_url (str, optional): Name of the `md` file for roles.\n            Defaults to \"roles.md\".\n    \"\"\"\n    self.model = model\n    self.model_name = friendly_name or model.Catalog or model.Database.Name\n    self.friendly_name: str = str()\n    self.save_path: Path\n    self.save_location: str = save_location\n\n    # Translation information\n    self.culture_include: bool = False\n    self.culture_selected: str = \"en-US\"\n    self.culture_object: PyCulture\n\n    # Documentation Parts\n    self.general_page: str = str()\n    self.general_page_url: str = general_page_url\n\n    self.measure_page: str = str()\n    self.measure_page_url: str = measure_page_url\n\n    self.roles_page: str = str()\n    self.roles_page_url: str = roles_page_url\n\n    self.table_page: str = str()\n    self.table_folder: str = table_folder\n\n    # Generate an url friendly name for the model / folder\n    self.friendly_name: str = self.set_url_friendly_name(self.model_name)\n\n    # Initialize Save path so checks can be run against it.\n    self.save_path = self.set_save_path()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_object_reference","title":"<code>create_object_reference(object, object_parent)</code>","text":"<p>Create a Custom ID for link sections in the docs.</p> <p>This is based on the technical names in the model, so not the once in the translations. This makes it possible to link based on dependencies. (Scope is only Docusaurus)</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str</code> <p>Object Name</p> required <code>object_parent</code> <code>str</code> <p>Object Parent (e.g. Table)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String that can be used for custom linking</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_object_reference(self, object: str, object_parent: str) -&gt; str:\n    \"\"\"Create a Custom ID for link sections in the docs.\n\n    This is based on the technical names in the model,\n    so not the once in the translations. This makes it\n    possible to link based on dependencies.\n    (Scope is only Docusaurus)\n\n    Args:\n        object (str): Object Name\n        object_parent (str): Object Parent (e.g. Table)\n\n    Returns:\n        str: String that can be used for custom linking\n    \"\"\"\n    url_reference = f\"{object_parent}-{object}\".replace(\" \", \"\")\n    return f\"{{#{url_reference}}}\"\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_documentation_pages","title":"<code>generate_documentation_pages()</code>","text":"<p>Generate Documentation for each specific part of the model.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_documentation_pages(self) -&gt; None:\n    \"\"\"Generate Documentation for each specific part of the model.\"\"\"\n    self.measure_page = self.generate_markdown_measure_page()\n    self.table_page = self.generate_markdown_table_page()\n    self.general_page = self.generate_general_info_file()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.get_object_caption","title":"<code>get_object_caption(object_name, object_parent)</code>","text":"<p>Retrieves the caption of an object, based on the translations in the culture.</p> <p>If no culture is present, the object_name is returned.</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>Object Name</p> required <code>object_parent</code> <code>str</code> <p>Object Parent Name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Translated object.</p> Source code in <code>pytabular/document.py</code> <pre><code>def get_object_caption(self, object_name: str, object_parent: str) -&gt; str:\n    \"\"\"Retrieves the caption of an object, based on the translations in the culture.\n\n    If no culture is present, the object_name is returned.\n\n    Args:\n        object_name (str): Object Name\n        object_parent (str): Object Parent Name\n\n    Returns:\n        str: Translated object.\n    \"\"\"\n    if self.culture_include:\n        return str(\n            self.culture_object.get_translation(\n                object_name=object_name, object_parent_name=object_parent\n            ).get(\"object_translation\")\n        )\n\n    return object_name\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_translations","title":"<code>set_translations(enable_translations=False, culture='en-US')</code>","text":"<p>Set translations to active or inactive, depending on the needs of the users.</p> <p>Parameters:</p> Name Type Description Default <code>enable_translations</code> <code>bool</code> <p>Flag to enable or disable translations. Defaults to False.</p> <code>False</code> <code>culture</code> <code>str</code> <p>Set culture that needs to be used in the docs. Defaults to \"en-US\".</p> <code>'en-US'</code> Source code in <code>pytabular/document.py</code> <pre><code>def set_translations(\n    self, enable_translations: bool = False, culture: str = \"en-US\"\n) -&gt; None:\n    \"\"\"Set translations to active or inactive, depending on the needs of the users.\n\n    Args:\n        enable_translations (bool, optional): Flag to enable or disable translations.\n            Defaults to False.\n        culture (str, optional): Set culture that needs to be used in the docs.\n            Defaults to \"en-US\".\n    \"\"\"\n    logger.info(f\"Using Translations set to &gt; {enable_translations}\")\n\n    if enable_translations:\n        try:\n            self.culture_object = self.model.Cultures[culture]\n            self.culture_selected = culture\n            self.culture_include = enable_translations\n        except IndexError:\n            self.culture_include = False\n            logger.warn(\n                \"Culture not found, reverting back to orginal setting &gt; False\"\n            )\n        else:\n            logger.info(f\"Setting culture to {self.culture_selected}\")\n\n    else:\n        self.culture_include = enable_translations\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_save_path","title":"<code>set_save_path()</code>","text":"<p>Set the location of the documentation.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path where the docs are saved.</p> Source code in <code>pytabular/document.py</code> <pre><code>def set_save_path(self) -&gt; Path:\n    \"\"\"Set the location of the documentation.\n\n    Returns:\n        Path: Path where the docs are saved.\n    \"\"\"\n    return Path(f\"{self.save_location}/{self.friendly_name}\")\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.save_page","title":"<code>save_page(content, page_name, keep_file=False)</code>","text":"<p>Save the content of the documentation to a file.</p> <p>Based on the class setup. - Save Location - Model Friendly Name - Page to be written</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>File content to write to file.</p> required <code>page_name</code> <code>str</code> <p>Name of the file that will be used.</p> required <code>keep_file</code> <code>bool</code> <p>The file will only be overwritten if the keep_file is set to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pytabular/document.py</code> <pre><code>def save_page(self, content: str, page_name: str, keep_file: bool = False) -&gt; None:\n    \"\"\"Save the content of the documentation to a file.\n\n    Based on the class setup.\n    - Save Location\n    - Model Friendly Name\n    - Page to be written\n\n    Args:\n        content (str): File content to write to file.\n        page_name (str): Name of the file that will be used.\n        keep_file (bool): The file will only be overwritten if\n            the keep_file is set to False.\n\n    Returns:\n        None\n    \"\"\"\n    target_file = self.save_path / page_name\n\n    if target_file.parent.exists() is False:\n        target_file.parent.mkdir(parents=True, exist_ok=True)\n\n    if keep_file and target_file.exists():\n        logger.info(f\"{page_name} already exists -&gt; file will not overwritten.\")\n    else:\n        logger.info(f\"Results are written to -&gt; {page_name}.\")\n\n        with target_file.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            f.close()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.save_documentation","title":"<code>save_documentation()</code>","text":"<p>Generate documentation of the model, based on the meta-data in the model definitions.</p> <p>This first checks if the folder exists, and then starts to export the files that are needed for the documentatation. - General Information Page -&gt; Free format page to create. - Measure Page -&gt; Describes the measures in the model. - Tables Page -&gt; Describes the tables in the model. - Columns Page -&gt; Describes all columns in the model per table. - Roles Page -&gt; Describes the roles in the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ModelDocumenter</code> <p>Model object for documentation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pytabular/document.py</code> <pre><code>def save_documentation(self) -&gt; None:\n    \"\"\"Generate documentation of the model, based on the meta-data in the model definitions.\n\n    This first checks if the folder exists,\n    and then starts to export the files that are needed\n    for the documentatation.\n    - General Information Page -&gt; Free format page to create.\n    - Measure Page -&gt; Describes the measures in the model.\n    - Tables Page -&gt; Describes the tables in the model.\n    - Columns Page -&gt; Describes all columns in the model per table.\n    - Roles Page -&gt; Describes the roles in the model.\n\n    Args:\n        self (ModelDocumenter): Model object for documentation.\n\n    Returns:\n        None\n    \"\"\"\n    if self.save_path.exists():\n        logger.info(\n            f\"Path exists -&gt; Generating documentation for {self.friendly_name}\"\n        )\n    else:\n        logger.info(\n            f\"Path does not exist -&gt; Creating directory for {self.friendly_name}\"\n        )\n        self.save_path.mkdir(parents=True, exist_ok=True)\n\n    if self.general_page:\n        self.save_page(\n            content=self.general_page,\n            keep_file=True,\n            page_name=self.general_page_url,\n        )\n\n    if self.measure_page:\n        self.save_page(\n            content=self.measure_page,\n            keep_file=False,\n            page_name=self.measure_page_url,\n        )\n\n    for table in self.create_markdown_for_table_and_column():\n        table = table.items()\n        page_name, page_content = list(table)[0]\n        self.save_page(\n            content=page_content,\n            keep_file=False,\n            page_name=f\"{self.table_folder}/{page_name}\",\n        )\n\n    if self.roles_page:\n        self.save_page(\n            content=self.roles_page, keep_file=False, page_name=self.roles_page_url\n        )\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_measure","title":"<code>create_markdown_for_measure(object)</code>","text":"<p>Create Markdown for a specific measure.</p> <p>That can later on be used for generating the whole measure page.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyMeasure</code> <p>The measure to document.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Markdown section for specific Measure</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_measure(self, object: PyMeasure) -&gt; str:\n    \"\"\"Create Markdown for a specific measure.\n\n    That can later on be used for generating the whole measure page.\n\n    Args:\n        object (PyMeasure): The measure to document.\n\n    Returns:\n        str: Markdown section for specific Measure\n    \"\"\"\n    object_caption = (\n        self.get_object_caption(\n            object_name=object.Name, object_parent=object.Parent.Name\n        )\n        or object.Name\n    )\n\n    obj_description = (object.Description or \"No Description available\").replace(\n        \"\\\\n\", \"\"\n    )\n\n    obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n    object_properties = [\n        {\"Measure Name\": object.Name},\n        {\"Display Folder\": object.DisplayFolder},\n        {\"Format String\": object.FormatString},\n        {\"Is Hidden\": \"Yes\" if object.IsHidden else \"No\"},\n    ]\n\n    obj_text = [\n        f\"### {object_caption}\",\n        \"**Description**:\",\n        f\"&gt; {obj_description}\",\n        \"\",\n        \"\" f\"{self.generate_object_properties(object_properties)}\" \"\",\n        f'```dax title=\"Technical: {object.Name}\"',\n        f\"{object.Expression}\",\n        \"```\",\n        \"---\",\n    ]\n    return \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_measure_page","title":"<code>generate_markdown_measure_page()</code>","text":"<p>This function generates the meausure documation page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full markdown text that is needed make it compatible with Docusaurus.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_measure_page(self) -&gt; str:\n    \"\"\"This function generates the meausure documation page.\n\n    Returns:\n        str: The full markdown text that is needed\n            make it compatible with Docusaurus.\n    \"\"\"\n    prev_display_folder = \"\"\n    markdown_template = [\n        \"---\",\n        \"sidebar_position: 1\",\n        \"title: Measures\",\n        \"description: This page contains all measures for \"\n        f\"the {self.model.Name} model, including the description, \"\n        \"format string, and other technical details.\",\n        \"---\",\n        \"\",\n        f\"# Measures for {self.model.Name}\",\n    ]\n\n    measures = sorted(\n        self.model.Measures, key=lambda x: x.DisplayFolder, reverse=False\n    )\n\n    for measure in measures:\n        logger.debug(f\"Creating docs for {measure.Name}\")\n        display_folder = measure.DisplayFolder or \"Other\"\n        display_folder = display_folder.split(\"\\\\\")[0]\n\n        if prev_display_folder != display_folder:\n            markdown_template.append(f\"\"\"## {display_folder}\"\"\")\n            prev_display_folder = display_folder\n\n        markdown_template.append(self.create_markdown_for_measure(measure))\n\n    return \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_table_and_column","title":"<code>create_markdown_for_table_and_column()</code>","text":"<p>Create Pages for Tables and Columns.</p> <p>Based on the model this functions creates a general overview pages for all tables and then with per table a page with all column details.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of dicts per page.</p> Example <p>```     {         \"Overview\": \"Content\",         \"Table1\": \"Content\",         \"Table2\": \"Content\",     }</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_table_and_column(self) -&gt; list:\n    \"\"\"Create Pages for Tables and Columns.\n\n    Based on the model this functions creates a general\n    overview pages for all tables and then with per\n    table a page with all column details.\n\n    Returns:\n        list: List of dicts per page.\n\n    Example:\n        ```\n            {\n                \"Overview\": \"Content\",\n                \"Table1\": \"Content\",\n                \"Table2\": \"Content\",\n            }\n\n    \"\"\"\n    obj_content = [{\"index.md\": self.generate_markdown_table_page()}]\n\n    for idx, table in enumerate(self.model.Tables):\n        obj_caption = (\n            self.get_object_caption(\n                object_name=table.Name, object_parent=table.Parent.Name\n            )\n            or table.Name\n        )\n\n        obj_caption = obj_caption.replace(\"[\", \"\").replace(\"]\", \"\")\n\n        key = f\"{self.set_url_friendly_name(obj_caption)}.md\"\n        value = self.generate_markdown_column_page(\n            object=table, object_caption=obj_caption, page_index=idx + 2\n        )\n\n        obj_content.append({key: value})\n\n    return obj_content\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_table","title":"<code>create_markdown_for_table(object)</code>","text":"<p>This functions returns the markdown for a table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyTable</code> <p>Based on the PyTabular Package.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_table(self, object: PyTable) -&gt; str:\n    \"\"\"This functions returns the markdown for a table.\n\n    Args:\n        object (PyTable): Based on the PyTabular Package.\n\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\n    object_caption = (\n        self.get_object_caption(\n            object_name=object.Name, object_parent=object.Parent.Name\n        )\n        or object.Name\n    )\n\n    obj_description = (object.Description or \"No Description available\").replace(\n        \"\\\\n\", \"\"\n    )\n\n    object_properties = [\n        {\"Measures (#)\": len(object.Measures)},\n        {\"Columns (#)\": len(object.Columns)},\n        {\"Partiton (#)\": len(object.Partitions)},\n        {\"Data Category\": object.DataCategory or \"Regular Table\"},\n        {\"Is Hidden\": object.IsHidden},\n        {\"Table Type\": object.Partitions[0].ObjectType},\n        {\"Source Type\": object.Partitions[0].SourceType},\n    ]\n\n    obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n    partition_type = \"\"\n    partition_source = \"\"\n\n    logger.debug(f\"{object_caption} =&gt; {str(object.Partitions[0].SourceType)}\")\n\n    if str(object.Partitions[0].SourceType) == \"Calculated\":\n        partition_type = \"dax\"\n        partition_source = object.Partitions[0].Source.Expression\n    elif str(object.Partitions[0].SourceType) == \"M\":\n        partition_type = \"powerquery\"\n        partition_source = object.Partitions[0].Source.Expression\n    elif str(object.Partitions[0].SourceType) == \"CalculationGroup\":\n        partition_type = \"\"\n        partition_source = \"\"\n    else:\n        partition_type = \"sql\"\n        partition_source = object.Partitions[0].Source.Query\n\n    obj_text = [\n        f\"### {object_caption}\",\n        \"**Description**: \",\n        f\"&gt; {obj_description}\",\n        \"\",\n        f\"{self.generate_object_properties(object_properties)}\",\n        \"\",\n        f'```{partition_type} title=\"Table Source: {object.Name}\"',\n        f\"{partition_source}\",\n        \"```\",\n        \"---\",\n    ]\n\n    return \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_table_page","title":"<code>generate_markdown_table_page()</code>","text":"<p>This function generates the markdown for table documentation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_table_page(self) -&gt; str:\n    \"\"\"This function generates the markdown for table documentation.\n\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\n    markdown_template = [\n        \"---\",\n        \"sidebar_position: 2\",\n        \"sidebar_label: Tables\",\n        \"description: This page contains all columns with \"\n        f\"tables for {self.model.Name}, including the description, \"\n        \"and technical details.\",\n        \"---\",\n        \"\",\n        f\"# Tables {self.model.Name}\",\n    ]\n\n    markdown_template.extend(\n        self.create_markdown_for_table(table) for table in self.model.Tables\n    )\n    return \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_column","title":"<code>create_markdown_for_column(object)</code>","text":"<p>Generates the Markdown for a specifc column.</p> <p>If a columns is calculated, then it also shows the expression for that column in DAX.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyColumn</code> <p>Needs PyColumn objects input</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_column(self, object: PyColumn) -&gt; str:\n    \"\"\"Generates the Markdown for a specifc column.\n\n    If a columns is calculated, then it also shows the expression for\n    that column in DAX.\n\n    Args:\n        object (PyColumn): Needs PyColumn objects input\n\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\n    object_caption = (\n        self.get_object_caption(\n            object_name=object.Name, object_parent=object.Parent.Name\n        )\n        or object.Name\n    )\n\n    obj_description = (\n        object.Description.replace(\"\\\\n\", \"\") or \"No Description available\"\n    )\n\n    obj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\n\n    obj_heading = f\"\"\"{object_caption}\"\"\"\n\n    object_properties = [\n        {\"Column Name\": object.Name},\n        {\"Object Type\": object.ObjectType},\n        {\"Type\": object.Type},\n        {\"Is Available In Excel\": object.IsAvailableInMDX},\n        {\"Is Hidden\": object.IsHidden},\n        {\"Data Category\": object.DataCategory},\n        {\"Data Type\": object.DataType},\n        {\"Display Folder\": object.DisplayFolder},\n    ]\n\n    obj_text = [\n        f\"### {obj_heading}\",\n        \"**Description**:\",\n        f\"&gt; {obj_description}\",\n        \"\",\n        f\"{self.generate_object_properties(object_properties)}\",\n    ]\n\n    if str(object.Type) == \"Calculated\":\n        obj_text.extend(\n            (\n                f'```dax title=\"Technical: {object.Name}\"',\n                f\"{object.Expression}\",\n                \"```\",\n            )\n        )\n    obj_text.append(\"---\")\n\n    return \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_column_page","title":"<code>generate_markdown_column_page(object, object_caption, page_index=2)</code>","text":"<p>This function generates the markdown for the colums documentation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_column_page(\n    self, object: PyTable, object_caption: str, page_index: int = 2\n) -&gt; str:\n    \"\"\"This function generates the markdown for the colums documentation.\n\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\n    markdown_template = [\n        \"---\",\n        f\"sidebar_position: {page_index}\",\n        f\"sidebar_label: {object_caption}\",\n        f\"title: {object_caption}\",\n        f\"description: This page contains all columns with \"\n        f\"Columns for {self.model.Name} \"\n        \"including the description, format string, and other technical details.\",\n        \"---\",\n        \"\",\n    ]\n\n    markdown_template.extend(\n        self.create_markdown_for_column(column)\n        for column in object.Columns\n        if \"RowNumber\" not in column.Name\n    )\n    return \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_general_info_file","title":"<code>generate_general_info_file()</code>","text":"<p>Index.md file for the model.</p> <p>Basic text for an introduction page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Markdown str for info page</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_general_info_file(self) -&gt; str:\n    \"\"\"Index.md file for the model.\n\n    Basic text for an introduction page.\n\n    Returns:\n        str: Markdown str for info page\n    \"\"\"\n    return \"\\n\".join(\n        [\n            \"---\",\n            \"sidebar_position: 1\",\n            f\"title: {self.model_name}\",\n            \"description: This page contains all measures for the Model model,\"\n            \"including the description,\"\n            \"format string, and other technical details.\",\n            \"---\",\n            \"\",\n            \"## General information\",\n            \"### Business Owners\",\n            \"\",\n            \"## Information Sources\",\n        ]\n    )\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_object_properties","title":"<code>generate_object_properties(properties)</code>  <code>staticmethod</code>","text":"<p>Generate the section for object properties.</p> <p>You can select your own properties to display by providing a the properties in a list of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>dict</code> <p>The ones you want to show.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>HTML used in the markdown.</p> Example <p><pre><code>    [\n        { \"Display Folder\": \"Sales Order Information\" },\n        { \"Is Hidden\": \"False\" },\n        { \"Format String\": \"#.###,## }\n    ]\n</code></pre> Returns: <pre><code>&lt;dl&gt;\n    &lt;dt&gt;Display Folder&lt;/dt&gt;\n    &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n\n    &lt;dt&gt;Is Hidden&lt;/dt&gt;\n    &lt;dd&gt;False&lt;/dd&gt;\n\n    &lt;dt&gt;Format String&lt;/dt&gt;\n    &lt;dd&gt;#.###,##&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre></p> Source code in <code>pytabular/document.py</code> <pre><code>@staticmethod\ndef generate_object_properties(properties: List[Dict[str, str]]) -&gt; str:\n    \"\"\"Generate the section for object properties.\n\n    You can select your own properties to display\n    by providing a the properties in a list of\n    dicts.\n\n    Args:\n        properties (dict): The ones you want to show.\n\n    Returns:\n        str: HTML used in the markdown.\n\n    Example:\n        ```python\n            [\n                { \"Display Folder\": \"Sales Order Information\" },\n                { \"Is Hidden\": \"False\" },\n                { \"Format String\": \"#.###,## }\n            ]\n        ```\n        Returns:\n        ```\n        &lt;dl&gt;\n            &lt;dt&gt;Display Folder&lt;/dt&gt;\n            &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n\n            &lt;dt&gt;Is Hidden&lt;/dt&gt;\n            &lt;dd&gt;False&lt;/dd&gt;\n\n            &lt;dt&gt;Format String&lt;/dt&gt;\n            &lt;dd&gt;#.###,##&lt;/dd&gt;\n        &lt;/dl&gt;\n        ```\n    \"\"\"\n    obj_text = [\"&lt;dl&gt;\"]\n\n    for obj_prop in properties:\n        for caption, text in obj_prop.items():\n            save_text = str(text).replace(\"\\\\\", \" &gt; \")\n            obj_text.extend(\n                (f\"  &lt;dt&gt;{caption}&lt;/dt&gt;\", f\"  &lt;dd&gt;{save_text}&lt;/dd&gt;\", \"\")\n            )\n    obj_text.extend((\"&lt;/dl&gt;\", \"\"))\n    return \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_url_friendly_name","title":"<code>set_url_friendly_name(page_name)</code>  <code>staticmethod</code>","text":"<p>Replaces the model name to a friendly string, so it can be used in an URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Friendly model name used in url for docs.</p> Source code in <code>pytabular/document.py</code> <pre><code>@staticmethod\ndef set_url_friendly_name(page_name: str) -&gt; str:\n    \"\"\"Replaces the model name to a friendly string, so it can be used in an URL.\n\n    Returns:\n        str: Friendly model name used in url for docs.\n    \"\"\"\n    # return (self.model_name).replace(\" \", \"-\").replace(\"_\", \"-\").lower()\n    return (\n        page_name.replace(\" \", \"-\")\n        .replace(\"_\", \"-\")\n        .lower()\n        .replace(\"[\", \"\")\n        .replace(\"]\", \"\")\n    )\n</code></pre>"},{"location":"logic_utils/","title":"logic_utils","text":"<p><code>logic_utils</code> used to store multiple functions that are used in many different files.</p>"},{"location":"logic_utils/#pytabular.logic_utils.ticks_to_datetime","title":"<code>ticks_to_datetime(ticks)</code>","text":"<p>Converts a C# system datetime tick into a python datatime.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>C# DateTime Tick.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: datetime of tick.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def ticks_to_datetime(ticks: int) -&gt; datetime.datetime:\n    \"\"\"Converts a C# system datetime tick into a python datatime.\n\n    Args:\n            ticks (int): C# DateTime Tick.\n\n    Returns:\n            datetime.datetime: datetime of tick.\n    \"\"\"\n    return datetime.datetime(1, 1, 1) + datetime.timedelta(microseconds=ticks // 10)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.pandas_datatype_to_tabular_datatype","title":"<code>pandas_datatype_to_tabular_datatype(df)</code>","text":"<p>Takes dataframe columns and gets respective tabular column datatype.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>dictionary with results.</p> Example <pre><code>{\n    'col1': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9700&gt;,\n    'col2': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC8840&gt;,\n    'col3': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9800&gt;\n}\n</code></pre> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def pandas_datatype_to_tabular_datatype(df: pd.DataFrame) -&gt; Dict:\n    \"\"\"Takes dataframe columns and gets respective tabular column datatype.\n\n    Args:\n            df (pd.DataFrame): Pandas DataFrame\n\n    Returns:\n            Dict: dictionary with results.\n\n    Example:\n        ```\n        {\n            'col1': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9700&gt;,\n            'col2': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC8840&gt;,\n            'col3': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9800&gt;\n        }\n        ```\n    \"\"\"\n    logger.info(\"Getting DF Column Dtypes to Tabular Dtypes...\")\n    tabular_datatype_mapping_key = {\n        \"b\": DataType.Boolean,\n        \"i\": DataType.Int64,\n        \"u\": DataType.Int64,\n        \"f\": DataType.Double,\n        \"c\": DataType.Double,\n        \"m\": DataType.DateTime,\n        \"M\": DataType.DateTime,\n        \"O\": DataType.String,\n        \"S\": DataType.String,\n        \"U\": DataType.String,\n        \"V\": DataType.String,\n    }\n    return {\n        column: tabular_datatype_mapping_key[df[column].dtype.kind]\n        for column in df.columns\n    }\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.pd_dataframe_to_m_expression","title":"<code>pd_dataframe_to_m_expression(df)</code>","text":"<p>This will take a pandas dataframe and convert to an m expression.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Pandas DataFrame</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Currently only returning string values in your tabular model.</p> Example <p><pre><code>col1  col2\n0   1     3\n1   2     4\n</code></pre> converts to <pre><code>Source=#table({\"col1\",\"col2\"},\n{\n{\"1\",\"3\"},{\"2\",\"4\"}\n})\nin\nSource\n</code></pre></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def pd_dataframe_to_m_expression(df: pd.DataFrame) -&gt; str:\n    \"\"\"This will take a pandas dataframe and convert to an m expression.\n\n    Args:\n            df (pd.DataFrame): Pandas DataFrame\n\n    Returns:\n            str: Currently only returning string values in your tabular model.\n\n    Example:\n        ```\n        col1  col2\n        0   1     3\n        1   2     4\n        ```\n        converts to\n        ```\n        Source=#table({\"col1\",\"col2\"},\n        {\n        {\"1\",\"3\"},{\"2\",\"4\"}\n        })\n        in\n        Source\n        ```\n    \"\"\"\n\n    def m_list_expression_generator(list_of_strings: List[str]) -&gt; str:\n        \"\"\"Takes a python list of strings and converts to power query m expression list format.\n\n        Ex: `[\"item1\",\"item2\",\"item3\"]` --&gt; `{\"item1\",\"item2\",\"item3\"}`\n        Codepoint reference --&gt; `\\u007b` == `{` and `\\u007d` == `}`\n        \"\"\"\n        string_components = \",\".join(\n            [f'\"{string_value}\"' for string_value in list_of_strings]\n        )\n        return f\"\\u007b{string_components}\\u007d\"\n\n    logger.debug(f\"Executing m_list_generator()... for {df.columns}\")\n    columns = m_list_expression_generator(df.columns)\n    expression_str = f\"let\\nSource=#table({columns},\\n\"\n    logger.debug(\n        f\"Iterating through rows to build expression... df has {len(df)} rows...\"\n    )\n    expression_list_rows = []\n    for _, row in df.iterrows():\n        expression_list_rows += [m_list_expression_generator(row.to_list())]\n    expression_str += f\"\\u007b\\n{','.join(expression_list_rows)}\\n\\u007d)\\nin\\nSource\"\n    return expression_str\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_folder_and_contents","title":"<code>remove_folder_and_contents(folder_location)</code>","text":"<p>Internal used in tabular_editor.py and best_practice_analyzer.py.</p> <p>Parameters:</p> Name Type Description Default <code>folder_location</code> <code>str</code> <p>Folder path to remove directory and contents.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_folder_and_contents(folder_location):\n    \"\"\"Internal used in tabular_editor.py and best_practice_analyzer.py.\n\n    Args:\n            folder_location (str): Folder path to remove directory and contents.\n    \"\"\"\n    import shutil\n\n    if os.path.exists(folder_location):\n        logger.info(f\"Removing Dir and Contents -&gt; {folder_location}\")\n        shutil.rmtree(folder_location)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_file","title":"<code>remove_file(file_path)</code>","text":"<p>Just <code>os.remove()</code> but wanted a <code>logger.info()</code> with it.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_file(file_path):\n    \"\"\"Just `os.remove()` but wanted a `logger.info()` with it.\"\"\"\n    logger.info(f\"Removing file - {file_path}\")\n    os.remove(file_path)\n    pass\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_suffix","title":"<code>remove_suffix(input_string, suffix)</code>","text":"<p>Adding for &lt;3.9 compatiblity.</p> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>str</code> <p>input string to remove suffix from.</p> required <code>suffix</code> <code>str</code> <p>suffix to be removed.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_suffix(input_string, suffix):\n    \"\"\"Adding for &lt;3.9 compatiblity.\n\n    Args:\n            input_string (str): input string to remove suffix from.\n            suffix (str): suffix to be removed.\n    \"\"\"\n    # [Stackoverflow Answer](https://stackoverflow.com/questions/66683630/removesuffix-returns-error-str-object-has-no-attribute-removesuffix)  # noqa: E501\n    output = (\n        input_string[: -len(suffix)]\n        if suffix and input_string.endswith(suffix)\n        else input_string\n    )\n    return output\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.get_sub_list","title":"<code>get_sub_list(lst, n)</code>","text":"<p>Nest list by n amount.</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list</code> <p>List to nest.</p> required <code>n</code> <code>int</code> <p>Amount to nest list.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Nested list.</p> <p>Example:     <code>get_sub_list([1,2,3,4,5,6],2) == [[1,2],[3,4],[5,6]]</code></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def get_sub_list(lst: list, n: int) -&gt; list:\n    \"\"\"Nest list by n amount.\n\n    Args:\n        lst (list): List to nest.\n        n (int): Amount to nest list.\n\n    Returns:\n        list: Nested list.\n    Example:\n        `get_sub_list([1,2,3,4,5,6],2) == [[1,2],[3,4],[5,6]]`\n    \"\"\"\n    return [lst[i : i + n] for i in range(0, len(lst), n)]\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.get_value_to_df","title":"<code>get_value_to_df(query, index)</code>","text":"<p>Gets the values from the AdomdDataReader to convert to python df.</p> <p>Lots of room for improvement on this one.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>AdomdDataReader</code> <p>The AdomdDataReader .Net object.</p> required <code>index</code> <code>int</code> <p>Index of the value to perform the logic on.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def get_value_to_df(query: AdomdDataReader, index: int):\n    \"\"\"Gets the values from the AdomdDataReader to convert to python df.\n\n    Lots of room for improvement on this one.\n\n    Args:\n        query (AdomdDataReader): The AdomdDataReader .Net object.\n        index (int): Index of the value to perform the logic on.\n    \"\"\"\n    if (\n        query.GetDataTypeName((index)) in (\"Decimal\")\n        and query.GetValue(index) is not None\n    ):\n        return query.GetValue(index).ToDouble(query.GetValue(index))\n    else:\n        return query.GetValue(index)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.dataframe_to_dict","title":"<code>dataframe_to_dict(df)</code>","text":"<p>Convert to Dataframe to dictionary and alter columns names with it.</p> <p>Will convert the underscores (_) to spaces, and all strings are converted to Title Case.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Original table that needs to be converted to a list with dicts.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>list of dictionaries.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def dataframe_to_dict(df: pd.DataFrame) -&gt; List[dict]:\n    \"\"\"Convert to Dataframe to dictionary and alter columns names with it.\n\n    Will convert the underscores (_) to spaces,\n    and all strings are converted to Title Case.\n\n    Args:\n        df (pd.DataFrame): Original table that needs to be converted\n            to a list with dicts.\n\n    Returns:\n        list of dictionaries.\n    \"\"\"\n    list_of_dicts = df.to_dict(\"records\")\n    return [\n        {k.replace(\"_\", \" \").title(): v for k, v in dict.items()}\n        for dict in list_of_dicts\n    ]\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.dict_to_markdown_table","title":"<code>dict_to_markdown_table(list_of_dicts, columns_to_include=None)</code>","text":"<p>Generate a Markdown table based on a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>list_of_dicts</code> <code>list</code> <p>List of Dictionaries that need to be converted to a markdown table.</p> required <code>columns_to_include</code> <code>list</code> <p>Default = None, and all colums are included. If a list is supplied, those columns will be included.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>String that will represent a table in Markdown.</p> Example <p><pre><code>    columns = ['Referenced Object Type', 'Referenced Table', 'Referenced Object']\n    dict_to_markdown_table(dependancies, columns)\n</code></pre> Returns: <pre><code>    | Referenced Object Type | Referenced Table | Referenced Object               |\n    | ---------------------- | ---------------- | ------------------------------- |\n    | TABLE                  | Cases            | Cases                           |\n    | COLUMN                 | Cases            | IsClosed                        |\n    | CALC_COLUMN            | Cases            | Resolution Time (Working Hours) |\n</code></pre></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def dict_to_markdown_table(list_of_dicts: list, columns_to_include: list = None) -&gt; str:\n    \"\"\"Generate a Markdown table based on a list of dictionaries.\n\n    Args:\n        list_of_dicts (list): List of Dictionaries that need to be converted\n            to a markdown table.\n        columns_to_include (list): Default = None, and all colums are included.\n            If a list is supplied, those columns will be included.\n\n    Returns:\n        String that will represent a table in Markdown.\n\n    Example:\n        ```python\n            columns = ['Referenced Object Type', 'Referenced Table', 'Referenced Object']\n            dict_to_markdown_table(dependancies, columns)\n        ```\n        Returns:\n        ```\n            | Referenced Object Type | Referenced Table | Referenced Object               |\n            | ---------------------- | ---------------- | ------------------------------- |\n            | TABLE                  | Cases            | Cases                           |\n            | COLUMN                 | Cases            | IsClosed                        |\n            | CALC_COLUMN            | Cases            | Resolution Time (Working Hours) |\n        ```\n    \"\"\"\n    keys = set().union(*[set(d.keys()) for d in list_of_dicts])\n\n    if columns_to_include is not None:\n        keys = list(keys.intersection(columns_to_include))\n\n    table_header = f\"| {' | '.join(map(str, keys))} |\"\n    table_header_separator = \"|-----\" * len(keys) + \"|\"\n    markdown_table = [table_header, table_header_separator]\n\n    for row in list_of_dicts:\n        table_row = f\"| {' | '.join(str(row.get(key, '')) for key in keys)} |\"\n        markdown_table.append(table_row)\n    return \"\\n\".join(markdown_table)\n</code></pre>"},{"location":"pbi_helper/","title":"pbi_helper","text":"<p><code>pbi_helper.py</code> was reverse engineered from DaxStudio <code>PowerBiHelper.cs</code>.</p> <p>So all credit and genius should go to DaxStudio. I just wanted it in python... The main function is <code>find_local_pbi_instances()</code>. It will find any open PBIX files on your computer and spit out a connection string for you.</p>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_msmdsrv","title":"<code>get_msmdsrv()</code>","text":"<p>Runs powershel command to retrieve the ProcessId.</p> <p>Uses <code>Get-CimInstance</code> where <code>Name == 'msmdsrv.exe'</code>.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>returns ProcessId(s) in list. Formatted to account for multiple PBIX files open at the same time.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_msmdsrv() -&gt; list:\n    \"\"\"Runs powershel command to retrieve the ProcessId.\n\n    Uses `Get-CimInstance` where `Name == 'msmdsrv.exe'`.\n\n    Returns:\n        list: returns ProcessId(s) in list.\n            Formatted to account for multiple PBIX files open at the same time.\n    \"\"\"\n    p.logger.debug(\"Retrieving msmdsrv.exe(s)\")\n\n    try:\n        msmdsrv = subprocess.check_output(\n            [\n                \"powershell\",\n                \"\"\"Get-CimInstance -ClassName Win32_Process \\\n                    -Property * -Filter \"Name = 'msmdsrv.exe'\" | \\\n                    Select-Object -Property ProcessId -ExpandProperty ProcessId\"\"\",\n            ]\n        )\n\n        msmdsrv_id = msmdsrv.decode().strip().splitlines()\n        p.logger.debug(f\"ProcessId for msmdsrv.exe {msmdsrv_id}\")\n        return msmdsrv_id\n\n    except subprocess.CalledProcessError as e:\n        p.logger.error(\n            f\"command '{e.cmd}' return with error (code {e.returncode}): {e.output}\"\n        )\n        p.logger.warn(\n            \"Check if powershell is availabe in the PATH environment variables.\"\n        )\n        raise RuntimeError(\n            f\"command '{e.cmd}' return with error (code {e.returncode}): {e.output}\"\n        ) from e\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_port_number","title":"<code>get_port_number(msmdsrv)</code>","text":"<p>Gets the local port number of given msmdsrv ProcessId. Via PowerShell.</p> <p>Parameters:</p> Name Type Description Default <code>msmdsrv</code> <code>str</code> <p>A ProcessId returned from <code>get_msmdsrv()</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p><code>LocalPort</code> returned for specific ProcessId.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_port_number(msmdsrv: str) -&gt; str:\n    \"\"\"Gets the local port number of given msmdsrv ProcessId. Via PowerShell.\n\n    Args:\n        msmdsrv (str): A ProcessId returned from `get_msmdsrv()`.\n\n    Returns:\n        str: `LocalPort` returned for specific ProcessId.\n    \"\"\"\n    port = subprocess.check_output(\n        [\n            \"powershell\",\n            f\"Get-NetTCPConnection -State Listen \\\n                -OwningProcess {msmdsrv} | Select-Object \\\n                -Property LocalPort -First 1 -ExpandProperty LocalPort\",\n        ]\n    )\n    port_number = port.decode().strip()\n    p.logger.debug(f\"Listening port - {port_number} for msmdsrv.exe - {msmdsrv}\")\n    return port_number\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_parent_id","title":"<code>get_parent_id(msmdsrv)</code>","text":"<p>Gets ParentProcessId via PowerShell from the msmdsrv ProcessId.</p> <p>Parameters:</p> Name Type Description Default <code>msmdsrv</code> <code>str</code> <p>A ProcessId returned from <code>get_msmdsrv()</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Returns ParentProcessId in <code>str</code> format.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_parent_id(msmdsrv: str) -&gt; str:\n    \"\"\"Gets ParentProcessId via PowerShell from the msmdsrv ProcessId.\n\n    Args:\n        msmdsrv (str):  A ProcessId returned from `get_msmdsrv()`.\n\n    Returns:\n        str: Returns ParentProcessId in `str` format.\n    \"\"\"\n    parent = subprocess.check_output(\n        [\n            \"powershell\",\n            f'Get-CimInstance -ClassName Win32_Process -Property * \\\n                -Filter \"ProcessId = {msmdsrv}\" | \\\n                Select-Object -Property ParentProcessId -ExpandProperty ParentProcessId',\n        ]\n    )\n    parent_id = parent.decode().strip()\n    p.logger.debug(f\"ProcessId - {parent_id} for parent of msmdsrv.exe - {msmdsrv}\")\n    return parent_id\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_parent_title","title":"<code>get_parent_title(parent_id)</code>","text":"<p>Takes the ParentProcessId and gets the name of the PBIX file.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>Takes ParentProcessId which can be retrieved from <code>get_parent_id(msmdsrv)</code></p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Returns str of title of PBIX file.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_parent_title(parent_id: str) -&gt; str:\n    \"\"\"Takes the ParentProcessId and gets the name of the PBIX file.\n\n    Args:\n        parent_id (str): Takes ParentProcessId which can be retrieved from `get_parent_id(msmdsrv)`\n\n    Returns:\n        str: Returns str of title of PBIX file.\n    \"\"\"\n    pbi_title_suffixes: list = [\n        \" \\u002D Power BI Desktop\",  # Dash Punctuation - minus hyphen\n        \" \\u2212 Power BI Desktop\",  # Math Symbol - minus sign\n        \" \\u2011 Power BI Desktop\",  # Dash Punctuation - non-breaking hyphen\n        \" \\u2013 Power BI Desktop\",  # Dash Punctuation - en dash\n        \" \\u2014 Power BI Desktop\",  # Dash Punctuation - em dash\n        \" \\u2015 Power BI Desktop\",  # Dash Punctuation - horizontal bar\n    ]\n    title = subprocess.check_output(\n        [\"powershell\", f\"\"\"(Get-Process -Id {parent_id}).MainWindowTitle\"\"\"]\n    )\n    title_name = title.decode().strip()\n    for suffix in pbi_title_suffixes:\n        title_name = title_name.replace(suffix, \"\")\n    p.logger.debug(f\"Title - {title_name} for {parent_id}\")\n    return title_name\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.create_connection_str","title":"<code>create_connection_str(port_number)</code>","text":"<p>This takes the port number and adds to connection string.</p> <p>This is pretty bland right now, may improve later.</p> <p>Parameters:</p> Name Type Description Default <code>port_number</code> <code>str</code> <p>port number retrieved from <code>get_port_number(msmdsrv)</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>port number as string.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def create_connection_str(port_number: str) -&gt; str:\n    \"\"\"This takes the port number and adds to connection string.\n\n    This is pretty bland right now, may improve later.\n\n    Args:\n        port_number (str): port number retrieved from `get_port_number(msmdsrv)`.\n\n    Returns:\n        str: port number as string.\n    \"\"\"\n    connection_str = f\"Data Source=localhost:{port_number}\"\n    p.logger.debug(f\"Local Connection Str - {connection_str}\")\n    return connection_str\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.find_local_pbi_instances","title":"<code>find_local_pbi_instances()</code>","text":"<p>The real genius is from Dax Studio.</p> <p>I just wanted it in python not C#, so reverse engineered what DaxStudio did. It will run some powershell scripts to pull the appropriate info. Then will spit out a list with tuples inside. You can use the connection string to connect to your model with pytabular. Dax Studio.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>EX <code>[('PBI File Name1','localhost:{port}'),('PBI File Name2','localhost:{port}')]</code></p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def find_local_pbi_instances() -&gt; list:\n    \"\"\"The real genius is from Dax Studio.\n\n    I just wanted it in python not C#, so reverse engineered what DaxStudio did.\n    It will run some powershell scripts to pull the appropriate info.\n    Then will spit out a list with tuples inside.\n    You can use the connection string to connect to your model with pytabular.\n    [Dax Studio](https://github.com/DaxStudio/DaxStudio/blob/master/src/DaxStudio.UI/Utils/PowerBIHelper.cs).\n\n    Returns:\n        list: EX `[('PBI File Name1','localhost:{port}'),('PBI File Name2','localhost:{port}')]`\n    \"\"\"  # noqa: E501\n    instances = get_msmdsrv()\n    pbi_instances = []\n    for instance in instances:\n        p.logger.debug(f\"Building connection for {instance}\")\n        port = get_port_number(instance)\n        parent = get_parent_id(instance)\n        title = get_parent_title(parent)\n        connect_str = create_connection_str(port)\n        pbi_instances += [(title, connect_str)]\n    return pbi_instances\n</code></pre>"},{"location":"query/","title":"Query Model","text":"<p><code>query.py</code> houses a custom <code>Connection</code> class that uses the .Net AdomdConnection.</p> <p><code>Connection</code> is created automatically when connecting to your model.</p> Example query from model<pre><code>import pytabular as p\nmodel = p.Tabular(CONNECTION_STR)\nmodel.query(\"EVALUATE {1}\")\n</code></pre> pass an effective user<pre><code>model.query(\n    \"EVALUATE {1}\",\n    effective_user = \"user@company.com\"\n)\n</code></pre>"},{"location":"query/#pytabular.query.Connection","title":"<code>Connection</code>","text":"<p>             Bases: <code>AdomdConnection</code></p> <p>Connection class creates an AdomdConnection.</p> <p>Mainly used for the <code>query()</code> method. The <code>query()</code> method in the Tabular class is just a wrapper for this class. But you can pass through your <code>effective_user</code> more efficiently, so use that instead.</p> Source code in <code>pytabular/query.py</code> <pre><code>class Connection(AdomdConnection):\n    \"\"\"Connection class creates an AdomdConnection.\n\n    Mainly used for the `query()` method. The `query()`\n    method in the Tabular class is just a wrapper for this class.\n    But you can pass through your `effective_user` more efficiently,\n    so use that instead.\n    \"\"\"\n\n    def __init__(self, server, effective_user=None) -&gt; None:\n        \"\"\"Init creates the connection.\n\n        Args:\n            server (Server): The server that you are connecting to.\n            effective_user (str, optional): Pass through an effective user\n                to query as somebody else. Defaults to None.\n        \"\"\"\n        super().__init__()\n        if server.ConnectionInfo.Password is None:\n            connection_string = server.ConnectionString\n        else:\n            connection_string = (\n                f\"{server.ConnectionString}Password='{server.ConnectionInfo.Password}'\"\n            )\n        logger.debug(f\"{connection_string}\")\n        if effective_user is not None:\n            connection_string += f\";EffectiveUserName={effective_user}\"\n        self.ConnectionString = connection_string\n\n    def query(self, query_str: str) -&gt; Union[pd.DataFrame, str, int]:\n        \"\"\"Executes query on Model and returns results in Pandas DataFrame.\n\n        Iterates through results of `AdomdCommmand().ExecuteReader()`\n        in the .Net library. If result is a single value, it will\n        return that single value instead of DataFrame.\n\n        Args:\n            query_str (str): Dax Query. Note, needs full syntax\n                (ex: `EVALUATE`). See [DAX](https://docs.microsoft.com/en-us/dax/dax-queries).\n                Will check if query string is a file.\n                If it is, then it will perform a query\n                on whatever is read from the file.\n                It is also possible to query DMV.\n                For example.\n                `query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")`.\n\n        Returns:\n            pd.DataFrame: Returns dataframe with results.\n        \"\"\"\n        try:\n            is_file = os.path.isfile(query_str)\n        except Exception:\n            is_file = False\n\n        if is_file:\n            logger.debug(\n                f\"File path detected, reading file... -&gt; {query_str}\",\n            )\n            with open(query_str, \"r\") as file:\n                query_str = str(file.read())\n\n        if str(self.get_State()) != \"Open\":\n            # Works for now, need to update to handle different types of conneciton properties\n            # https://learn.microsoft.com/en-us/dotnet/api/system.data.connectionstate?view=net-7.0\n            logger.info(\"Checking initial Adomd Connection...\")\n            self.Open()\n            logger.info(f\"Connected! Session ID - {self.SessionID}\")\n\n        logger.debug(\"Querying Model...\")\n        logger.debug(query_str)\n        query = AdomdCommand(query_str, self).ExecuteReader()\n        column_headers = [\n            (index, query.GetName(index)) for index in range(0, query.FieldCount)\n        ]\n        results = list()\n        while query.Read():\n            results.append(\n                [\n                    get_value_to_df(query, index)\n                    for index in range(0, len(column_headers))\n                ]\n            )\n\n        query.Close()\n        logger.debug(\"Data retrieved... reading...\")\n        df = pd.DataFrame(results, columns=[value for _, value in column_headers])\n        if len(df) == 1 and len(df.columns) == 1:\n            return df.iloc[0][df.columns[0]]\n        return df\n</code></pre>"},{"location":"query/#pytabular.query.Connection.__init__","title":"<code>__init__(server, effective_user=None)</code>","text":"<p>Init creates the connection.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>Server</code> <p>The server that you are connecting to.</p> required <code>effective_user</code> <code>str</code> <p>Pass through an effective user to query as somebody else. Defaults to None.</p> <code>None</code> Source code in <code>pytabular/query.py</code> <pre><code>def __init__(self, server, effective_user=None) -&gt; None:\n    \"\"\"Init creates the connection.\n\n    Args:\n        server (Server): The server that you are connecting to.\n        effective_user (str, optional): Pass through an effective user\n            to query as somebody else. Defaults to None.\n    \"\"\"\n    super().__init__()\n    if server.ConnectionInfo.Password is None:\n        connection_string = server.ConnectionString\n    else:\n        connection_string = (\n            f\"{server.ConnectionString}Password='{server.ConnectionInfo.Password}'\"\n        )\n    logger.debug(f\"{connection_string}\")\n    if effective_user is not None:\n        connection_string += f\";EffectiveUserName={effective_user}\"\n    self.ConnectionString = connection_string\n</code></pre>"},{"location":"query/#pytabular.query.Connection.query","title":"<code>query(query_str)</code>","text":"<p>Executes query on Model and returns results in Pandas DataFrame.</p> <p>Iterates through results of <code>AdomdCommmand().ExecuteReader()</code> in the .Net library. If result is a single value, it will return that single value instead of DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>Dax Query. Note, needs full syntax (ex: <code>EVALUATE</code>). See DAX. Will check if query string is a file. If it is, then it will perform a query on whatever is read from the file. It is also possible to query DMV. For example. <code>query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")</code>.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, str, int]</code> <p>pd.DataFrame: Returns dataframe with results.</p> Source code in <code>pytabular/query.py</code> <pre><code>def query(self, query_str: str) -&gt; Union[pd.DataFrame, str, int]:\n    \"\"\"Executes query on Model and returns results in Pandas DataFrame.\n\n    Iterates through results of `AdomdCommmand().ExecuteReader()`\n    in the .Net library. If result is a single value, it will\n    return that single value instead of DataFrame.\n\n    Args:\n        query_str (str): Dax Query. Note, needs full syntax\n            (ex: `EVALUATE`). See [DAX](https://docs.microsoft.com/en-us/dax/dax-queries).\n            Will check if query string is a file.\n            If it is, then it will perform a query\n            on whatever is read from the file.\n            It is also possible to query DMV.\n            For example.\n            `query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")`.\n\n    Returns:\n        pd.DataFrame: Returns dataframe with results.\n    \"\"\"\n    try:\n        is_file = os.path.isfile(query_str)\n    except Exception:\n        is_file = False\n\n    if is_file:\n        logger.debug(\n            f\"File path detected, reading file... -&gt; {query_str}\",\n        )\n        with open(query_str, \"r\") as file:\n            query_str = str(file.read())\n\n    if str(self.get_State()) != \"Open\":\n        # Works for now, need to update to handle different types of conneciton properties\n        # https://learn.microsoft.com/en-us/dotnet/api/system.data.connectionstate?view=net-7.0\n        logger.info(\"Checking initial Adomd Connection...\")\n        self.Open()\n        logger.info(f\"Connected! Session ID - {self.SessionID}\")\n\n    logger.debug(\"Querying Model...\")\n    logger.debug(query_str)\n    query = AdomdCommand(query_str, self).ExecuteReader()\n    column_headers = [\n        (index, query.GetName(index)) for index in range(0, query.FieldCount)\n    ]\n    results = list()\n    while query.Read():\n        results.append(\n            [\n                get_value_to_df(query, index)\n                for index in range(0, len(column_headers))\n            ]\n        )\n\n    query.Close()\n    logger.debug(\"Data retrieved... reading...\")\n    df = pd.DataFrame(results, columns=[value for _, value in column_headers])\n    if len(df) == 1 and len(df.columns) == 1:\n        return df.iloc[0][df.columns[0]]\n    return df\n</code></pre>"},{"location":"refresh/","title":"Refresh Model","text":"<p><code>refresh.py</code> is the main file to handle all the components of refreshing your model.</p> <p>You have may ways to interact with refreshing.</p> Example refresh from model<pre><code>import pytabular as p\nmodel = p.Tabular(CONNECTION_STR)\nmodel.refresh('Table Name')\n</code></pre> refresh from PyTables<pre><code>model.Tables.find(\"fact\").refresh() # (1)\n</code></pre> <ol> <li>Refresh all tables with 'fact' in the name.</li> </ol> refresh from PyTable<pre><code>model.Tables['Sales'].refresh()\n</code></pre> refresh from PyPartitions<pre><code>model.Tables['Large Sales Fact'].Partitions.refresh()\n</code></pre> refresh from PyPartition<pre><code>model.Tables['Sales'].Partitions['Last Fiscal Year'].refresh()\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck","title":"<code>RefreshCheck</code>","text":"<p>             Bases: <code>ABC</code></p> <p><code>RefreshCheck</code> is an test you run after your refreshes.</p> <p>It will run the given <code>function</code> before and after refreshes, then run the assertion of before and after. The default given in a refresh is to check row count. It will check row count before, and row count after. Then fail if row count after is zero.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class RefreshCheck(ABC):\n    \"\"\"`RefreshCheck` is an test you run after your refreshes.\n\n    It will run the given `function` before and after refreshes,\n    then run the assertion of before and after.\n    The default given in a refresh is to check row count.\n    It will check row count before, and row count after.\n    Then fail if row count after is zero.\n    \"\"\"\n\n    def __init__(self, name: str, function, assertion=None) -&gt; None:\n        \"\"\"Sets the necessary components to perform a refresh check.\n\n        Args:\n            name (str): Name of refresh check.\n            function (Callable): Function to run on pre and post checks.\n                    For example, a dax query. readme has examples of this.\n            assertion (Callable, optional): A function that can be run.\n                    Supply the assertion function with 2 arguments. The first one\n                    for your 'pre' results from the `function` argument. The second\n                    for your `post` results from the`function` argument.\n                    Return `True` or `False` depending on the comparison of the two arguments\n                    to determine a pass or fail status of your refresh.\n                    Defaults to None.\n        \"\"\"\n        super().__init__()\n        self._name = name\n        self._function = function\n        self._assertion = assertion\n        self._pre = None\n        self._post = None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"`__repre__` that returns details on `RefreshCheck`.\"\"\"\n        return f\"{self.name} - {self.pre} - {self.post} - {str(self.function)}\"\n\n    @property\n    def name(self):\n        \"\"\"Get your custom name of refresh check.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        self._name = name\n\n    @name.deleter\n    def name(self):\n        del self._name\n\n    @property\n    def function(self):\n        \"\"\"Get the function that is used to run a pre and post check.\"\"\"\n        return self._function\n\n    @function.setter\n    def function(self, func):\n        self._function = func\n\n    @function.deleter\n    def function(self):\n        del self._function\n\n    @property\n    def pre(self):\n        \"\"\"Get the pre value that is the result from the pre refresh check.\"\"\"\n        return self._pre\n\n    @pre.setter\n    def pre(self, pre):\n        self._pre = pre\n\n    @pre.deleter\n    def pre(self):\n        del self._pre\n\n    @property\n    def post(self):\n        \"\"\"Get the post value that is the result from the post refresh check.\"\"\"\n        return self._post\n\n    @post.setter\n    def post(self, post):\n        self._post = post\n\n    @post.deleter\n    def post(self):\n        del self._post\n\n    @property\n    def assertion(self):\n        \"\"\"Get the assertion that is the result from the post refresh check.\"\"\"\n        return self._assertion\n\n    @assertion.setter\n    def assertion(self, assertion):\n        self._assertion = assertion\n\n    @assertion.deleter\n    def assertion(self):\n        del self._assertion\n\n    def _check(self, stage: str):\n        \"\"\"Runs the given function and stores results.\n\n        Stored in either `self.pre` or `self.post` depending on `stage`.\n\n        Args:\n            stage (str): Either 'Pre' or 'Post'\n\n        Returns:\n            object: Returns the results of the pre or post check.\n        \"\"\"\n        logger.debug(f\"Running {stage}-Check for {self.name}\")\n        results = self.function()\n        if stage == \"Pre\":\n            self.pre = results\n        else:\n            self.post = results\n        logger.info(f\"{stage}-Check results for {self.name} - {results}\")\n        return results\n\n    def pre_check(self):\n        \"\"\"Runs `self._check(\"Pre\")`.\"\"\"\n        self._check(\"Pre\")\n        pass\n\n    def post_check(self):\n        \"\"\"Runs `self._check(\"Post\")` then `self.assertion_run()`.\"\"\"\n        self._check(\"Post\")\n        self.assertion_run()\n        pass\n\n    def assertion_run(self):\n        \"\"\"Runs the given self.assertion function with `self.pre` and `self.post`.\n\n        So, `self.assertion_run(self.pre, self.post)`.\n        \"\"\"\n        if self.assertion is None:\n            logger.debug(\"Skipping assertion none given\")\n        else:\n            test = self.assertion(self.pre, self.post)\n            assert_str = f\"Test {self.name} - {test} - Pre Results - {self.pre} | Post Results {self.post}\"  # noqa: E501\n            if test:\n                logger.info(assert_str)\n            else:\n                logger.critical(assert_str)\n            assert (\n                test\n            ), f\"Test failed! Pre Results - {self.pre} | Post Results {self.post}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.name","title":"<code>name</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get your custom name of refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.function","title":"<code>function</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the function that is used to run a pre and post check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.pre","title":"<code>pre</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the pre value that is the result from the pre refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.post","title":"<code>post</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the post value that is the result from the post refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.assertion","title":"<code>assertion</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the assertion that is the result from the post refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.__init__","title":"<code>__init__(name, function, assertion=None)</code>","text":"<p>Sets the necessary components to perform a refresh check.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of refresh check.</p> required <code>function</code> <code>Callable</code> <p>Function to run on pre and post checks.     For example, a dax query. readme has examples of this.</p> required <code>assertion</code> <code>Callable</code> <p>A function that can be run.     Supply the assertion function with 2 arguments. The first one     for your 'pre' results from the <code>function</code> argument. The second     for your <code>post</code> results from the<code>function</code> argument.     Return <code>True</code> or <code>False</code> depending on the comparison of the two arguments     to determine a pass or fail status of your refresh.     Defaults to None.</p> <code>None</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(self, name: str, function, assertion=None) -&gt; None:\n    \"\"\"Sets the necessary components to perform a refresh check.\n\n    Args:\n        name (str): Name of refresh check.\n        function (Callable): Function to run on pre and post checks.\n                For example, a dax query. readme has examples of this.\n        assertion (Callable, optional): A function that can be run.\n                Supply the assertion function with 2 arguments. The first one\n                for your 'pre' results from the `function` argument. The second\n                for your `post` results from the`function` argument.\n                Return `True` or `False` depending on the comparison of the two arguments\n                to determine a pass or fail status of your refresh.\n                Defaults to None.\n    \"\"\"\n    super().__init__()\n    self._name = name\n    self._function = function\n    self._assertion = assertion\n    self._pre = None\n    self._post = None\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.__repr__","title":"<code>__repr__()</code>","text":"<p><code>__repre__</code> that returns details on <code>RefreshCheck</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"`__repre__` that returns details on `RefreshCheck`.\"\"\"\n    return f\"{self.name} - {self.pre} - {self.post} - {str(self.function)}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.pre_check","title":"<code>pre_check()</code>","text":"<p>Runs <code>self._check(\"Pre\")</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def pre_check(self):\n    \"\"\"Runs `self._check(\"Pre\")`.\"\"\"\n    self._check(\"Pre\")\n    pass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.post_check","title":"<code>post_check()</code>","text":"<p>Runs <code>self._check(\"Post\")</code> then <code>self.assertion_run()</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def post_check(self):\n    \"\"\"Runs `self._check(\"Post\")` then `self.assertion_run()`.\"\"\"\n    self._check(\"Post\")\n    self.assertion_run()\n    pass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.assertion_run","title":"<code>assertion_run()</code>","text":"<p>Runs the given self.assertion function with <code>self.pre</code> and <code>self.post</code>.</p> <p>So, <code>self.assertion_run(self.pre, self.post)</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def assertion_run(self):\n    \"\"\"Runs the given self.assertion function with `self.pre` and `self.post`.\n\n    So, `self.assertion_run(self.pre, self.post)`.\n    \"\"\"\n    if self.assertion is None:\n        logger.debug(\"Skipping assertion none given\")\n    else:\n        test = self.assertion(self.pre, self.post)\n        assert_str = f\"Test {self.name} - {test} - Pre Results - {self.pre} | Post Results {self.post}\"  # noqa: E501\n        if test:\n            logger.info(assert_str)\n        else:\n            logger.critical(assert_str)\n        assert (\n            test\n        ), f\"Test failed! Pre Results - {self.pre} | Post Results {self.post}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection","title":"<code>RefreshCheckCollection</code>","text":"<p>Groups together your <code>RefreshChecks</code>.</p> <p>Used to handle multiple types of checks in a single refresh.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class RefreshCheckCollection:\n    \"\"\"Groups together your `RefreshChecks`.\n\n    Used to handle multiple types of checks in a single refresh.\n    \"\"\"\n\n    def __init__(self, refresh_checks: RefreshCheck = []) -&gt; None:\n        \"\"\"Init to supply RefreshChecks.\n\n        Args:\n            refresh_checks (RefreshCheck, optional): Defaults to [].\n        \"\"\"\n        self._refreshchecks = refresh_checks\n        pass\n\n    def __iter__(self):\n        \"\"\"Basic iteration through the different `RefreshCheck`(s).\"\"\"\n        for refresh_check in self._refreshchecks:\n            yield refresh_check\n\n    def add_refresh_check(self, refresh_check: RefreshCheck):\n        \"\"\"Add a RefreshCheck.\n\n        Supply the `RefreshCheck` to add.\n\n        Args:\n            refresh_check (RefreshCheck): `RefreshCheck` class.\n        \"\"\"\n        self._refreshchecks.append(refresh_check)\n\n    def remove_refresh_check(self, refresh_check: RefreshCheck):\n        \"\"\"Remove a RefreshCheck.\n\n        Supply the `RefreshCheck` to remove.\n\n        Args:\n            refresh_check (RefreshCheck): `RefreshCheck` class.\n        \"\"\"\n        self._refreshchecks.remove(refresh_check)\n\n    def clear_refresh_checks(self):\n        \"\"\"Clear Refresh Checks.\"\"\"\n        self._refreshchecks.clear()\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.__init__","title":"<code>__init__(refresh_checks=[])</code>","text":"<p>Init to supply RefreshChecks.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_checks</code> <code>RefreshCheck</code> <p>Defaults to [].</p> <code>[]</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(self, refresh_checks: RefreshCheck = []) -&gt; None:\n    \"\"\"Init to supply RefreshChecks.\n\n    Args:\n        refresh_checks (RefreshCheck, optional): Defaults to [].\n    \"\"\"\n    self._refreshchecks = refresh_checks\n    pass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.__iter__","title":"<code>__iter__()</code>","text":"<p>Basic iteration through the different <code>RefreshCheck</code>(s).</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def __iter__(self):\n    \"\"\"Basic iteration through the different `RefreshCheck`(s).\"\"\"\n    for refresh_check in self._refreshchecks:\n        yield refresh_check\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.add_refresh_check","title":"<code>add_refresh_check(refresh_check)</code>","text":"<p>Add a RefreshCheck.</p> <p>Supply the <code>RefreshCheck</code> to add.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_check</code> <code>RefreshCheck</code> <p><code>RefreshCheck</code> class.</p> required Source code in <code>pytabular/refresh.py</code> <pre><code>def add_refresh_check(self, refresh_check: RefreshCheck):\n    \"\"\"Add a RefreshCheck.\n\n    Supply the `RefreshCheck` to add.\n\n    Args:\n        refresh_check (RefreshCheck): `RefreshCheck` class.\n    \"\"\"\n    self._refreshchecks.append(refresh_check)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.remove_refresh_check","title":"<code>remove_refresh_check(refresh_check)</code>","text":"<p>Remove a RefreshCheck.</p> <p>Supply the <code>RefreshCheck</code> to remove.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_check</code> <code>RefreshCheck</code> <p><code>RefreshCheck</code> class.</p> required Source code in <code>pytabular/refresh.py</code> <pre><code>def remove_refresh_check(self, refresh_check: RefreshCheck):\n    \"\"\"Remove a RefreshCheck.\n\n    Supply the `RefreshCheck` to remove.\n\n    Args:\n        refresh_check (RefreshCheck): `RefreshCheck` class.\n    \"\"\"\n    self._refreshchecks.remove(refresh_check)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.clear_refresh_checks","title":"<code>clear_refresh_checks()</code>","text":"<p>Clear Refresh Checks.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def clear_refresh_checks(self):\n    \"\"\"Clear Refresh Checks.\"\"\"\n    self._refreshchecks.clear()\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh","title":"<code>PyRefresh</code>","text":"<p>PyRefresh Class to handle refreshes of model.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class PyRefresh:\n    \"\"\"PyRefresh Class to handle refreshes of model.\"\"\"\n\n    def __init__(\n        self,\n        model,\n        object: Union[str, PyTable, PyPartition, Dict[str, Any]],\n        trace: BaseTrace = RefreshTrace,\n        refresh_checks: RefreshCheckCollection = RefreshCheckCollection(),\n        default_row_count_check: bool = True,\n        refresh_type: RefreshType = RefreshType.Full,\n    ) -&gt; None:\n        \"\"\"Init when a refresh is requested.\n\n        Runs through requested tables and partitions\n        to make sure they are in model.\n        Then will run pre checks on the requested objects.\n\n        Args:\n            model (Tabular): Tabular model.\n            object (Union[str, PyTable, PyPartition, Dict[str, Any]]): The objects\n                that you are wanting to refresh. Can be a `PyTable`, `PyPartition`,\n                `TABLE_NAME` string, or a dict with `{TABLE_REFERENCE:PARTITION_REFERENCE}`\n            trace (BaseTrace, optional): Defaults to RefreshTrace.\n            refresh_checks (RefreshCheckCollection, optional): Defaults to RefreshCheckCollection().\n            default_row_count_check (bool, optional): Defaults to True.\n            refresh_type (RefreshType, optional): Defaults to RefreshType.Full.\n        \"\"\"\n        self.model = model\n        self.object = object\n        self.trace = trace\n        self.default_row_count_check = default_row_count_check\n        self.refresh_type = refresh_type\n        self._objects_to_refresh = []\n        self._request_refresh(self.object)\n        self._checks = refresh_checks\n        self._pre_checks()\n        logger.info(\"Refresh Request Completed!\")\n        pass\n\n    def _pre_checks(self):\n        \"\"\"Checks if any `BaseTrace` classes are needed from `tabular_tracing.py`.\n\n        Then checks if any `RefreshChecks` are needed, along with the default `row_count` check.\n        \"\"\"\n        logger.debug(\"Running Pre-checks\")\n        if self.trace is not None:\n            logger.debug(\"Getting Trace\")\n            self.trace = self._get_trace()\n        if self.default_row_count_check:\n            logger.debug(\n                f\"Running default row count check - {self.default_row_count_check}\"\n            )\n            tables = [\n                table\n                for refresh_dict in self._objects_to_refresh\n                for table in refresh_dict.keys()\n            ]\n\n            def row_count_assertion(pre, post):\n                \"\"\"Checks if table refreshed zero rows.\"\"\"\n                post = 0 if post is None else post\n                return post &gt; 0\n\n            for table in set(tables):\n                check = RefreshCheck(\n                    f\"{table.Name} Row Count\", table.row_count, row_count_assertion\n                )\n                self._checks.add_refresh_check(check)\n        for check in self._checks:\n            check.pre_check()\n        pass\n\n    def _post_checks(self):\n        \"\"\"If traces are running it Stops and Drops it.\n\n        Runs through any `post_checks()` in `RefreshChecks`.\n        \"\"\"\n        if self.trace is not None:\n            self.trace.stop()\n            self.trace.drop()\n        for check in self._checks:\n            check.post_check()\n            # self._checks.remove_refresh_check(check)\n        self._checks.clear_refresh_checks()\n        pass\n\n    def _get_trace(self) -&gt; BaseTrace:\n        \"\"\"Creates Trace and creates it in model.\"\"\"\n        return self.trace(self.model)\n\n    def _find_table(self, table_str: str) -&gt; Table:\n        \"\"\"Finds table in `PyTables` class.\"\"\"\n        try:\n            result = self.model.Tables[table_str]\n        except Exception:\n            raise Exception(f\"Unable to find table! from {table_str}\")\n        logger.debug(f\"Found table {result.Name}\")\n        return result\n\n    def _find_partition(self, table: Table, partition_str: str) -&gt; Partition:\n        \"\"\"Finds partition in `PyPartitions` class.\"\"\"\n        try:\n            result = table.Partitions[partition_str]\n        except Exception:\n            raise Exception(f\"Unable to find partition! {table.Name}|{partition_str}\")\n        logger.debug(f\"Found partition {result.Table.Name}|{result.Name}\")\n        return result\n\n    def _refresh_table(self, table: PyTable) -&gt; None:\n        \"\"\"Runs .Net `RequestRefresh()` on table.\"\"\"\n        logging.info(f\"Requesting refresh for {table.Name}\")\n        self._objects_to_refresh += [\n            {table: [partition for partition in table.Partitions]}\n        ]\n        table.RequestRefresh(self.refresh_type)\n\n    def _refresh_partition(self, partition: PyPartition) -&gt; None:\n        \"\"\"Runs .Net `RequestRefresh()` on partition.\"\"\"\n        logging.info(f\"Requesting refresh for {partition.Table.Name}|{partition.Name}\")\n        self._objects_to_refresh += [{partition.Table: [partition]}]\n        partition.RequestRefresh(self.refresh_type)\n\n    def _refresh_dict(self, partition_dict: Dict) -&gt; None:\n        \"\"\"Handles refreshes if argument given was a dictionary.\"\"\"\n        for table in partition_dict.keys():\n            table_object = self._find_table(table) if isinstance(table, str) else table\n\n            def handle_partitions(object):\n                \"\"\"Figures out if partition argument given is a str or an actual `PyPartition`.\n\n                Then will run `self._refresh_partition()` appropriately.\n                \"\"\"\n                if isinstance(object, str):\n                    self._refresh_partition(self._find_partition(table_object, object))\n                elif isinstance(object, PyPartition):\n                    self._refresh_partition(object)\n                else:\n                    [handle_partitions(obj) for obj in object]\n\n            handle_partitions(partition_dict[table])\n\n    def _request_refresh(self, object):\n        \"\"\"Base method to parse through argument and figure out what needs to be refreshed.\n\n        Someone please make this better...\n        \"\"\"\n        logger.debug(f\"Requesting Refresh for {object}\")\n        if isinstance(object, str):\n            self._refresh_table(self._find_table(object))\n        elif isinstance(object, PyTables):\n            [self._refresh_table(table) for table in object]\n        elif isinstance(object, Dict):\n            self._refresh_dict(object)\n        elif isinstance(object, PyTable):\n            self._refresh_table(object)\n        elif isinstance(object, PyPartition):\n            self._refresh_partition(object)\n        else:\n            [self._request_refresh(obj) for obj in object]\n\n    def _refresh_report(self, property_changes) -&gt; pd.DataFrame:\n        \"\"\"Builds a DataFrame that displays details on the refresh.\n\n        Args:\n            Property_Changes: Which is returned from `model.save_changes()`\n\n        Returns:\n            pd.DataFrame: DataFrame of refresh details.\n        \"\"\"\n        logger.debug(\"Running Refresh Report...\")\n        refresh_data = []\n        for property_change in property_changes:\n            if (\n                isinstance(property_change.object, Partition)\n                and property_change.property_name == \"RefreshedTime\"\n            ):\n                table, partition, refreshed_time = (\n                    property_change.object.Table.Name,\n                    property_change.object.Name,\n                    ticks_to_datetime(property_change.new_value.Ticks),\n                )\n                logger.info(\n                    f'{table} - {partition} Refreshed! - {refreshed_time.strftime(\"%m/%d/%Y, %H:%M:%S\")}'  # noqa: E501\n                )\n                refresh_data += [[table, partition, refreshed_time]]\n        return pd.DataFrame(\n            refresh_data, columns=[\"Table\", \"Partition\", \"Refreshed Time\"]\n        )\n\n    def run(self) -&gt; pd.DataFrame:\n        \"\"\"When ready, execute to start the refresh process.\n\n        First checks if connected and reconnects if needed.\n        Then starts the trace if needed.\n        Next will execute `save_changes()`\n        and run the post checks after that.\n        Last will return a `pd.DataFrame` of refresh results.\n        \"\"\"\n        if self.model.Server.Connected is False:\n            logger.info(f\"{self.Server.Name} - Reconnecting...\")\n            self.model.reconnect()\n\n        if self.trace is not None:\n            self.trace.start()\n\n        save_changes = self.model.save_changes()\n\n        self._post_checks()\n\n        return self._refresh_report(save_changes.property_changes)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh.__init__","title":"<code>__init__(model, object, trace=RefreshTrace, refresh_checks=RefreshCheckCollection(), default_row_count_check=True, refresh_type=RefreshType.Full)</code>","text":"<p>Init when a refresh is requested.</p> <p>Runs through requested tables and partitions to make sure they are in model. Then will run pre checks on the requested objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Tabular</code> <p>Tabular model.</p> required <code>object</code> <code>Union[str, PyTable, PyPartition, Dict[str, Any]]</code> <p>The objects that you are wanting to refresh. Can be a <code>PyTable</code>, <code>PyPartition</code>, <code>TABLE_NAME</code> string, or a dict with <code>{TABLE_REFERENCE:PARTITION_REFERENCE}</code></p> required <code>trace</code> <code>BaseTrace</code> <p>Defaults to RefreshTrace.</p> <code>RefreshTrace</code> <code>refresh_checks</code> <code>RefreshCheckCollection</code> <p>Defaults to RefreshCheckCollection().</p> <code>RefreshCheckCollection()</code> <code>default_row_count_check</code> <code>bool</code> <p>Defaults to True.</p> <code>True</code> <code>refresh_type</code> <code>RefreshType</code> <p>Defaults to RefreshType.Full.</p> <code>Full</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(\n    self,\n    model,\n    object: Union[str, PyTable, PyPartition, Dict[str, Any]],\n    trace: BaseTrace = RefreshTrace,\n    refresh_checks: RefreshCheckCollection = RefreshCheckCollection(),\n    default_row_count_check: bool = True,\n    refresh_type: RefreshType = RefreshType.Full,\n) -&gt; None:\n    \"\"\"Init when a refresh is requested.\n\n    Runs through requested tables and partitions\n    to make sure they are in model.\n    Then will run pre checks on the requested objects.\n\n    Args:\n        model (Tabular): Tabular model.\n        object (Union[str, PyTable, PyPartition, Dict[str, Any]]): The objects\n            that you are wanting to refresh. Can be a `PyTable`, `PyPartition`,\n            `TABLE_NAME` string, or a dict with `{TABLE_REFERENCE:PARTITION_REFERENCE}`\n        trace (BaseTrace, optional): Defaults to RefreshTrace.\n        refresh_checks (RefreshCheckCollection, optional): Defaults to RefreshCheckCollection().\n        default_row_count_check (bool, optional): Defaults to True.\n        refresh_type (RefreshType, optional): Defaults to RefreshType.Full.\n    \"\"\"\n    self.model = model\n    self.object = object\n    self.trace = trace\n    self.default_row_count_check = default_row_count_check\n    self.refresh_type = refresh_type\n    self._objects_to_refresh = []\n    self._request_refresh(self.object)\n    self._checks = refresh_checks\n    self._pre_checks()\n    logger.info(\"Refresh Request Completed!\")\n    pass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh.run","title":"<code>run()</code>","text":"<p>When ready, execute to start the refresh process.</p> <p>First checks if connected and reconnects if needed. Then starts the trace if needed. Next will execute <code>save_changes()</code> and run the post checks after that. Last will return a <code>pd.DataFrame</code> of refresh results.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def run(self) -&gt; pd.DataFrame:\n    \"\"\"When ready, execute to start the refresh process.\n\n    First checks if connected and reconnects if needed.\n    Then starts the trace if needed.\n    Next will execute `save_changes()`\n    and run the post checks after that.\n    Last will return a `pd.DataFrame` of refresh results.\n    \"\"\"\n    if self.model.Server.Connected is False:\n        logger.info(f\"{self.Server.Name} - Reconnecting...\")\n        self.model.reconnect()\n\n    if self.trace is not None:\n        self.trace.start()\n\n    save_changes = self.model.save_changes()\n\n    self._post_checks()\n\n    return self._refresh_report(save_changes.property_changes)\n</code></pre>"},{"location":"tabular_editor/","title":"tabular_editor","text":"<p>This has a <code>Tabular_Editor</code> class which will download TE2 from a default location.</p> <p>Or you can input your own location.</p>"},{"location":"tabular_editor/#pytabular.tabular_editor.TabularEditor","title":"<code>TabularEditor</code>","text":"<p>Setting Tabular_Editor Class for future work.</p> <p>Mainly runs <code>download_tabular_editor()</code></p> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>class TabularEditor:\n    \"\"\"Setting Tabular_Editor Class for future work.\n\n    Mainly runs `download_tabular_editor()`\n    \"\"\"\n\n    def __init__(self, exe_file_path: str = \"Default\") -&gt; None:\n        \"\"\"Init for `TabularEditor()` class.\n\n        This is mostly a placeholder right now.\n        But useful if you want an easy way to download TE2.\n\n        Args:\n            exe_file_path (str, optional): File path where TE2 lives. Defaults to \"Default\".\n                If \"Default\", it will run `download_tabular_editor()`\n                and download from github.\n        \"\"\"\n        logger.debug(f\"Initializing Tabular Editor Class:: {exe_file_path}\")\n        if exe_file_path == \"Default\":\n            self.exe: str = download_tabular_editor()\n        else:\n            self.exe: str = exe_file_path\n        pass\n</code></pre>"},{"location":"tabular_editor/#pytabular.tabular_editor.TabularEditor.__init__","title":"<code>__init__(exe_file_path='Default')</code>","text":"<p>Init for <code>TabularEditor()</code> class.</p> <p>This is mostly a placeholder right now. But useful if you want an easy way to download TE2.</p> <p>Parameters:</p> Name Type Description Default <code>exe_file_path</code> <code>str</code> <p>File path where TE2 lives. Defaults to \"Default\". If \"Default\", it will run <code>download_tabular_editor()</code> and download from github.</p> <code>'Default'</code> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>def __init__(self, exe_file_path: str = \"Default\") -&gt; None:\n    \"\"\"Init for `TabularEditor()` class.\n\n    This is mostly a placeholder right now.\n    But useful if you want an easy way to download TE2.\n\n    Args:\n        exe_file_path (str, optional): File path where TE2 lives. Defaults to \"Default\".\n            If \"Default\", it will run `download_tabular_editor()`\n            and download from github.\n    \"\"\"\n    logger.debug(f\"Initializing Tabular Editor Class:: {exe_file_path}\")\n    if exe_file_path == \"Default\":\n        self.exe: str = download_tabular_editor()\n    else:\n        self.exe: str = exe_file_path\n    pass\n</code></pre>"},{"location":"tabular_editor/#pytabular.tabular_editor.download_tabular_editor","title":"<code>download_tabular_editor(download_location='https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip', folder='Tabular_Editor_2', auto_remove=True)</code>","text":"<p>Runs a request.get() to retrieve the zip file from web.</p> <p>Will unzip response and store in directory. Will also register the removal of the new directory and files when exiting program.</p> <p>Parameters:</p> Name Type Description Default <code>download_location</code> <code>str</code> <p>File path for zip of Tabular Editor 2. See code args for default download url.</p> <code>'https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip'</code> <code>folder</code> <code>str</code> <p>New Folder Location. Defaults to \"Tabular_Editor_2\".</p> <code>'Tabular_Editor_2'</code> <code>auto_remove</code> <code>bool</code> <p>Boolean to determine auto removal of files once script exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>File path of TabularEditor.exe</p> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>def download_tabular_editor(\n    download_location: str = (\n        \"https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip\"  # noqa: E501\n    ),\n    folder: str = \"Tabular_Editor_2\",\n    auto_remove=True,\n) -&gt; str:\n    \"\"\"Runs a request.get() to retrieve the zip file from web.\n\n    Will unzip response and store in directory.\n    Will also register the removal of the new directory\n    and files when exiting program.\n\n    Args:\n            download_location (str, optional): File path for zip of Tabular Editor 2.\n                    See code args for default download url.\n            folder (str, optional): New Folder Location. Defaults to \"Tabular_Editor_2\".\n            auto_remove (bool, optional): Boolean to determine auto\n                    removal of files once script exits. Defaults to True.\n\n    Returns:\n            str: File path of TabularEditor.exe\n    \"\"\"\n    logger.info(\"Downloading Tabular Editor 2...\")\n    logger.info(f\"From... {download_location}\")\n    folder_location = os.path.join(os.getcwd(), folder)\n    response = r.get(download_location)\n    file_location = f\"{os.getcwd()}\\\\{download_location.split('/')[-1]}\"\n    with open(file_location, \"wb\") as te2_zip:\n        te2_zip.write(response.content)\n    with z.ZipFile(file_location) as zipper:\n        zipper.extractall(path=folder_location)\n    logger.debug(\"Removing Zip File...\")\n    os.remove(file_location)\n    logger.info(f\"Tabular Editor Downloaded and Extracted to {folder_location}\")\n    if auto_remove:\n        logger.debug(f\"Registering removal on termination... For {folder_location}\")\n        atexit.register(remove_folder_and_contents, folder_location)\n    return f\"{folder_location}\\\\TabularEditor.exe\"\n</code></pre>"},{"location":"tabular_tracing/","title":"Running Traces","text":"<p><code>tabular_tracing.py</code> handles all tracing capabilities in your model.</p> <p>It also includes some pre built traces to make life easier. Feel free to build your own.</p> Example Monitor Queries<pre><code>import pytabular as p\nimport logging as l\nmodel = p.Tabular(CONNECTION_STR)\nquery_trace = p.QueryMonitor(model)\nquery_trace.start() # (1)\n\n###\n\np.logger.setLevel(l.DEBUG) # (2)\n\n###\n\nquery_trace.stop()\nquery_trace.drop() # (3)\n</code></pre> <ol> <li>You will now start to see query traces on your model get outputed to your console.</li> <li>If you want to see the FULL query then set logging to DEBUG.</li> <li>You can drop on your own, or will get dropped on script exit.</li> </ol>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace","title":"<code>BaseTrace</code>","text":"<p>Generates trace to be run on Server.</p> <p>This is the base class to customize the type of Trace you are looking for. It's recommended to use the out of the box traces built. It's on the roadmap to have an intuitive way to build traces for users.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class BaseTrace:\n    \"\"\"Generates trace to be run on Server.\n\n    This is the base class to customize the type of Trace you are looking for.\n    It's recommended to use the out of the box traces built.\n    It's on the roadmap to have an intuitive way to build traces for users.\n    \"\"\"\n\n    def __init__(\n        self,\n        tabular_class,\n        trace_events: List[TraceEvent],\n        trace_event_columns: List[TraceColumn],\n        handler: Callable,\n    ) -&gt; None:\n        \"\"\"This will `build()`, `add()`, and `update()` the trace to model.\n\n        It will also register the dropping on the trace on exiting python.\n\n        Args:\n            tabular_class (Tabular): The model you want the trace for.\n            trace_events (List[TraceEvent]): The TraceEvents you want have in your trace.\n                From Microsoft.AnalysisServices.TraceEventClass.\n            trace_event_columns (List[TraceColumn]): The trace event columns you want in your trace.\n                From Microsoft.AnalysisServices.TraceColumn.\n            handler (Callable): The `handler` is a function that will take in two args.\n                The first arg is `source` and it is currently unused.\n                The second is arg is `args` and here\n                is where you can access the results of the trace.\n        \"\"\"\n        logger.debug(\"Trace Base Class initializing...\")\n        self.Name = \"PyTabular_\" + \"\".join(\n            random.SystemRandom().choices(\n                [str(x) for x in [y for y in range(0, 10)]], k=10\n            )\n        )\n        self.ID = self.Name.replace(\"PyTabular_\", \"\")\n        self.Trace = Trace(self.Name, self.ID)\n        logger.debug(f\"Trace {self.Trace.Name} created...\")\n        self.tabular_class = tabular_class\n        self.Event_Categories = self._query_dmv_for_event_categories()\n\n        self.trace_events = trace_events\n        self.trace_event_columns = trace_event_columns\n        self.handler = handler\n\n        self.build()\n        self.add()\n        self.update()\n        atexit.register(self.drop)\n\n    def build(self) -&gt; bool:\n        \"\"\"Run on init.\n\n        This will take the inputed arguments for the class\n        and attempt to build the Trace.\n\n        Returns:\n                bool: True if successful\n        \"\"\"\n        logger.info(f\"Building Trace {self.Name}\")\n        te = [TraceEvent(trace_event) for trace_event in self.trace_events]\n        logger.debug(f\"Adding Events to... {self.Trace.Name}\")\n        [self.Trace.get_Events().Add(t) for t in te]\n\n        def add_column(trace_event, trace_event_column):\n            \"\"\"Adds the column to trace event.\"\"\"\n            try:\n                trace_event.Columns.Add(trace_event_column)\n            except Exception:\n                logger.warning(f\"{trace_event} - {trace_event_column} Skipped\")\n                pass\n\n        logger.debug(\"Adding Trace Event Columns...\")\n        [\n            add_column(trace_event, trace_event_column)\n            for trace_event_column in self.trace_event_columns\n            for trace_event in te\n            if str(trace_event_column.value__)\n            in self.Event_Categories[str(trace_event.EventID.value__)]\n        ]\n\n        logger.debug(\"Adding Handler to Trace...\")\n        self.handler = TraceEventHandler(self.handler)\n        self.Trace.OnEvent += self.handler\n        return True\n\n    def add(self) -&gt; int:\n        \"\"\"Runs on init. Adds built trace to the Server.\n\n        Returns:\n                int: Return int of placement in Server.Traces.get_Item(int).\n        \"\"\"\n        logger.info(f\"Adding {self.Name} to {self.tabular_class.Server.Name}\")\n        return self.tabular_class.Server.Traces.Add(self.Trace)\n\n    def update(self) -&gt; None:\n        \"\"\"Runs on init. Syncs with Server.\n\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\n        logger.info(f\"Updating {self.Name} in {self.tabular_class.Server.Name}\")\n        if self.tabular_class.Server.Connected is False:\n            self.tabular_class.reconnect()\n\n        return self.Trace.Update()\n\n    def start(self) -&gt; None:\n        \"\"\"Call when you want to start the trace.\n\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\n        logger.info(f\"Starting {self.Name} in {self.tabular_class.Server.Name}\")\n        return self.Trace.Start()\n\n    def stop(self) -&gt; None:\n        \"\"\"Call when you want to stop the trace.\n\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\n        logger.info(f\"Stopping {self.Name} in {self.tabular_class.Server.Name}\")\n        return self.Trace.Stop()\n\n    def drop(self) -&gt; None:\n        \"\"\"Call when you want to drop the trace.\n\n        Returns:\n            None: Returns None. Unless unsuccessful,\n                then it will return the error from Server.\n        \"\"\"\n        logger.info(f\"Dropping {self.Name} in {self.tabular_class.Server.Name}\")\n        atexit.unregister(self.drop)\n        return self.Trace.Drop()\n\n    def _query_dmv_for_event_categories(self):\n        \"\"\"Internal use. Called during the building process of a refresh.\n\n        It is used to locate allowed columns for event categories.\n        This is done by executing a `Tabular().Query()`\n        on the `DISCOVER_EVENT_CATEGORIES` table in the DMV.\n        Then the function will parse the results,\n        as it is xml inside of rows.\n        \"\"\"\n        event_categories = {}\n        events = []\n        logger.debug(\"Querying DMV for columns rules...\")\n        logger.debug(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")\n        df = self.tabular_class.query(\n            \"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\"\n        )\n        for index, row in df.iterrows():\n            xml_data = xmltodict.parse(row.Data)\n            if isinstance(xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"], list):\n                events += [\n                    event for event in xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"]\n                ]\n            else:\n                events += [xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"]]\n        for event in events:\n            event_categories[event[\"ID\"]] = [\n                column[\"ID\"] for column in event[\"EVENTCOLUMNLIST\"][\"EVENTCOLUMN\"]\n            ]\n        return event_categories\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.__init__","title":"<code>__init__(tabular_class, trace_events, trace_event_columns, handler)</code>","text":"<p>This will <code>build()</code>, <code>add()</code>, and <code>update()</code> the trace to model.</p> <p>It will also register the dropping on the trace on exiting python.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>The model you want the trace for.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>The TraceEvents you want have in your trace. From Microsoft.AnalysisServices.TraceEventClass.</p> required <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>The trace event columns you want in your trace. From Microsoft.AnalysisServices.TraceColumn.</p> required <code>handler</code> <code>Callable</code> <p>The <code>handler</code> is a function that will take in two args. The first arg is <code>source</code> and it is currently unused. The second is arg is <code>args</code> and here is where you can access the results of the trace.</p> required Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\n    self,\n    tabular_class,\n    trace_events: List[TraceEvent],\n    trace_event_columns: List[TraceColumn],\n    handler: Callable,\n) -&gt; None:\n    \"\"\"This will `build()`, `add()`, and `update()` the trace to model.\n\n    It will also register the dropping on the trace on exiting python.\n\n    Args:\n        tabular_class (Tabular): The model you want the trace for.\n        trace_events (List[TraceEvent]): The TraceEvents you want have in your trace.\n            From Microsoft.AnalysisServices.TraceEventClass.\n        trace_event_columns (List[TraceColumn]): The trace event columns you want in your trace.\n            From Microsoft.AnalysisServices.TraceColumn.\n        handler (Callable): The `handler` is a function that will take in two args.\n            The first arg is `source` and it is currently unused.\n            The second is arg is `args` and here\n            is where you can access the results of the trace.\n    \"\"\"\n    logger.debug(\"Trace Base Class initializing...\")\n    self.Name = \"PyTabular_\" + \"\".join(\n        random.SystemRandom().choices(\n            [str(x) for x in [y for y in range(0, 10)]], k=10\n        )\n    )\n    self.ID = self.Name.replace(\"PyTabular_\", \"\")\n    self.Trace = Trace(self.Name, self.ID)\n    logger.debug(f\"Trace {self.Trace.Name} created...\")\n    self.tabular_class = tabular_class\n    self.Event_Categories = self._query_dmv_for_event_categories()\n\n    self.trace_events = trace_events\n    self.trace_event_columns = trace_event_columns\n    self.handler = handler\n\n    self.build()\n    self.add()\n    self.update()\n    atexit.register(self.drop)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.build","title":"<code>build()</code>","text":"<p>Run on init.</p> <p>This will take the inputed arguments for the class and attempt to build the Trace.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def build(self) -&gt; bool:\n    \"\"\"Run on init.\n\n    This will take the inputed arguments for the class\n    and attempt to build the Trace.\n\n    Returns:\n            bool: True if successful\n    \"\"\"\n    logger.info(f\"Building Trace {self.Name}\")\n    te = [TraceEvent(trace_event) for trace_event in self.trace_events]\n    logger.debug(f\"Adding Events to... {self.Trace.Name}\")\n    [self.Trace.get_Events().Add(t) for t in te]\n\n    def add_column(trace_event, trace_event_column):\n        \"\"\"Adds the column to trace event.\"\"\"\n        try:\n            trace_event.Columns.Add(trace_event_column)\n        except Exception:\n            logger.warning(f\"{trace_event} - {trace_event_column} Skipped\")\n            pass\n\n    logger.debug(\"Adding Trace Event Columns...\")\n    [\n        add_column(trace_event, trace_event_column)\n        for trace_event_column in self.trace_event_columns\n        for trace_event in te\n        if str(trace_event_column.value__)\n        in self.Event_Categories[str(trace_event.EventID.value__)]\n    ]\n\n    logger.debug(\"Adding Handler to Trace...\")\n    self.handler = TraceEventHandler(self.handler)\n    self.Trace.OnEvent += self.handler\n    return True\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.add","title":"<code>add()</code>","text":"<p>Runs on init. Adds built trace to the Server.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Return int of placement in Server.Traces.get_Item(int).</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def add(self) -&gt; int:\n    \"\"\"Runs on init. Adds built trace to the Server.\n\n    Returns:\n            int: Return int of placement in Server.Traces.get_Item(int).\n    \"\"\"\n    logger.info(f\"Adding {self.Name} to {self.tabular_class.Server.Name}\")\n    return self.tabular_class.Server.Traces.Add(self.Trace)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.update","title":"<code>update()</code>","text":"<p>Runs on init. Syncs with Server.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Runs on init. Syncs with Server.\n\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\n    logger.info(f\"Updating {self.Name} in {self.tabular_class.Server.Name}\")\n    if self.tabular_class.Server.Connected is False:\n        self.tabular_class.reconnect()\n\n    return self.Trace.Update()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.start","title":"<code>start()</code>","text":"<p>Call when you want to start the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Call when you want to start the trace.\n\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\n    logger.info(f\"Starting {self.Name} in {self.tabular_class.Server.Name}\")\n    return self.Trace.Start()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.stop","title":"<code>stop()</code>","text":"<p>Call when you want to stop the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Call when you want to stop the trace.\n\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\n    logger.info(f\"Stopping {self.Name} in {self.tabular_class.Server.Name}\")\n    return self.Trace.Stop()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.drop","title":"<code>drop()</code>","text":"<p>Call when you want to drop the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful, then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def drop(self) -&gt; None:\n    \"\"\"Call when you want to drop the trace.\n\n    Returns:\n        None: Returns None. Unless unsuccessful,\n            then it will return the error from Server.\n    \"\"\"\n    logger.info(f\"Dropping {self.Name} in {self.tabular_class.Server.Name}\")\n    atexit.unregister(self.drop)\n    return self.Trace.Drop()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.RefreshTrace","title":"<code>RefreshTrace</code>","text":"<p>             Bases: <code>BaseTrace</code></p> <p>Subclass of <code>BaseTrace()</code>. Usefull for monitoring refreshes.</p> <p>This is the default trace that is run on refreshes. It will output all the various details into <code>logger()</code>. See <code>_refresh_handler()</code> for more details on what gets put into <code>logger()</code>.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class RefreshTrace(BaseTrace):\n    \"\"\"Subclass of `BaseTrace()`. Usefull for monitoring refreshes.\n\n    This is the default trace that is run on refreshes.\n    It will output all the various details into `logger()`.\n    See `_refresh_handler()` for more details on what gets\n    put into `logger()`.\n    \"\"\"\n\n    def __init__(\n        self,\n        tabular_class,\n        trace_events: List[TraceEvent] = [\n            TraceEventClass.ProgressReportBegin,\n            TraceEventClass.ProgressReportCurrent,\n            TraceEventClass.ProgressReportEnd,\n            TraceEventClass.ProgressReportError,\n        ],\n        trace_event_columns: List[TraceColumn] = [\n            TraceColumn.EventSubclass,\n            TraceColumn.CurrentTime,\n            TraceColumn.ObjectName,\n            TraceColumn.ObjectPath,\n            TraceColumn.DatabaseName,\n            TraceColumn.SessionID,\n            TraceColumn.TextData,\n            TraceColumn.EventClass,\n            TraceColumn.ProgressTotal,\n        ],\n        handler: Callable = _refresh_handler,\n    ) -&gt; None:\n        \"\"\"Init will extend through `BaseTrace()`. But pass through specific params.\n\n        Args:\n            tabular_class (Tabular): This is your `Tabular()` class.\n            trace_events (List[TraceEvent], optional): Defaults to [\n                TraceEventClass.ProgressReportBegin,\n                TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd,\n                TraceEventClass.ProgressReportError, ].\n            trace_event_columns (List[TraceColumn], optional): Defaults to\n                [ TraceColumn.EventSubclass, TraceColumn.CurrentTime,\n                TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName,\n                TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass,\n                TraceColumn.ProgressTotal, ].\n            handler (Callable, optional): _description_. Defaults to _refresh_handler.\n        \"\"\"\n        super().__init__(tabular_class, trace_events, trace_event_columns, handler)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.RefreshTrace.__init__","title":"<code>__init__(tabular_class, trace_events=[TraceEventClass.ProgressReportBegin, TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd, TraceEventClass.ProgressReportError], trace_event_columns=[TraceColumn.EventSubclass, TraceColumn.CurrentTime, TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName, TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass, TraceColumn.ProgressTotal], handler=_refresh_handler)</code>","text":"<p>Init will extend through <code>BaseTrace()</code>. But pass through specific params.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>This is your <code>Tabular()</code> class.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>Defaults to [ TraceEventClass.ProgressReportBegin, TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd, TraceEventClass.ProgressReportError, ].</p> <code>[ProgressReportBegin, ProgressReportCurrent, ProgressReportEnd, ProgressReportError]</code> <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>Defaults to [ TraceColumn.EventSubclass, TraceColumn.CurrentTime, TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName, TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass, TraceColumn.ProgressTotal, ].</p> <code>[EventSubclass, CurrentTime, ObjectName, ObjectPath, DatabaseName, SessionID, TextData, EventClass, ProgressTotal]</code> <code>handler</code> <code>Callable</code> <p>description. Defaults to _refresh_handler.</p> <code>_refresh_handler</code> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\n    self,\n    tabular_class,\n    trace_events: List[TraceEvent] = [\n        TraceEventClass.ProgressReportBegin,\n        TraceEventClass.ProgressReportCurrent,\n        TraceEventClass.ProgressReportEnd,\n        TraceEventClass.ProgressReportError,\n    ],\n    trace_event_columns: List[TraceColumn] = [\n        TraceColumn.EventSubclass,\n        TraceColumn.CurrentTime,\n        TraceColumn.ObjectName,\n        TraceColumn.ObjectPath,\n        TraceColumn.DatabaseName,\n        TraceColumn.SessionID,\n        TraceColumn.TextData,\n        TraceColumn.EventClass,\n        TraceColumn.ProgressTotal,\n    ],\n    handler: Callable = _refresh_handler,\n) -&gt; None:\n    \"\"\"Init will extend through `BaseTrace()`. But pass through specific params.\n\n    Args:\n        tabular_class (Tabular): This is your `Tabular()` class.\n        trace_events (List[TraceEvent], optional): Defaults to [\n            TraceEventClass.ProgressReportBegin,\n            TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd,\n            TraceEventClass.ProgressReportError, ].\n        trace_event_columns (List[TraceColumn], optional): Defaults to\n            [ TraceColumn.EventSubclass, TraceColumn.CurrentTime,\n            TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName,\n            TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass,\n            TraceColumn.ProgressTotal, ].\n        handler (Callable, optional): _description_. Defaults to _refresh_handler.\n    \"\"\"\n    super().__init__(tabular_class, trace_events, trace_event_columns, handler)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.QueryMonitor","title":"<code>QueryMonitor</code>","text":"<p>             Bases: <code>BaseTrace</code></p> <p>Subclass of <code>BaseTrace()</code>. Usefull for monitoring queries.</p> <p>The default handler for <code>QueryMonitor()</code> shows full query in <code>logger.debug()</code>. So you will need to set your logger to <code>debug()</code> if you would like to see them. Otherwise, will show basic info on who/what is querying.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class QueryMonitor(BaseTrace):\n    \"\"\"Subclass of `BaseTrace()`. Usefull for monitoring queries.\n\n    The default handler for `QueryMonitor()` shows full query in `logger.debug()`.\n    So you will need to set your logger to `debug()` if you would like to see them.\n    Otherwise, will show basic info on who/what is querying.\n    \"\"\"\n\n    def __init__(\n        self,\n        tabular_class,\n        trace_events: List[TraceEvent] = [TraceEventClass.QueryEnd],\n        trace_event_columns: List[TraceColumn] = [\n            TraceColumn.EventSubclass,\n            TraceColumn.StartTime,\n            TraceColumn.EndTime,\n            TraceColumn.Duration,\n            TraceColumn.Severity,\n            TraceColumn.Error,\n            TraceColumn.NTUserName,\n            TraceColumn.DatabaseName,\n            TraceColumn.ApplicationName,\n            TraceColumn.TextData,\n        ],\n        handler: Callable = _query_monitor_handler,\n    ) -&gt; None:\n        \"\"\"Init will extend through to BaseTrace, but pass through specific params.\n\n        Args:\n            tabular_class (Tabular): This is your `Tabular()` class.\n                All that will need to provided to successfully init.\n            trace_events (List[TraceEvent], optional): Defaults to [TraceEventClass.QueryEnd].\n            trace_event_columns (List[TraceColumn], optional): Defaults to\n                [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime,\n                TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error,\n                TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName,\n                TraceColumn.TextData, ].\n            handler (Callable, optional): Defaults to `_query_monitor_handler()`.\n        \"\"\"\n        super().__init__(tabular_class, trace_events, trace_event_columns, handler)\n        logger.info(\"Query text lives in DEBUG, adjust logging to see query text.\")\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.QueryMonitor.__init__","title":"<code>__init__(tabular_class, trace_events=[TraceEventClass.QueryEnd], trace_event_columns=[TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime, TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error, TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName, TraceColumn.TextData], handler=_query_monitor_handler)</code>","text":"<p>Init will extend through to BaseTrace, but pass through specific params.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>This is your <code>Tabular()</code> class. All that will need to provided to successfully init.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>Defaults to [TraceEventClass.QueryEnd].</p> <code>[QueryEnd]</code> <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>Defaults to [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime, TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error, TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName, TraceColumn.TextData, ].</p> <code>[EventSubclass, StartTime, EndTime, Duration, Severity, Error, NTUserName, DatabaseName, ApplicationName, TextData]</code> <code>handler</code> <code>Callable</code> <p>Defaults to <code>_query_monitor_handler()</code>.</p> <code>_query_monitor_handler</code> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\n    self,\n    tabular_class,\n    trace_events: List[TraceEvent] = [TraceEventClass.QueryEnd],\n    trace_event_columns: List[TraceColumn] = [\n        TraceColumn.EventSubclass,\n        TraceColumn.StartTime,\n        TraceColumn.EndTime,\n        TraceColumn.Duration,\n        TraceColumn.Severity,\n        TraceColumn.Error,\n        TraceColumn.NTUserName,\n        TraceColumn.DatabaseName,\n        TraceColumn.ApplicationName,\n        TraceColumn.TextData,\n    ],\n    handler: Callable = _query_monitor_handler,\n) -&gt; None:\n    \"\"\"Init will extend through to BaseTrace, but pass through specific params.\n\n    Args:\n        tabular_class (Tabular): This is your `Tabular()` class.\n            All that will need to provided to successfully init.\n        trace_events (List[TraceEvent], optional): Defaults to [TraceEventClass.QueryEnd].\n        trace_event_columns (List[TraceColumn], optional): Defaults to\n            [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime,\n            TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error,\n            TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName,\n            TraceColumn.TextData, ].\n        handler (Callable, optional): Defaults to `_query_monitor_handler()`.\n    \"\"\"\n    super().__init__(tabular_class, trace_events, trace_event_columns, handler)\n    logger.info(\"Query text lives in DEBUG, adjust logging to see query text.\")\n</code></pre>"}]}