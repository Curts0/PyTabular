{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyTabular","text":""},{"location":"#what-is-it","title":"What is it?","text":"<p>PyTabular (python-tabular in pypi) is a python package that allows for programmatic execution on your tabular models! This is possible thanks to Pythonnet and Microsoft's .Net APIs on Azure Analysis Services. Currently this build is tested and working on Windows Operating System only. Help is needed to expand this for other os. See the Documentation Here. PyTabular is still considered alpha. Please send bugs my way! Preferably in the issues section in Github.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the Pypi project for available versions. To become PEP8 compliant with naming conventions, serious name changes were made in 0.3.5. Install v. 0.3.4 or lower to get the older naming conventions. Install Example<pre><code>python3 -m pip install python-tabular\n#install specific version\npython3 -m pip install python-tabular==0.3.4\n</code></pre></p> <p>In your python environment, import pytabular and call the main Tabular Class. Only parameter needed is a solid connection string. Connecting to Model<pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR) # (1)\n</code></pre></p> <ol> <li>That's it. A solid connection string.</li> </ol> <p>You may have noticed some logging into your console. I'm a big fan of logging, if you don't want any just get the logger and disable it. Logging Example<pre><code>import pytabular\npytabular.logger.disabled = True\n</code></pre></p> <p>You can query your models with the <code>query()</code> method from your tabular class. For Dax Queries, it will need the full Dax syntax. See EVALUATE example. This will return a Pandas DataFrame. If you are looking to return a single value, see below. Simply wrap your query in the the curly brackets. The method will take that single cell table and just return the individual value. You can also query your DMV. See below for example. Query Examples<pre><code>#Run basic queries\nDAX_QUERY = \"EVALUATE TOPN(100, 'Table1')\"\nmodel.query(DAX_QUERY) # (1)\n#or...\nDMV_QUERY = \"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\"\nmodel.query(DMV_QUERY) # (2)\n#or...\nSINGLE_VALUE_QUERY_EX = \"EVALUATE {1}\"\nmodel.query(SINGLE_VALUE_QUERY_EX) # (3)\n#or...\nFILE_PATH = 'C:\\\\FILEPATHEXAMPLE\\\\file.dax'\nmodel.query(FILE_PATH) # (4)\n</code></pre></p> <ol> <li>Returns a <code>pd.DataFrame()</code>.</li> <li>Returns a <code>pd.DataFrame()</code>.</li> <li>This will return a single value. Example, <code>1</code> or <code>'string'</code>.</li> <li>This will return same logic as above, single values if possible else will return <code>pd.DataFrame()</code>. Supply any file type.</li> </ol> <p>You can also explore your tables, partitions, columns, etc. via the attributes of your <code>Tabular</code> class. Usage Examples<pre><code>model.Tables['Table Name'].refresh() # (1)\n#or\nmodel.Tables['Table Name'].Partitions['Partition Name'].refresh() # (2)\n#or\nmodel.Tables['Table Name'].Partitions[4].last_refresh() # (3)\n#or\nmodel.Tables['Table Name'].row_count() # (4)\n#or\nmodel.Tables['Table Name'].Columns['Column Name'].distinct_count() # (5)\n</code></pre></p> <ol> <li>Refresh a specific table. The <code>.Tables</code> is your attribute to gain access to your <code>PyTables</code> class. From that, you can iterate into specific <code>PyTable</code> classes.</li> <li>Refresh a specific partition.</li> <li>Get the last refresh time of a specific partition. Notice this time that instead of the partition name, an <code>int</code> was used to index into the specific <code>PyPartition</code>.</li> <li>Get row count of a table.</li> <li>Get distinct count of a column.</li> </ol> <p>Use the <code>refresh()</code> method to handle refreshes on your model. This is synchronous. Should be flexible enough to handle a variety of inputs. See PyTabular Docs for Refreshing Tables and Partitions. Most basic way to refresh is input the table name string. The method will search for table and output exception if unable to find it. For partitions you will need a key, value combination. Example, <code>{'Table1':'Partition1'}</code>. You can also take the key value pair and iterate through a group of partitions. Example, <code>{'Table1':['Partition1','Partition2']}</code>. Rather than providing a string, you can also input the actual class. See below for those examples. You can acess them from the built in attributes <code>self.Tables</code>, <code>self.Partitions</code>. Refresh Examples<pre><code>model.refresh('Table Name') # (1)\nmodel.refresh(['Table1','Table2','Table3']) # (2)\n#or...\nmodel.refresh(&lt;PyTable Class&gt;) # (3)\n#or...\nmodel.refresh(&lt;PyPartition Class&gt;) # (4)\n#or...\nmodel.refresh({'Table Name':'Partition Name'}) # (5)\n#or...\nmodel.refresh(\n[\n{\n&lt;PyTable Class&gt;:&lt;PyPartition Class&gt;,\n'Table Name':['Partition1','Partition2']\n},\n'Table Name',\n'Table Name2'\n]\n) # (6)\n#or...\nmodel.Tables['Table Name'].refresh() # (7)\n#or...\nmodel.Tables['Table Name'].Partitions['Partition Name'].refresh() # (8)\n#or...\nmodel.refresh(['Table1','Table2'], trace = None) # (9)\n</code></pre></p> <ol> <li>Basic refresh of a specific table by table name string.</li> <li>Basic refresh of a group of tables by table name strings. Example is with list, but as long as it's iterable you should be fine.</li> <li>Refresh of a table by passing the <code>PyTable</code> class.</li> <li>Refresh of a partition by passing the <code>PyPartition</code> class.</li> <li>Refresh a specific partition by passing a dictionary with table name as key and partition name as value.</li> <li>Get crazy. Pass all kinds of weird combinations.</li> <li>Basic refresh from a <code>PyTable</code> class.</li> <li>Basic refresh from a <code>PyPartition</code> class.</li> <li>By default a <code>RefreshTrace</code> is started during refresh. It can be disabled by setting <code>trace = None</code>.</li> </ol>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#if-blank-table-then-refresh-table","title":"If blank table, then refresh table.","text":"<p>This will use the function find_zero_rows and the method refresh from the Tabular class. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ntables = model.Tables.find_zero_rows()\nif len(tables) &gt; 0:\ntables.refresh()\n</code></pre></p> <p>Maybe you only want to check a subset of tables? Like <code>find()</code> tables with 'fact' in the name, then check if any facts are blank. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ntables = model.Tables.find('fact').find_zero_rows()\nif len(tables) &gt; 0:\ntables.refresh()\n</code></pre></p>"},{"location":"#sneak-in-a-refresh","title":"Sneak in a refresh.","text":"<p>This will use the method is_process and the method refresh from the Tabular class. It will check the DMV to see if any jobs are currently running classified as processing. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\nif model.is_process():\n#do what you want if there is a refresh happening\nelse:\nmodel.refresh(TABLES_OR_PARTITIONS_TO_REFRESH)\n</code></pre></p>"},{"location":"#show-refresh-times-in-model","title":"Show refresh times in model.","text":"<p>This will use the function last_refresh and the method create_table from the Tabular class. It will search through the model for all tables and partitions and pull the 'RefreshedTime' property from it. It will return results into a pandas dataframe, which will then be converted into an M expression used for a new table. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\ndf = model.Tables.last_refresh()\nmodel.create_table(df, 'Refresh Times')\n</code></pre></p>"},{"location":"#if-bpa-violation-then-revert-deployment","title":"If BPA Violation, then revert deployment.","text":"<p>This uses a few things. First the BPA Class, then the TE2 Class, and will finish with the analyze_bpa method. Did not want to re-invent the wheel with the amazing work done with Tabular Editor and it's BPA capabilities. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\n# Feel free to input your TE2 File path or this will download for you.\nte2 = pytabular.TabularEditor()\n# Feel free to input your own BPA file or this will download for you from:\n# https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\nbpa = pytabular.BPA()\nresults = model.analyze_bpa(te2.exe,bpa.location)\nif len(results) &gt; 0:\n#Revert deployment here!\n</code></pre></p>"},{"location":"#loop-through-and-query-dax-files","title":"Loop through and query Dax files","text":"<p>Let's say you have multiple dax queries you would like to store and run through as checks. The query method on the Tabular class can also take file paths. It can really be any file type as it's just checking os.path.isfile(). But would suggest <code>.dax</code> or <code>.txt</code>. It will read the file and use that as the new <code>query_str</code> argument. <pre><code>import pytabular\nmodel = pytabular.Tabular(CONNECTION_STR)\nLIST_OF_FILE_PATHS = [\n'C:\\\\FilePath\\\\file1.dax',\n'C:\\\\FilePath\\\\file1.txt',\n'C:\\\\FilePath\\\\file2.dax',\n'C:\\\\FilePath\\\\file2.txt'\n]\nfor file_path in LIST_OF_FILE_PATHS:\nmodel.query(file_path)\n</code></pre></p>"},{"location":"#advanced-refreshing-with-pre-and-post-checks","title":"Advanced Refreshing with Pre and Post Checks","text":"<p>Maybe you are introducing new logic to a fact table, and you need to ensure that a measure checking last month values never changes. To do that you can take advantage of the <code>RefreshCheck</code> and <code>RefreshCheckCollection</code> classes. But using those you can build out something that would first check the results of the measure, then refresh, then check the results of the measure after refresh, and lastly perform your desired check. In this case the <code>pre</code> value matches the <code>post</code> value. When refreshing, if your pre does not equal post, it would fail and give an assertion error in your logging. <pre><code>from pytabular import Tabular\nfrom pytabular.refresh import RefreshCheck, RefreshCheckCollection\nmodel = Tabular(CONNECTION_STR)\n# This is our custom check that we want to run after refresh.\n# Does the pre refresh value match the post refresh value.\ndef sum_of_sales_assertion(pre, post):\nreturn pre == post\n# This is where we put it all together into the `RefreshCheck` class. Give it a name, give it a query to run, and give it the assertion you want to make.\nsum_of_last_month_sales = RefreshCheck(\n'Last Month Sales',\nlambda: model.query(\"EVALUATE {[Last Month Sales]}\")\n,sum_of_sales_assertion\n)\n# Here we are adding it to a `RefreshCheckCollection` because you can have more than on `Refresh_Check` to run.\nall_refresh_check = RefreshCheckCollection([sum_of_last_month_sales])\nmodel.Refresh(\n'Fact Table Name',\nrefresh_checks = RefreshCheckCollection([sum_of_last_month_sales])\n)\n</code></pre></p>"},{"location":"#query-as-another-user","title":"Query as Another User","text":"<p>There are plenty of tools that allow you to query as an 'Effective User' inheriting their security when querying. This is an extremely valuable concept built natively into the .Net apis. My only gripe is they were all UI based. This allows you to programmatically connect as an effective user and query in Python. You could easily loop through all your users to run tests on their security. <pre><code>import pytabular as p\n#Connect to your model like usual...\nmodel = p.Tabular(CONNECTION_STR)\n#This will be the query I run...\nquery_str = '''\nEVALUATE\nSUMMARIZE(\n    'Product Dimension',\n    'Product Dimension'[Product Name],\n    \"Total Product Sales\", [Total Sales]\n)\n'''\n#This will be the user I want to query as...\nuser_email = 'user1@company.com'\n#Base line, to query as the user connecting to the model.\nmodel.query(query_str)\n#Option 1, Connect via connection class...\nuser1 = p.Connection(model.Server, effective_user = user_email)\nuser1.query(query_str)\n#Option 2, Just add Effective_User\nmodel.query(query_str, effective_user = user_email)\n#PyTabular will do it's best to handle multiple accounts...\n#So you won't have to reconnect on every query\n</code></pre></p>"},{"location":"#refresh-related-tables","title":"Refresh Related Tables","text":"<p>Ever need to refresh related tables of a Fact? Now should be a lot easier. <pre><code>import pytabular as p\n#Connect to model\nmodel = p.Tabular(CONNECTION_STR)\n#Get related tables\ntables = model.Tables[TABLE_NAME].related()\n#Now just refresh like usual...\ntables.refresh()\n</code></pre></p>"},{"location":"#documenting-a-model","title":"Documenting a Model","text":"<p>The Tabular model contains a lot of information that can be used to generation documentation if filled in. Currently the markdown files are generated with the Docusaurs heading in place, but this will be changed in future to support multiple documentation platforms. </p> <p>Tip: With Tabular Editor 2 (Free) or 3 (Paid) you can easily add Descriptioms, Translations (Cultures) and other additonal information that can later be used for generating the documentation. </p> <p>Args:</p> <ul> <li>model: Tabular</li> <li>friendly_name: Default &gt; No Value </li> </ul> <p>To specify the location of the docs, just supply the save location with a new folder name argument.</p> <ul> <li>save_location: Default &gt; docs</li> </ul> <p>Each page in the generation process has it's own specific name, with these arguments you can rename them to your liking.</p> <ul> <li>general_page_url: Default &gt; 1-general-information.md</li> <li>measure_page_url: Default &gt; 2-measures.md</li> <li>table_page_url: Default &gt; 3-tables.md</li> <li>column_page_url: Default &gt; 4-columns.md</li> <li>roles_page_url: Default &gt; 5-roles.md</li> </ul>"},{"location":"#documenting-a-model_1","title":"Documenting a Model","text":"<p>The simpelst way to document a tabular model is to connect to the model, and initialize the documentation and execute <code>save_documentation()</code>. </p> <pre><code>import pytabular\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n# Initiate the Docs \ndocs = pytabular.ModelDocumenter(model)\n# Generate the pages. \ndocs.generate_documentation_pages()\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre>"},{"location":"#documenting-a-model-with-cultures","title":"Documenting a Model with Cultures","text":"<p>Some model creators choose to add cultures to a tabular model for different kinds of reasons. We can leverage those cultures to use the translation names instead of the original object names. In order to this you can set translations to <code>True</code> and specify the culture you want to use (e.g. <code>'en-US'</code>). </p> <pre><code>import pytabular\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n# Initiate the Docs \ndocs = pytabular.ModelDocumenter(model)\n# Set the translation for documentation to an available culture.\n# By setting the Tranlsations to `True` it will check if it exists and if it does, \n# it will start using the translations for the docs\ndocs.set_translations(\nenable_translations = True, \nculture = 'en-US'\n)\n# Generate the pages. \ndocs.generate_documentation_pages()\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre>"},{"location":"#documenting-a-power-bi-local-model","title":"Documenting a Power BI &gt; Local Model.","text":"<p>The Local model doesn't have a \"name\", only an Id. So we need to Supply a \"Friendly Name\", which will be used to store the markdown files. <pre><code>import pytabular\n# Connect to a Tabular Model Model\nmodel = pytabular.Tabular(CONNECTION_STR)\n# Initiate the Docs and set a friendly name to store the markdown files.\ndocs = pytabular.ModelDocumenter(\nmodel = model,\nfriendly_name = \"Adventure Works\"\n)\n# Generate the pages. \ndocs.generate_documentation_pages()\n# Save docs to the default location\ndocs.save_documentation()\n</code></pre></p>"},{"location":"#contributing","title":"Contributing","text":"<p>See contributing.md</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guidelines","text":""},{"location":"CONTRIBUTING/#goal","title":"Goal","text":"<ul> <li>Make Python a first class citizen for interacting with Tabular models.</li> </ul>"},{"location":"CONTRIBUTING/#some-rules","title":"Some rules","text":"<ul> <li>See github actions for checks run on pull request.</li> <li>We <code>docstring-coverage</code> to check for 100% docstring coverage.</li> <li><code>flake8</code> also runs, but with a few extra packages. (pep8-naming, flake8-docstrings).</li> <li>Updates of any kind are welcome! Even just letting me know of the issues. Or updating docstrings...</li> <li>Limit any extra packages, see <code>pyproject.toml</code> for dependencies</li> <li>Install pre-commit. Pre-commit will run pytest, flake8, and docstr-coverage before push. <pre><code>pip install pre-commit\npre-commit install --hook-type pre-push\n</code></pre></li> <li>This will take a while... pytest will open a PBIX file in repository and run tests on it... Eventually these tests will be run on a model that is not local.</li> </ul>"},{"location":"CONTRIBUTING/#documentation-help","title":"Documentation help","text":"<ul> <li>Docstrings follow the google docstring convention. See Example.</li> <li>The <code>flake8-docstrings</code> will check that google docstring format is followed.</li> <li>Docstrings get converted to markdown with the <code>mkdocstring</code> package.</li> <li>Then gets converted to a site with the <code>mkdocs</code> package.</li> </ul>"},{"location":"CONTRIBUTING/#misc","title":"Misc","text":"<ul> <li>Work will be distributed under a MIT license.</li> </ul>"},{"location":"PyColumn/","title":"PyColumn","text":"<p>         Bases: <code>PyObject</code></p> <p>The main class to work with your columns.</p> <p>Notice the <code>PyObject</code> magic method <code>__getattr__()</code> will search in <code>self._object</code> if it is unable to find it in the default attributes. This let's you also easily check the default .Net properties. See methods for extra functionality.</p> Source code in <code>pytabular/column.py</code> <pre><code>class PyColumn(PyObject):\n\"\"\"The main class to work with your columns.\n    Notice the `PyObject` magic method `__getattr__()` will search in `self._object`\n    if it is unable to find it in the default attributes.\n    This let's you also easily check the default .Net properties.\n    See methods for extra functionality.\n    \"\"\"\ndef __init__(self, object, table) -&gt; None:\n\"\"\"Init that connects your column to parent table.\n        It will also build custom rows for your `rich`\n        display table.\n        Args:\n            object (Column): .Net column object.\n            table (Table): .Net table object.\n        \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\n\"Description\", str(self._object.Description), end_section=True\n)\nself._display.add_row(\"DataType\", str(self._object.DataType))\nself._display.add_row(\"EncodingHint\", str(self._object.EncodingHint))\nself._display.add_row(\"IsAvailableInMDX\", str(self._object.IsAvailableInMDX))\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"IsKey\", str(self._object.IsKey))\nself._display.add_row(\"IsNullable\", str(self._object.IsNullable))\nself._display.add_row(\"State\", str(self._object.State))\nself._display.add_row(\"DisplayFolder\", str(self._object.DisplayFolder))\ndef get_dependencies(self) -&gt; pd.DataFrame:\n\"\"\"Returns the dependant columns of a measure.\"\"\"\ndmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where [OBJECT] = \\\n            '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\nreturn self.Table.Model.query(dmv_query)\ndef get_sample_values(self, top_n: int = 3) -&gt; pd.DataFrame:\n\"\"\"Get sample values of column.\"\"\"\ncolumn_to_sample = f\"'{self.Table.Name}'[{self.Name}]\"\ntry:\n# adding temporary try except. TOPNSKIP will not work for directquery mode.\n# Need an efficient way to identify if query is direct query or not.\ndax_query = f\"\"\"EVALUATE\n                                TOPNSKIP(\n{top_n},\n                                    0,\n                                    FILTER(\n                                        VALUES({column_to_sample}),\n                                        NOT ISBLANK({column_to_sample})\n                                        &amp;&amp; LEN({column_to_sample}) &gt; 0\n                                    ),\n                                    1\n                                )\n                                ORDER BY {column_to_sample}\n                        \"\"\"\nreturn self.Table.Model.query(dax_query)\nexcept Exception:\n# This is really tech debt anyways and should be replaced...\ndax_query = f\"\"\"\n            EVALUATE\n                TOPN(\n{top_n},\n                    FILTER(\n                        VALUES({column_to_sample}),\n                        NOT ISBLANK({column_to_sample}) &amp;&amp; LEN({column_to_sample}) &gt; 0\n                    )\n                )\n            \"\"\"\nreturn self.Table.Model.query(dax_query)\ndef distinct_count(self, no_blank=False) -&gt; int:\n\"\"\"Get the `DISTINCTCOUNT` of a column.\n        Args:\n            no_blank (bool, optional): If `True`, will call `DISTINCTCOUNTNOBLANK`.\n                Defaults to `False`.\n        Returns:\n            int: Number of Distinct Count from column.\n                If `no_blank == True` then will return number of distinct count no blanks.\n        \"\"\"\nfunc = \"DISTINCTCOUNT\"\nif no_blank:\nfunc += \"NOBLANK\"\nreturn self.Table.Model.Adomd.query(\nf\"EVALUATE {{{func}('{self.Table.Name}'[{self.Name}])}}\"\n)\ndef values(self) -&gt; pd.DataFrame:\n\"\"\"Get single column DataFrame of values in column.\n        Similar to `get_sample_values()` but will return **all**.\n        Returns:\n            pd.DataFrame: Single column DataFrame of values.\n        \"\"\"\nreturn self.Table.Model.Adomd.query(\nf\"EVALUATE VALUES('{self.Table.Name}'[{self.Name}])\"\n)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Init that connects your column to parent table.</p> <p>It will also build custom rows for your <code>rich</code> display table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Column</code> <p>.Net column object.</p> required <code>table</code> <code>Table</code> <p>.Net table object.</p> required Source code in <code>pytabular/column.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n\"\"\"Init that connects your column to parent table.\n    It will also build custom rows for your `rich`\n    display table.\n    Args:\n        object (Column): .Net column object.\n        table (Table): .Net table object.\n    \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\n\"Description\", str(self._object.Description), end_section=True\n)\nself._display.add_row(\"DataType\", str(self._object.DataType))\nself._display.add_row(\"EncodingHint\", str(self._object.EncodingHint))\nself._display.add_row(\"IsAvailableInMDX\", str(self._object.IsAvailableInMDX))\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"IsKey\", str(self._object.IsKey))\nself._display.add_row(\"IsNullable\", str(self._object.IsNullable))\nself._display.add_row(\"State\", str(self._object.State))\nself._display.add_row(\"DisplayFolder\", str(self._object.DisplayFolder))\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Returns the dependant columns of a measure.</p> Source code in <code>pytabular/column.py</code> <pre><code>def get_dependencies(self) -&gt; pd.DataFrame:\n\"\"\"Returns the dependant columns of a measure.\"\"\"\ndmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where [OBJECT] = \\\n        '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\nreturn self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.get_sample_values","title":"<code>get_sample_values(top_n=3)</code>","text":"<p>Get sample values of column.</p> Source code in <code>pytabular/column.py</code> <pre><code>def get_sample_values(self, top_n: int = 3) -&gt; pd.DataFrame:\n\"\"\"Get sample values of column.\"\"\"\ncolumn_to_sample = f\"'{self.Table.Name}'[{self.Name}]\"\ntry:\n# adding temporary try except. TOPNSKIP will not work for directquery mode.\n# Need an efficient way to identify if query is direct query or not.\ndax_query = f\"\"\"EVALUATE\n                            TOPNSKIP(\n{top_n},\n                                0,\n                                FILTER(\n                                    VALUES({column_to_sample}),\n                                    NOT ISBLANK({column_to_sample})\n                                    &amp;&amp; LEN({column_to_sample}) &gt; 0\n                                ),\n                                1\n                            )\n                            ORDER BY {column_to_sample}\n                    \"\"\"\nreturn self.Table.Model.query(dax_query)\nexcept Exception:\n# This is really tech debt anyways and should be replaced...\ndax_query = f\"\"\"\n        EVALUATE\n            TOPN(\n{top_n},\n                FILTER(\n                    VALUES({column_to_sample}),\n                    NOT ISBLANK({column_to_sample}) &amp;&amp; LEN({column_to_sample}) &gt; 0\n                )\n            )\n        \"\"\"\nreturn self.Table.Model.query(dax_query)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.distinct_count","title":"<code>distinct_count(no_blank=False)</code>","text":"<p>Get the <code>DISTINCTCOUNT</code> of a column.</p> <p>Parameters:</p> Name Type Description Default <code>no_blank</code> <code>bool</code> <p>If <code>True</code>, will call <code>DISTINCTCOUNTNOBLANK</code>. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of Distinct Count from column. If <code>no_blank == True</code> then will return number of distinct count no blanks.</p> Source code in <code>pytabular/column.py</code> <pre><code>def distinct_count(self, no_blank=False) -&gt; int:\n\"\"\"Get the `DISTINCTCOUNT` of a column.\n    Args:\n        no_blank (bool, optional): If `True`, will call `DISTINCTCOUNTNOBLANK`.\n            Defaults to `False`.\n    Returns:\n        int: Number of Distinct Count from column.\n            If `no_blank == True` then will return number of distinct count no blanks.\n    \"\"\"\nfunc = \"DISTINCTCOUNT\"\nif no_blank:\nfunc += \"NOBLANK\"\nreturn self.Table.Model.Adomd.query(\nf\"EVALUATE {{{func}('{self.Table.Name}'[{self.Name}])}}\"\n)\n</code></pre>"},{"location":"PyColumn/#pytabular.column.PyColumn.values","title":"<code>values()</code>","text":"<p>Get single column DataFrame of values in column.</p> <p>Similar to <code>get_sample_values()</code> but will return all.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Single column DataFrame of values.</p> Source code in <code>pytabular/column.py</code> <pre><code>def values(self) -&gt; pd.DataFrame:\n\"\"\"Get single column DataFrame of values in column.\n    Similar to `get_sample_values()` but will return **all**.\n    Returns:\n        pd.DataFrame: Single column DataFrame of values.\n    \"\"\"\nreturn self.Table.Model.Adomd.query(\nf\"EVALUATE VALUES('{self.Table.Name}'[{self.Name}])\"\n)\n</code></pre>"},{"location":"PyColumns/","title":"PyColumns","text":"<p>         Bases: <code>PyObjects</code></p> <p>Groups together multiple <code>PyColumn()</code>.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyColumns</code> straight from model. For ex: <code>model.Columns</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Columns</code>. You can even filter down with <code>.Find()</code>. For example find all columns with <code>Key</code> in name. <code>model.Columns.Find('Key')</code>.</p> Source code in <code>pytabular/column.py</code> <pre><code>class PyColumns(PyObjects):\n\"\"\"Groups together multiple `PyColumn()`.\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyColumns` straight from model. For ex: `model.Columns`.\n    Or through individual tables `model.Tables[TABLE_NAME].Columns`.\n    You can even filter down with `.Find()`.\n    For example find all columns with `Key` in name.\n    `model.Columns.Find('Key')`.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Init extends through to the `PyObjects()` init.\"\"\"\nsuper().__init__(objects)\ndef query_all(self, query_function: str = \"COUNTROWS(VALUES(_))\") -&gt; pd.DataFrame:\n\"\"\"This will dynamically all columns in `PyColumns()` class.\n        It will replace the `_` with the column to run\n        whatever the given `query_function` value is.\n        Args:\n                query_function (str, optional): Default is `COUNTROWS(VALUES(_))`.\n                        The `_` gets replaced with the column in question.\n                        Method will take whatever DAX query is given.\n        Returns:\n                pd.DataFrame: Returns dataframe with results.\n        \"\"\"\nlogger.info(\"Beginning execution of querying every column...\")\nlogger.debug(f\"Function to be run: {query_function}\")\nlogger.debug(\"Dynamically creating DAX query...\")\nquery_str = \"EVALUATE UNION(\\n\"\ncolumns = [column for column in self]\nfor column in columns:\nif column.Type != ColumnType.RowNumber:\ntable_name = column.Table.get_Name()\ncolumn_name = column.get_Name()\ndax_identifier = f\"'{table_name}'[{column_name}]\"\nquery_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\n\\\"Column\\\",\\\"{column_name}\\\",\\\"{query_function}\\\",\\\n{query_function.replace('_',dax_identifier)}),\\n\"\nquery_str = f\"{query_str[:-2]})\"\nreturn self[0].Table.Model.query(query_str)\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n\"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n        Args:\n            objects (_type_): _description_\n        \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\ndef __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\ndef __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\nreturn len(self._objects)\ndef __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\ndef find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n        It is case insensitive.\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyColumns/#pytabular.column.PyColumns.__init__","title":"<code>__init__(objects)</code>","text":"<p>Init extends through to the <code>PyObjects()</code> init.</p> Source code in <code>pytabular/column.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n\"\"\"Init extends through to the `PyObjects()` init.\"\"\"\nsuper().__init__(objects)\n</code></pre>"},{"location":"PyColumns/#pytabular.column.PyColumns.query_all","title":"<code>query_all(query_function='COUNTROWS(VALUES(_))')</code>","text":"<p>This will dynamically all columns in <code>PyColumns()</code> class.</p> <p>It will replace the <code>_</code> with the column to run whatever the given <code>query_function</code> value is.</p> <p>Parameters:</p> Name Type Description Default <code>query_function</code> <code>str</code> <p>Default is <code>COUNTROWS(VALUES(_))</code>. The <code>_</code> gets replaced with the column in question. Method will take whatever DAX query is given.</p> <code>'COUNTROWS(VALUES(_))'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Returns dataframe with results.</p> Source code in <code>pytabular/column.py</code> <pre><code>def query_all(self, query_function: str = \"COUNTROWS(VALUES(_))\") -&gt; pd.DataFrame:\n\"\"\"This will dynamically all columns in `PyColumns()` class.\n    It will replace the `_` with the column to run\n    whatever the given `query_function` value is.\n    Args:\n            query_function (str, optional): Default is `COUNTROWS(VALUES(_))`.\n                    The `_` gets replaced with the column in question.\n                    Method will take whatever DAX query is given.\n    Returns:\n            pd.DataFrame: Returns dataframe with results.\n    \"\"\"\nlogger.info(\"Beginning execution of querying every column...\")\nlogger.debug(f\"Function to be run: {query_function}\")\nlogger.debug(\"Dynamically creating DAX query...\")\nquery_str = \"EVALUATE UNION(\\n\"\ncolumns = [column for column in self]\nfor column in columns:\nif column.Type != ColumnType.RowNumber:\ntable_name = column.Table.get_Name()\ncolumn_name = column.get_Name()\ndax_identifier = f\"'{table_name}'[{column_name}]\"\nquery_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\n\\\"Column\\\",\\\"{column_name}\\\",\\\"{query_function}\\\",\\\n{query_function.replace('_',dax_identifier)}),\\n\"\nquery_str = f\"{query_str[:-2]})\"\nreturn self[0].Table.Model.query(query_str)\n</code></pre>"},{"location":"PyColumns/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>object.PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n    It is case insensitive.\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyMeasure/","title":"PyMeasure","text":"<p>         Bases: <code>PyObject</code></p> <p>Main class for interacting with measures.</p> <p>See methods for available functionality.</p> Source code in <code>pytabular/measure.py</code> <pre><code>class PyMeasure(PyObject):\n\"\"\"Main class for interacting with measures.\n    See methods for available functionality.\n    \"\"\"\ndef __init__(self, object, table) -&gt; None:\n\"\"\"Connects measure to parent `PyTable`.\n        It will also add some custom rows for the `rich`\n        table display.\n        Args:\n            object (object.PyObject): The .Net measure object.\n            table (table.PyTable): The parent `PyTable`.\n        \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\"Expression\", self._object.Expression, end_section=True)\nself._display.add_row(\"DisplayFolder\", self._object.DisplayFolder)\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"FormatString\", self._object.FormatString)\ndef get_dependencies(self) -&gt; pd.DataFrame:\n\"\"\"Get the dependant objects of a measure.\n        Returns:\n            pd.DataFrame: The Return Value is a Pandas dataframe\n                            which displays all the dependancies\n                            of the object.\n        \"\"\"\ndmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where \\\n            [OBJECT] = '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\nreturn self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyMeasure/#pytabular.measure.PyMeasure.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Connects measure to parent <code>PyTable</code>.</p> <p>It will also add some custom rows for the <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>object.PyObject</code> <p>The .Net measure object.</p> required <code>table</code> <code>table.PyTable</code> <p>The parent <code>PyTable</code>.</p> required Source code in <code>pytabular/measure.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n\"\"\"Connects measure to parent `PyTable`.\n    It will also add some custom rows for the `rich`\n    table display.\n    Args:\n        object (object.PyObject): The .Net measure object.\n        table (table.PyTable): The parent `PyTable`.\n    \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\"Expression\", self._object.Expression, end_section=True)\nself._display.add_row(\"DisplayFolder\", self._object.DisplayFolder)\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"FormatString\", self._object.FormatString)\n</code></pre>"},{"location":"PyMeasure/#pytabular.measure.PyMeasure.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Get the dependant objects of a measure.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The Return Value is a Pandas dataframe             which displays all the dependancies             of the object.</p> Source code in <code>pytabular/measure.py</code> <pre><code>def get_dependencies(self) -&gt; pd.DataFrame:\n\"\"\"Get the dependant objects of a measure.\n    Returns:\n        pd.DataFrame: The Return Value is a Pandas dataframe\n                        which displays all the dependancies\n                        of the object.\n    \"\"\"\ndmv_query = f\"select * from $SYSTEM.DISCOVER_CALC_DEPENDENCY where \\\n        [OBJECT] = '{self.Name}' and [TABLE] = '{self.Table.Name}'\"\nreturn self.Table.Model.query(dmv_query)\n</code></pre>"},{"location":"PyMeasures/","title":"PyMeasures","text":"<p>         Bases: <code>PyObjects</code></p> <p>Groups together multiple measures.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyMeasures</code> straight from model. For ex: <code>model.Measures</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Measures</code>. You can even filter down with <code>.find()</code>. For example find all measures with <code>ratio</code> in name. <code>model.Measures.find('ratio')</code>.</p> Source code in <code>pytabular/measure.py</code> <pre><code>class PyMeasures(PyObjects):\n\"\"\"Groups together multiple measures.\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyMeasures` straight from model. For ex: `model.Measures`.\n    Or through individual tables `model.Tables[TABLE_NAME].Measures`.\n    You can even filter down with `.find()`.\n    For example find all measures with `ratio` in name.\n    `model.Measures.find('ratio')`.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Extends init from `PyObjects`.\"\"\"\nsuper().__init__(objects)\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n\"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n        Args:\n            objects (_type_): _description_\n        \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\ndef __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\ndef __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\nreturn len(self._objects)\ndef __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\ndef find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n        It is case insensitive.\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyMeasures/#pytabular.measure.PyMeasures.__init__","title":"<code>__init__(objects)</code>","text":"<p>Extends init from <code>PyObjects</code>.</p> Source code in <code>pytabular/measure.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n\"\"\"Extends init from `PyObjects`.\"\"\"\nsuper().__init__(objects)\n</code></pre>"},{"location":"PyMeasures/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>object.PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n    It is case insensitive.\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyObject/","title":"PyObject","text":"<p>         Bases: <code>ABC</code></p> <p>The main parent class for your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. <code>__getattr__()</code> will check in <code>self._object</code>, if unable to find anything in <code>self</code>. This will let you pull properties from the main .Net class.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObject(ABC):\n\"\"\"The main parent class for your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    `__getattr__()` will check in `self._object`, if unable to find anything in `self`.\n    This will let you pull properties from the main .Net class.\n    \"\"\"\ndef __init__(self, object) -&gt; None:\n\"\"\"Init to create your PyObject.\n        This will take the `object` and\n        set as an attribute to the `self._object`.\n        You can use that if you want to interact directly with the .Net object.\n        It will also begin to build out a default `rich` table display.\n        Args:\n            object (.Net object): A .Net object.\n        \"\"\"\nself._object = object\nself._display = Table(title=self.Name)\nself._display.add_column(\n\"Properties\", justify=\"right\", style=\"cyan\", no_wrap=True\n)\nself._display.add_column(\"\", justify=\"left\", style=\"magenta\", no_wrap=False)\nself._display.add_row(\"Name\", self.Name)\nself._display.add_row(\"ObjectType\", str(self.ObjectType))\nif str(self.ObjectType) not in \"Model\":\nself._display.add_row(\"ParentName\", self.Parent.Name)\nself._display.add_row(\n\"ParentObjectType\",\nstr(self.Parent.ObjectType),\nend_section=True,\n)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getattr__(self, attr):\n\"\"\"Searches in `self._object`.\"\"\"\nreturn getattr(self._object, attr)\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__init__","title":"<code>__init__(object)</code>","text":"<p>Init to create your PyObject.</p> <p>This will take the <code>object</code> and set as an attribute to the <code>self._object</code>. You can use that if you want to interact directly with the .Net object. It will also begin to build out a default <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>.Net object</code> <p>A .Net object.</p> required Source code in <code>pytabular/object.py</code> <pre><code>def __init__(self, object) -&gt; None:\n\"\"\"Init to create your PyObject.\n    This will take the `object` and\n    set as an attribute to the `self._object`.\n    You can use that if you want to interact directly with the .Net object.\n    It will also begin to build out a default `rich` table display.\n    Args:\n        object (.Net object): A .Net object.\n    \"\"\"\nself._object = object\nself._display = Table(title=self.Name)\nself._display.add_column(\n\"Properties\", justify=\"right\", style=\"cyan\", no_wrap=True\n)\nself._display.add_column(\"\", justify=\"left\", style=\"magenta\", no_wrap=False)\nself._display.add_row(\"Name\", self.Name)\nself._display.add_row(\"ObjectType\", str(self.ObjectType))\nif str(self.ObjectType) not in \"Model\":\nself._display.add_row(\"ParentName\", self.Parent.Name)\nself._display.add_row(\n\"ParentObjectType\",\nstr(self.Parent.ObjectType),\nend_section=True,\n)\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>See Rich Repr.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\n</code></pre>"},{"location":"PyObject/#pytabular.object.PyObject.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Searches in <code>self._object</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __getattr__(self, attr):\n\"\"\"Searches in `self._object`.\"\"\"\nreturn getattr(self._object, attr)\n</code></pre>"},{"location":"PyObjects/","title":"PyObjects","text":"<p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n\"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n        Args:\n            objects (_type_): _description_\n        \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\ndef __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\ndef __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\nreturn len(self._objects)\ndef __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\ndef find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n        It is case insensitive.\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__init__","title":"<code>__init__(objects)</code>","text":"<p>Initialization of <code>PyObjects</code>.</p> <p>Takes the objects in something that is iterable. Then will build a default <code>rich</code> table display.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>_type_</code> <p>description</p> required Source code in <code>pytabular/object.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n    Takes the objects in something that is iterable.\n    Then will build a default `rich` table display.\n    Args:\n        objects (_type_): _description_\n    \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__rich_repr__","title":"<code>__rich_repr__()</code>","text":"<p>See Rich Repr.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__getitem__","title":"<code>__getitem__(object)</code>","text":"<p>Get item from <code>PyObjects</code>.</p> <p>Checks if item is str or int. If string will iterate through and try to find matching name. Otherwise, will call into <code>self._objects[int]</code> to retrieve item.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n    Checks if item is str or int.\n    If string will iterate through and try to find matching name.\n    Otherwise, will call into `self._objects[int]` to retrieve item.\n    \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through <code>PyObjects</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__len__","title":"<code>__len__()</code>","text":"<p>Get length of <code>PyObjects</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of PyObject in PyObjects</p> Source code in <code>pytabular/object.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n    Returns:\n        int: Number of PyObject in PyObjects\n    \"\"\"\nreturn len(self._objects)\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.__iadd__","title":"<code>__iadd__(obj)</code>","text":"<p>Add a <code>PyObject</code> or <code>PyObjects</code> to your current <code>PyObjects</code> class.</p> <p>This is useful for building out a custom <code>PyObjects</code> class to work with.</p> Source code in <code>pytabular/object.py</code> <pre><code>def __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n    This is useful for building out a custom `PyObjects` class to work with.\n    \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\n</code></pre>"},{"location":"PyObjects/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>object.PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n    It is case insensitive.\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyPartition/","title":"PyPartition","text":"<p>         Bases: <code>PyObject</code></p> <p>Main class for interacting with partitions.</p> <p>See methods for available uses.</p> Source code in <code>pytabular/partition.py</code> <pre><code>class PyPartition(PyObject):\n\"\"\"Main class for interacting with partitions.\n    See methods for available uses.\n    \"\"\"\ndef __init__(self, object, table) -&gt; None:\n\"\"\"Extends from `PyObject` class.\n        Adds a few custom rows to `rich` table for the partition.\n        Args:\n            object (Partition): .Net Partition object.\n            table (PyTable): Parent table of the partition in question.\n        \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\"Mode\", str(self._object.Mode))\nself._display.add_row(\"State\", str(self._object.State))\nself._display.add_row(\n\"SourceType\", str(self._object.SourceType), end_section=True\n)\nself._display.add_row(\n\"RefreshedTime\", self.last_refresh().strftime(\"%m/%d/%Y, %H:%M:%S\")\n)\ndef last_refresh(self) -&gt; datetime:\n\"\"\"Queries `RefreshedTime` attribute in the partition.\n        Converts from C# Ticks to Python datetime.\n        Returns:\n            datetime.datetime: Last Refreshed time of Partition in datetime format\n        \"\"\"\nreturn ticks_to_datetime(self.RefreshedTime.Ticks)\ndef refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Same method from Model Refresh.\n        You can pass through any extra parameters. For example:\n        `Tabular().Tables['Table Name'].Partitions[0].refresh()`\n        Returns:\n            pd.DataFrame: Returns pandas dataframe with some refresh details\n        \"\"\"\nreturn self.Table.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.__init__","title":"<code>__init__(object, table)</code>","text":"<p>Extends from <code>PyObject</code> class.</p> <p>Adds a few custom rows to <code>rich</code> table for the partition.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Partition</code> <p>.Net Partition object.</p> required <code>table</code> <code>PyTable</code> <p>Parent table of the partition in question.</p> required Source code in <code>pytabular/partition.py</code> <pre><code>def __init__(self, object, table) -&gt; None:\n\"\"\"Extends from `PyObject` class.\n    Adds a few custom rows to `rich` table for the partition.\n    Args:\n        object (Partition): .Net Partition object.\n        table (PyTable): Parent table of the partition in question.\n    \"\"\"\nsuper().__init__(object)\nself.Table = table\nself._display.add_row(\"Mode\", str(self._object.Mode))\nself._display.add_row(\"State\", str(self._object.State))\nself._display.add_row(\n\"SourceType\", str(self._object.SourceType), end_section=True\n)\nself._display.add_row(\n\"RefreshedTime\", self.last_refresh().strftime(\"%m/%d/%Y, %H:%M:%S\")\n)\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.last_refresh","title":"<code>last_refresh()</code>","text":"<p>Queries <code>RefreshedTime</code> attribute in the partition.</p> <p>Converts from C# Ticks to Python datetime.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: Last Refreshed time of Partition in datetime format</p> Source code in <code>pytabular/partition.py</code> <pre><code>def last_refresh(self) -&gt; datetime:\n\"\"\"Queries `RefreshedTime` attribute in the partition.\n    Converts from C# Ticks to Python datetime.\n    Returns:\n        datetime.datetime: Last Refreshed time of Partition in datetime format\n    \"\"\"\nreturn ticks_to_datetime(self.RefreshedTime.Ticks)\n</code></pre>"},{"location":"PyPartition/#pytabular.partition.PyPartition.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Same method from Model Refresh.</p> <p>You can pass through any extra parameters. For example: <code>Tabular().Tables['Table Name'].Partitions[0].refresh()</code></p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Returns pandas dataframe with some refresh details</p> Source code in <code>pytabular/partition.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Same method from Model Refresh.\n    You can pass through any extra parameters. For example:\n    `Tabular().Tables['Table Name'].Partitions[0].refresh()`\n    Returns:\n        pd.DataFrame: Returns pandas dataframe with some refresh details\n    \"\"\"\nreturn self.Table.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartitions/","title":"PyPartitions","text":"<p>         Bases: <code>PyObjects</code></p> <p>Groups together multiple partitions.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyPartitions</code> straight from model. For ex: <code>model.Partitions</code>. Or through individual tables <code>model.Tables[TABLE_NAME].Partitions</code>. You can even filter down with <code>.find()</code>. For example find partitions with <code>prev-year</code> in name. <code>model.Partitions.find('prev-year')</code>.</p> Source code in <code>pytabular/partition.py</code> <pre><code>class PyPartitions(PyObjects):\n\"\"\"Groups together multiple partitions.\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyPartitions` straight from model.\n    For ex: `model.Partitions`.\n    Or through individual tables `model.Tables[TABLE_NAME].Partitions`.\n    You can even filter down with `.find()`. For example find partitions with `prev-year` in name.\n    `model.Partitions.find('prev-year')`.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Extends through to `PyObjects`.\"\"\"\nsuper().__init__(objects)\ndef refresh(self, *args, **kwargs):\n\"\"\"Refreshes all `PyPartition`(s) in class.\"\"\"\nmodel = self[0].Table.Model\nreturn model.refresh(self, *args, **kwargs)\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n\"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n        Args:\n            objects (_type_): _description_\n        \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\ndef __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\ndef __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\nreturn len(self._objects)\ndef __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\ndef find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n        It is case insensitive.\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyPartitions/#pytabular.partition.PyPartitions.__init__","title":"<code>__init__(objects)</code>","text":"<p>Extends through to <code>PyObjects</code>.</p> Source code in <code>pytabular/partition.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n\"\"\"Extends through to `PyObjects`.\"\"\"\nsuper().__init__(objects)\n</code></pre>"},{"location":"PyPartitions/#pytabular.partition.PyPartitions.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Refreshes all <code>PyPartition</code>(s) in class.</p> Source code in <code>pytabular/partition.py</code> <pre><code>def refresh(self, *args, **kwargs):\n\"\"\"Refreshes all `PyPartition`(s) in class.\"\"\"\nmodel = self[0].Table.Model\nreturn model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyPartitions/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>object.PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n    It is case insensitive.\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyTable/","title":"PyTable","text":"<p>         Bases: <code>PyObject</code></p> <p>The main PyTable class to interact with the tables in model.</p> <p>Notice the <code>PyObject</code> magic method <code>__getattr__()</code> will search in <code>self._object</code> if it is unable to find it in the default attributes. This let's you also easily check the default .Net properties.</p> Source code in <code>pytabular/table.py</code> <pre><code>class PyTable(PyObject):\n\"\"\"The main PyTable class to interact with the tables in model.\n    Notice the `PyObject` magic method `__getattr__()` will search in `self._object`\n    if it is unable to find it in the default attributes.\n    This let's you also easily check the default .Net properties.\n    \"\"\"\ndef __init__(self, object, model) -&gt; None:\n\"\"\"Init extends from `PyObject` class.\n        Also adds a few specific rows to the `rich`\n        table.\n        Args:\n            object (Table): The actual .Net table.\n            model (Tabular): The model that the table is in.\n        \"\"\"\nsuper().__init__(object)\nself.Model = model\nself.Partitions = PyPartitions(\n[\nPyPartition(partition, self)\nfor partition in self._object.Partitions.GetEnumerator()\n]\n)\nself.Columns = PyColumns(\n[PyColumn(column, self) for column in self._object.Columns.GetEnumerator()]\n)\nself.Measures = PyMeasures(\n[\nPyMeasure(measure, self)\nfor measure in self._object.Measures.GetEnumerator()\n]\n)\nself._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\nself._display.add_row(\"# of Columns\", str(len(self.Columns)))\nself._display.add_row(\n\"# of Measures\", str(len(self.Measures)), end_section=True\n)\nself._display.add_row(\"Description\", self._object.Description, end_section=True)\nself._display.add_row(\"DataCategory\", str(self._object.DataCategory))\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"IsPrivate\", str(self._object.IsPrivate))\nself._display.add_row(\n\"ModifiedTime\",\nticks_to_datetime(self._object.ModifiedTime.Ticks).strftime(\n\"%m/%d/%Y, %H:%M:%S\"\n),\n)\ndef row_count(self) -&gt; int:\n\"\"\"Method to return count of rows.\n        Simple Dax Query: `EVALUATE {COUNTROWS('Table Name')}`.\n        Returns:\n            int: Number of rows using `COUNTROWS`.\n        \"\"\"\nreturn self.Model.Adomd.query(f\"EVALUATE {{COUNTROWS('{self.Name}')}}\")\ndef refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Use this to refresh the PyTable in question.\n        You can pass through any extra parameters. For example:\n        `Tabular().Tables['Table Name'].Refresh(trace = None)`\n        Returns:\n            pd.DataFrame: Returns pandas dataframe with some refresh details.\n        \"\"\"\nreturn self.Model.refresh(self, *args, **kwargs)\ndef last_refresh(self) -&gt; datetime:\n\"\"\"Will query each partition for the last refresh time.\n        Then will select the max value to return.\n        Returns:\n            datetime: Last refresh time in datetime format\n        \"\"\"\npartition_refreshes = [\npartition.last_refresh() for partition in self.Partitions\n]\nreturn max(partition_refreshes)\ndef related(self):\n\"\"\"Returns tables with a relationship with the table in question.\"\"\"\nreturn self.Model.Relationships.related(self)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.__init__","title":"<code>__init__(object, model)</code>","text":"<p>Init extends from <code>PyObject</code> class.</p> <p>Also adds a few specific rows to the <code>rich</code> table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>Table</code> <p>The actual .Net table.</p> required <code>model</code> <code>Tabular</code> <p>The model that the table is in.</p> required Source code in <code>pytabular/table.py</code> <pre><code>def __init__(self, object, model) -&gt; None:\n\"\"\"Init extends from `PyObject` class.\n    Also adds a few specific rows to the `rich`\n    table.\n    Args:\n        object (Table): The actual .Net table.\n        model (Tabular): The model that the table is in.\n    \"\"\"\nsuper().__init__(object)\nself.Model = model\nself.Partitions = PyPartitions(\n[\nPyPartition(partition, self)\nfor partition in self._object.Partitions.GetEnumerator()\n]\n)\nself.Columns = PyColumns(\n[PyColumn(column, self) for column in self._object.Columns.GetEnumerator()]\n)\nself.Measures = PyMeasures(\n[\nPyMeasure(measure, self)\nfor measure in self._object.Measures.GetEnumerator()\n]\n)\nself._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\nself._display.add_row(\"# of Columns\", str(len(self.Columns)))\nself._display.add_row(\n\"# of Measures\", str(len(self.Measures)), end_section=True\n)\nself._display.add_row(\"Description\", self._object.Description, end_section=True)\nself._display.add_row(\"DataCategory\", str(self._object.DataCategory))\nself._display.add_row(\"IsHidden\", str(self._object.IsHidden))\nself._display.add_row(\"IsPrivate\", str(self._object.IsPrivate))\nself._display.add_row(\n\"ModifiedTime\",\nticks_to_datetime(self._object.ModifiedTime.Ticks).strftime(\n\"%m/%d/%Y, %H:%M:%S\"\n),\n)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.row_count","title":"<code>row_count()</code>","text":"<p>Method to return count of rows.</p> <p>Simple Dax Query: <code>EVALUATE {COUNTROWS('Table Name')}</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of rows using <code>COUNTROWS</code>.</p> Source code in <code>pytabular/table.py</code> <pre><code>def row_count(self) -&gt; int:\n\"\"\"Method to return count of rows.\n    Simple Dax Query: `EVALUATE {COUNTROWS('Table Name')}`.\n    Returns:\n        int: Number of rows using `COUNTROWS`.\n    \"\"\"\nreturn self.Model.Adomd.query(f\"EVALUATE {{COUNTROWS('{self.Name}')}}\")\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Use this to refresh the PyTable in question.</p> <p>You can pass through any extra parameters. For example: <code>Tabular().Tables['Table Name'].Refresh(trace = None)</code></p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Returns pandas dataframe with some refresh details.</p> Source code in <code>pytabular/table.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"Use this to refresh the PyTable in question.\n    You can pass through any extra parameters. For example:\n    `Tabular().Tables['Table Name'].Refresh(trace = None)`\n    Returns:\n        pd.DataFrame: Returns pandas dataframe with some refresh details.\n    \"\"\"\nreturn self.Model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.last_refresh","title":"<code>last_refresh()</code>","text":"<p>Will query each partition for the last refresh time.</p> <p>Then will select the max value to return.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Last refresh time in datetime format</p> Source code in <code>pytabular/table.py</code> <pre><code>def last_refresh(self) -&gt; datetime:\n\"\"\"Will query each partition for the last refresh time.\n    Then will select the max value to return.\n    Returns:\n        datetime: Last refresh time in datetime format\n    \"\"\"\npartition_refreshes = [\npartition.last_refresh() for partition in self.Partitions\n]\nreturn max(partition_refreshes)\n</code></pre>"},{"location":"PyTable/#pytabular.table.PyTable.related","title":"<code>related()</code>","text":"<p>Returns tables with a relationship with the table in question.</p> Source code in <code>pytabular/table.py</code> <pre><code>def related(self):\n\"\"\"Returns tables with a relationship with the table in question.\"\"\"\nreturn self.Model.Relationships.related(self)\n</code></pre>"},{"location":"PyTables/","title":"PyTables","text":"<p>         Bases: <code>PyObjects</code></p> <p>Groups together multiple tables.</p> <p>See <code>PyObjects</code> class for what more it can do. You can interact with <code>PyTables</code> straight from model. For ex: <code>model.Tables</code>. You can even filter down with <code>.Find()</code>. For example find all tables with <code>fact</code> in name. <code>model.Tables.Find('fact')</code>.</p> Source code in <code>pytabular/table.py</code> <pre><code>class PyTables(PyObjects):\n\"\"\"Groups together multiple tables.\n    See `PyObjects` class for what more it can do.\n    You can interact with `PyTables` straight from model. For ex: `model.Tables`.\n    You can even filter down with `.Find()`.\n    For example find all tables with `fact` in name.\n    `model.Tables.Find('fact')`.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Init just extends from the main `PyObjects` class.\"\"\"\nsuper().__init__(objects)\ndef refresh(self, *args, **kwargs):\n\"\"\"Refreshes all `PyTable`(s) in class.\"\"\"\nmodel = self._objects[0].Model\nreturn model.refresh(self, *args, **kwargs)\ndef query_all(self, query_function: str = \"COUNTROWS(_)\") -&gt; pd.DataFrame:\n\"\"\"Dynamically query all tables.\n        It will replace the `_` with the `query_function` arg\n        to build out the query to run.\n        Args:\n                query_function (str, optional): Dax query is\n                        dynamically building a query with the\n                        `UNION` &amp; `ROW` DAX Functions. Defaults to 'COUNTROWS(_)'.\n        Returns:\n                pd.DataFrame: Returns dataframe with results\n        \"\"\"\nlogger.info(\"Querying every table in PyTables...\")\nlogger.debug(f\"Function to be run: {query_function}\")\nlogger.debug(\"Dynamically creating DAX query...\")\nquery_str = \"EVALUATE UNION(\\n\"\nfor table in self:\ntable_name = table.get_Name()\ndax_table_identifier = f\"'{table_name}'\"\nquery_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\"{query_function}\\\",\\\n{query_function.replace('_',dax_table_identifier)}),\\n\"\nquery_str = f\"{query_str[:-2]})\"\nreturn self[0].Model.query(query_str)\ndef find_zero_rows(self):\n\"\"\"Returns PyTables class of tables with zero rows queried.\"\"\"\nquery_function: str = \"COUNTROWS(_)\"\ndf = self.query_all(query_function)\ntable_names = df[df[f\"[{query_function}]\"].isna()][\"[Table]\"].to_list()\nlogger.debug(f\"Found {table_names}\")\ntables = [self[name] for name in table_names]\nreturn self.__class__(tables)\ndef last_refresh(self, group_partition: bool = True) -&gt; pd.DataFrame:\n\"\"\"Returns `pd.DataFrame` of tables with their latest refresh time.\n        Optional 'group_partition' variable, default is True.\n        If False an extra column will be include to\n        have the last refresh time to the grain of the partition\n        Example to add to model\n        `model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')`.\n        Args:\n                group_partition (bool, optional): Whether or not you want\n                        the grain of the dataframe to be by table or by partition.\n                        Defaults to True.\n        Returns:\n                pd.DataFrame: pd dataframe with the RefreshedTime property\n                        If group_partition == True and the table has\n                        multiple partitions, then df.groupby(by[\"tables\"]).max()\n        \"\"\"\ndata = {\n\"Tables\": [\npartition.Table.Name for table in self for partition in table.Partitions\n],\n\"Partitions\": [\npartition.Name for table in self for partition in table.Partitions\n],\n\"RefreshedTime\": [\npartition.last_refresh()\nfor table in self\nfor partition in table.Partitions\n],\n}\ndf = pd.DataFrame(data)\nif group_partition:\nlogger.debug(\"Grouping together to grain of Table\")\nreturn (\ndf[[\"Tables\", \"RefreshedTime\"]]\n.groupby(by=[\"Tables\"])\n.max()\n.reset_index(drop=False)\n)\nelse:\nlogger.debug(\"Returning DF\")\nreturn df\n</code></pre> <p>The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).</p> <p>Notice the magic methods. <code>__rich_repr__()</code> starts the baseline for displaying your model. It uses the amazing <code>rich</code> python package and builds your display from the <code>self._display</code>. Still building out the magic methods to give <code>PyObjects</code> more flexibility.</p> Source code in <code>pytabular/object.py</code> <pre><code>class PyObjects:\n\"\"\"The main parent class for grouping your (Tables, Columns, Measures, Partitions, etc.).\n    Notice the magic methods. `__rich_repr__()` starts the baseline for displaying your model.\n    It uses the amazing `rich` python package and\n    builds your display from the `self._display`.\n    Still building out the magic methods to give `PyObjects` more flexibility.\n    \"\"\"\ndef __init__(self, objects) -&gt; None:\n\"\"\"Initialization of `PyObjects`.\n        Takes the objects in something that is iterable.\n        Then will build a default `rich` table display.\n        Args:\n            objects (_type_): _description_\n        \"\"\"\nself._objects = objects\nself._display = Table(title=str(self.__class__.mro()[0]))\nfor index, obj in enumerate(self._objects):\nself._display.add_row(str(index), obj.Name)\ndef __rich_repr__(self) -&gt; str:\n\"\"\"See [Rich Repr](https://rich.readthedocs.io/en/stable/pretty.html#rich-repr-protocol).\"\"\"\nConsole().print(self._display)\ndef __getitem__(self, object):\n\"\"\"Get item from `PyObjects`.\n        Checks if item is str or int.\n        If string will iterate through and try to find matching name.\n        Otherwise, will call into `self._objects[int]` to retrieve item.\n        \"\"\"\nif isinstance(object, str):\nreturn [pyobject for pyobject in self._objects if object == pyobject.Name][\n-1\n]\nelse:\nreturn self._objects[object]\ndef __iter__(self):\n\"\"\"Iterate through `PyObjects`.\"\"\"\nyield from self._objects\ndef __len__(self) -&gt; int:\n\"\"\"Get length of `PyObjects`.\n        Returns:\n            int: Number of PyObject in PyObjects\n        \"\"\"\nreturn len(self._objects)\ndef __iadd__(self, obj):\n\"\"\"Add a `PyObject` or `PyObjects` to your current `PyObjects` class.\n        This is useful for building out a custom `PyObjects` class to work with.\n        \"\"\"\nif isinstance(obj, Iterable):\nself._objects.__iadd__(obj._objects)\nelse:\nself._objects.__iadd__([obj])\nself.__init__(self._objects)\nreturn self\ndef find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n        It is case insensitive.\n        Args:\n            object_str (str): str to lookup in `PyObjects`\n        Returns:\n            PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n                where the `PyObject.Name` matches `object_str`.\n        \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.__init__","title":"<code>__init__(objects)</code>","text":"<p>Init just extends from the main <code>PyObjects</code> class.</p> Source code in <code>pytabular/table.py</code> <pre><code>def __init__(self, objects) -&gt; None:\n\"\"\"Init just extends from the main `PyObjects` class.\"\"\"\nsuper().__init__(objects)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p>Refreshes all <code>PyTable</code>(s) in class.</p> Source code in <code>pytabular/table.py</code> <pre><code>def refresh(self, *args, **kwargs):\n\"\"\"Refreshes all `PyTable`(s) in class.\"\"\"\nmodel = self._objects[0].Model\nreturn model.refresh(self, *args, **kwargs)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.query_all","title":"<code>query_all(query_function='COUNTROWS(_)')</code>","text":"<p>Dynamically query all tables.</p> <p>It will replace the <code>_</code> with the <code>query_function</code> arg to build out the query to run.</p> <p>Parameters:</p> Name Type Description Default <code>query_function</code> <code>str</code> <p>Dax query is dynamically building a query with the <code>UNION</code> &amp; <code>ROW</code> DAX Functions. Defaults to 'COUNTROWS(_)'.</p> <code>'COUNTROWS(_)'</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: Returns dataframe with results</p> Source code in <code>pytabular/table.py</code> <pre><code>def query_all(self, query_function: str = \"COUNTROWS(_)\") -&gt; pd.DataFrame:\n\"\"\"Dynamically query all tables.\n    It will replace the `_` with the `query_function` arg\n    to build out the query to run.\n    Args:\n            query_function (str, optional): Dax query is\n                    dynamically building a query with the\n                    `UNION` &amp; `ROW` DAX Functions. Defaults to 'COUNTROWS(_)'.\n    Returns:\n            pd.DataFrame: Returns dataframe with results\n    \"\"\"\nlogger.info(\"Querying every table in PyTables...\")\nlogger.debug(f\"Function to be run: {query_function}\")\nlogger.debug(\"Dynamically creating DAX query...\")\nquery_str = \"EVALUATE UNION(\\n\"\nfor table in self:\ntable_name = table.get_Name()\ndax_table_identifier = f\"'{table_name}'\"\nquery_str += f\"ROW(\\\"Table\\\",\\\"{table_name}\\\",\\\"{query_function}\\\",\\\n{query_function.replace('_',dax_table_identifier)}),\\n\"\nquery_str = f\"{query_str[:-2]})\"\nreturn self[0].Model.query(query_str)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.find_zero_rows","title":"<code>find_zero_rows()</code>","text":"<p>Returns PyTables class of tables with zero rows queried.</p> Source code in <code>pytabular/table.py</code> <pre><code>def find_zero_rows(self):\n\"\"\"Returns PyTables class of tables with zero rows queried.\"\"\"\nquery_function: str = \"COUNTROWS(_)\"\ndf = self.query_all(query_function)\ntable_names = df[df[f\"[{query_function}]\"].isna()][\"[Table]\"].to_list()\nlogger.debug(f\"Found {table_names}\")\ntables = [self[name] for name in table_names]\nreturn self.__class__(tables)\n</code></pre>"},{"location":"PyTables/#pytabular.table.PyTables.last_refresh","title":"<code>last_refresh(group_partition=True)</code>","text":"<p>Returns <code>pd.DataFrame</code> of tables with their latest refresh time.</p> <p>Optional 'group_partition' variable, default is True. If False an extra column will be include to have the last refresh time to the grain of the partition Example to add to model <code>model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_partition</code> <code>bool</code> <p>Whether or not you want the grain of the dataframe to be by table or by partition. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: pd dataframe with the RefreshedTime property If group_partition == True and the table has multiple partitions, then df.groupby(by[\"tables\"]).max()</p> Source code in <code>pytabular/table.py</code> <pre><code>def last_refresh(self, group_partition: bool = True) -&gt; pd.DataFrame:\n\"\"\"Returns `pd.DataFrame` of tables with their latest refresh time.\n    Optional 'group_partition' variable, default is True.\n    If False an extra column will be include to\n    have the last refresh time to the grain of the partition\n    Example to add to model\n    `model.Create_Table(p.Table_Last_Refresh_Times(model),'RefreshTimes')`.\n    Args:\n            group_partition (bool, optional): Whether or not you want\n                    the grain of the dataframe to be by table or by partition.\n                    Defaults to True.\n    Returns:\n            pd.DataFrame: pd dataframe with the RefreshedTime property\n                    If group_partition == True and the table has\n                    multiple partitions, then df.groupby(by[\"tables\"]).max()\n    \"\"\"\ndata = {\n\"Tables\": [\npartition.Table.Name for table in self for partition in table.Partitions\n],\n\"Partitions\": [\npartition.Name for table in self for partition in table.Partitions\n],\n\"RefreshedTime\": [\npartition.last_refresh()\nfor table in self\nfor partition in table.Partitions\n],\n}\ndf = pd.DataFrame(data)\nif group_partition:\nlogger.debug(\"Grouping together to grain of Table\")\nreturn (\ndf[[\"Tables\", \"RefreshedTime\"]]\n.groupby(by=[\"Tables\"])\n.max()\n.reset_index(drop=False)\n)\nelse:\nlogger.debug(\"Returning DF\")\nreturn df\n</code></pre>"},{"location":"PyTables/#pytabular.object.PyObjects.find","title":"<code>find(object_str)</code>","text":"<p>Finds any or all <code>PyObject</code> inside of <code>PyObjects</code> that match the <code>object_str</code>.</p> <p>It is case insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>object_str</code> <code>str</code> <p>str to lookup in <code>PyObjects</code></p> required <p>Returns:</p> Name Type Description <code>PyObjects</code> <code>object.PyObjects</code> <p>Returns a <code>PyObjects</code> class with all <code>PyObject</code> where the <code>PyObject.Name</code> matches <code>object_str</code>.</p> Source code in <code>pytabular/object.py</code> <pre><code>def find(self, object_str: str):\n\"\"\"Finds any or all `PyObject` inside of `PyObjects` that match the `object_str`.\n    It is case insensitive.\n    Args:\n        object_str (str): str to lookup in `PyObjects`\n    Returns:\n        PyObjects (object.PyObjects): Returns a `PyObjects` class with all `PyObject`\n            where the `PyObject.Name` matches `object_str`.\n    \"\"\"\nitems = [\nobject\nfor object in self._objects\nif object_str.lower() in object.Name.lower()\n]\nreturn self.__class__.mro()[0](items)\n</code></pre>"},{"location":"Tabular/","title":"Main Tabular Class","text":"<p>         Bases: <code>PyObject</code></p> <p>Tabular Class to perform operations.</p> <p>This is the main class to work with in PyTabular. You can connect to the other classes via the supplied attributes.</p> <p>Parameters:</p> Name Type Description Default <code>connection_str</code> <code>str</code> <p>Need a valid connection string: link</p> required <p>Attributes:</p> Name Type Description <code>AdomdConnection</code> <code>Connection</code> <p>For querying. This is the <code>Connection</code> class.</p> <code>Tables</code> <code>PyTables</code> <p>See <code>PyTables</code> for more information. Iterate through your tables in your model.</p> <code>Columns</code> <code>PyColumns</code> <p>See <code>PyColumns</code> for more information.</p> <code>Partitions</code> <code>PyPartitions</code> <p>See <code>PyPartitions</code> for more information.</p> <code>Measures</code> <code>PyMeasures</code> <p>See <code>PyMeasures</code> for more information.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>class Tabular(PyObject):\n\"\"\"Tabular Class to perform operations.\n    This is the main class to work with in PyTabular.\n    You can connect to the other classes via the supplied attributes.\n    Args:\n            connection_str (str): Need a valid connection string:\n                    [link](https://learn.microsoft.com/en-us/analysis-services/instances/connection-string-properties-analysis-services)\n    Attributes:\n            AdomdConnection (Connection): For querying.\n                    This is the `Connection` class.\n            Tables (PyTables): See `PyTables` for more information.\n                    Iterate through your tables in your model.\n            Columns (PyColumns): See `PyColumns` for more information.\n            Partitions (PyPartitions): See `PyPartitions` for more information.\n            Measures (PyMeasures): See `PyMeasures` for more information.\n    \"\"\"\ndef __init__(self, connection_str: str):\n\"\"\"Connect to model. Just supply a solid connection string.\"\"\"\n# Connecting to model...\nlogger.debug(\"Initializing Tabular Class\")\nself.Server = Server()\nself.Server.Connect(connection_str)\nlogger.info(f\"Connected to Server - {self.Server.Name}\")\nself.Catalog = self.Server.ConnectionInfo.Catalog\nlogger.debug(f\"Received Catalog - {self.Catalog}\")\ntry:\nself.Database = [\ndatabase\nfor database in self.Server.Databases.GetEnumerator()\nif database.Name == self.Catalog or self.Catalog is None\n][0]\nexcept Exception:\nerr_msg = f\"Unable to find Database... {self.Catalog}\"\nlogger.error(err_msg)\nraise Exception(err_msg)\nlogger.info(f\"Connected to Database - {self.Database.Name}\")\nself.CompatibilityLevel: int = self.Database.CompatibilityLevel\nself.CompatibilityMode: int = self.Database.CompatibilityMode.value__\nself.Model = self.Database.Model\nlogger.info(f\"Connected to Model - {self.Model.Name}\")\nself.Adomd: Connection = Connection(self.Server)\nself.effective_users: dict = {}\nself.PyRefresh = PyRefresh\n# Build PyObjects\nself.reload_model_info()\n# Run subclass init\nsuper().__init__(self.Model)\n# Building rich table display for repr\nself._display.add_row(\n\"EstimatedSize\",\nf\"{round(self.Database.EstimatedSize / 1000000000, 2)} GB\",\nend_section=True,\n)\nself._display.add_row(\"# of Tables\", str(len(self.Tables)))\nself._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\nself._display.add_row(\"# of Columns\", str(len(self.Columns)))\nself._display.add_row(\n\"# of Measures\", str(len(self.Measures)), end_section=True\n)\nself._display.add_row(\"Database\", self.Database.Name)\nself._display.add_row(\"Server\", self.Server.Name)\n# Finished and registering disconnect\nlogger.debug(\"Class Initialization Completed\")\nlogger.debug(\"Registering Disconnect on Termination...\")\natexit.register(self.disconnect)\ndef reload_model_info(self) -&gt; bool:\n\"\"\"Reload your model info into the `Tabular` class.\n        Should be called after any model changes.\n        Called in `save_changes()` and `__init__()`.\n        Returns:\n                bool: True if successful\n        \"\"\"\nself.Database.Refresh()\nself.Tables = PyTables(\n[PyTable(table, self) for table in self.Model.Tables.GetEnumerator()]\n)\nself.Relationships = PyRelationships(\n[\nPyRelationship(relationship, self)\nfor relationship in self.Model.Relationships.GetEnumerator()\n]\n)\nself.Partitions = PyPartitions(\n[partition for table in self.Tables for partition in table.Partitions]\n)\nself.Columns = PyColumns(\n[column for table in self.Tables for column in table.Columns]\n)\nself.Measures = PyMeasures(\n[measure for table in self.Tables for measure in table.Measures]\n)\nself.Cultures = PyCultures(\n[\nPyCulture(culture, self)\nfor culture in self.Model.Cultures.GetEnumerator()\n]\n)\nreturn True\ndef is_process(self) -&gt; bool:\n\"\"\"Run method to check if Processing is occurring.\n        Will query DMV `$SYSTEM.DISCOVER_JOBS`\n        to see if any processing is happening.\n        Returns:\n                bool: True if DMV shows Process, False if not.\n        \"\"\"\n_jobs_df = self.query(\"select * from $SYSTEM.DISCOVER_JOBS\")\nreturn len(_jobs_df[_jobs_df[\"JOB_DESCRIPTION\"] == \"Process\"]) &gt; 0\ndef disconnect(self) -&gt; None:\n\"\"\"Disconnects from Model.\"\"\"\nlogger.info(f\"Disconnecting from - {self.Server.Name}\")\natexit.unregister(self.disconnect)\nreturn self.Server.Disconnect()\ndef reconnect(self) -&gt; None:\n\"\"\"Reconnects to Model.\"\"\"\nlogger.info(f\"Reconnecting to {self.Server.Name}\")\nreturn self.Server.Reconnect()\ndef refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"`PyRefresh` class to handle refreshes of model.\n        See the `PyRefresh()` class for more details on what you can do with this.\n        \"\"\"\nreturn self.PyRefresh(self, *args, **kwargs).run()\ndef save_changes(self):\n\"\"\"Called after refreshes or any model changes.\n        Currently will return a named tuple of all changes detected.\n        A ton of room for improvement on what gets returned here.\n        \"\"\"\nif self.Server.Connected is False:\nself.reconnect()\ndef property_changes(property_changes_var):\n\"\"\"Returns any property changes.\"\"\"\nproperty_change = namedtuple(\n\"property_change\",\n\"new_value object original_value property_name property_type\",\n)\nreturn [\nproperty_change(\nchange.NewValue,\nchange.Object,\nchange.OriginalValue,\nchange.PropertyName,\nchange.PropertyType,\n)\nfor change in property_changes_var.GetEnumerator()\n]\nlogger.info(\"Executing save_changes()...\")\nmodel_save_results = self.Model.SaveChanges()\nif isinstance(model_save_results.Impact, type(None)):\nlogger.warning(f\"No changes detected on save for {self.Server.Name}\")\nreturn None\nelse:\nproperty_changes_var = model_save_results.Impact.PropertyChanges\nadded_objects = model_save_results.Impact.AddedObjects\nadded_subtree_roots = model_save_results.Impact.AddedSubtreeRoots\nremoved_objects = model_save_results.Impact.RemovedObjects\nremoved_subtree_roots = model_save_results.Impact.RemovedSubtreeRoots\nxmla_results = model_save_results.XmlaResults\nchanges = namedtuple(\n\"changes\",\n\"property_changes added_objects added_subtree_roots \\\n                    removed_objects removed_subtree_Roots xmla_results\",\n)\n[\nproperty_changes(property_changes_var),\nadded_objects,\nadded_subtree_roots,\nremoved_objects,\nremoved_subtree_roots,\nxmla_results,\n]\nself.reload_model_info()\nreturn changes(\nproperty_changes(property_changes_var),\nadded_objects,\nadded_subtree_roots,\nremoved_objects,\nremoved_subtree_roots,\nxmla_results,\n)\ndef backup_table(self, table_str: str) -&gt; bool:\n\"\"\"Will be removed.\n        Used in conjunction with `revert_table()`.\n        \"\"\"\nlogger.info(\"Backup Beginning...\")\nlogger.debug(f\"Cloning {table_str}\")\ntable = self.Model.Tables.Find(table_str).Clone()\nlogger.info(\"Beginning Renames\")\ndef rename(items):\n\"\"\"Iterates through items and requests rename.\"\"\"\nfor item in items:\nitem.RequestRename(f\"{item.Name}_backup\")\nlogger.debug(f\"Renamed - {item.Name}\")\nlogger.info(\"Renaming Columns\")\nrename(table.Columns.GetEnumerator())\nlogger.info(\"Renaming Partitions\")\nrename(table.Partitions.GetEnumerator())\nlogger.info(\"Renaming Measures\")\nrename(table.Measures.GetEnumerator())\nlogger.info(\"Renaming Hierarchies\")\nrename(table.Hierarchies.GetEnumerator())\nlogger.info(\"Renaming Table\")\ntable.RequestRename(f\"{table.Name}_backup\")\nlogger.info(\"Adding Table to Model as backup\")\nself.Model.Tables.Add(table)\nlogger.info(\"Finding Necessary Relationships... Cloning...\")\nrelationships = [\nrelationship.Clone()\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\")\nor relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\")\n]\nlogger.info(\"Renaming Relationships\")\nrename(relationships)\nlogger.info(\"Switching Relationships to Clone Table &amp; Column\")\nfor relationship in relationships:\nlogger.debug(f\"Renaming - {relationship.Name}\")\nif relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\"):\nrelationship.set_ToColumn(\ntable.Columns.find(f\"{relationship.ToColumn.Name}_backup\")\n)\nelif relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\"):\nrelationship.set_FromColumn(\ntable.Columns.find(f\"{relationship.FromColumn.Name}_backup\")\n)\nlogger.debug(f\"Adding {relationship.Name} to {self.Model.Name}\")\nself.Model.Relationships.Add(relationship)\ndef clone_role_permissions():\n\"\"\"Clones the role permissions for table.\"\"\"\nlogger.info(\"Beginning to handle roles and permissions for table...\")\nlogger.debug(\"Finding Roles...\")\nroles = [\nrole\nfor role in self.Model.Roles.GetEnumerator()\nfor tablepermission in role.TablePermissions.GetEnumerator()\nif tablepermission.Name == table_str\n]\nfor role in roles:\nlogger.debug(f\"Role {role.Name} matched, looking into it...\")\nlogger.debug(\"Searching for table specific permissions\")\ntablepermissions = [\ntable.Clone()\nfor table in role.TablePermissions.GetEnumerator()\nif table.Name == table_str\n]\nfor tablepermission in tablepermissions:\nlogger.debug(\nf\"{tablepermission.Name} found... switching table to clone\"\n)\ntablepermission.set_Table(table)\nfor column in tablepermission.ColumnPermissions.GetEnumerator():\nlogger.debug(\nf\"Column - {column.Name} copying permissions to clone...\"\n)\ncolumn.set_Column(\nself.Model.Tables.find(table.Name).Columns.find(\nf\"{column.Name}_backup\"\n)\n)\nlogger.debug(f\"Adding {tablepermission.Name} to {role.Name}\")\nrole.TablePermissions.Add(tablepermission)\nreturn True\nclone_role_permissions()\nlogger.info(f\"Refreshing Clone... {table.Name}\")\nself.reload_model_info()\nself.refresh(table.Name, default_row_count_check=False)\nlogger.info(f\"Updating Model {self.Model.Name}\")\nself.save_changes()\nreturn True\ndef revert_table(self, table_str: str) -&gt; bool:\n\"\"\"Will be removed.\n        This is used in conjunction with `backup_table()`.\n        \"\"\"\nlogger.info(f\"Beginning Revert for {table_str}\")\nlogger.debug(f\"Finding original {table_str}\")\nmain = self.Tables.find(table_str)[0]._object\nlogger.debug(f\"Finding backup {table_str}\")\nbackup = self.Tables.find(f\"{table_str}_backup\")[0]._object\nlogger.debug(\"Finding original relationships\")\nmain_relationships = [\nrelationship\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == main.Name\nor relationship.FromTable.Name == main.Name\n]\nlogger.debug(\"Finding backup relationships\")\nbackup_relationships = [\nrelationship\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == backup.Name\nor relationship.FromTable.Name == backup.Name\n]\ndef remove_role_permissions():\n\"\"\"Removes role permissions from table.\"\"\"\nlogger.debug(\nf\"Finding table and column permission in roles to remove from {table_str}\"\n)\nroles = [\nrole\nfor role in self.Model.Roles.GetEnumerator()\nfor tablepermission in role.TablePermissions.GetEnumerator()\nif tablepermission.Name == table_str\n]\nfor role in roles:\nlogger.debug(f\"Role {role.Name} Found\")\ntablepermissions = [\ntable\nfor table in role.TablePermissions.GetEnumerator()\nif table.Name == table_str\n]\nfor tablepermission in tablepermissions:\nlogger.debug(f\"Removing {tablepermission.Name} from {role.Name}\")\nrole.TablePermissions.Remove(tablepermission)\nfor relationship in main_relationships:\nlogger.debug(\"Cleaning relationships...\")\nif relationship.ToTable.Name == main.Name:\nlogger.debug(f\"Removing {relationship.Name}\")\nself.Model.Relationships.Remove(relationship)\nelif relationship.FromTable.Name == main.Name:\nlogger.debug(f\"Removing {relationship.Name}\")\nself.Model.Relationships.Remove(relationship)\nlogger.debug(f\"Removing Original Table {main.Name}\")\nself.Model.Tables.Remove(main)\nremove_role_permissions()\ndef dename(items):\n\"\"\"Denames all items.\"\"\"\nfor item in items:\nlogger.debug(f\"Removing Suffix for {item.Name}\")\nitem.RequestRename(remove_suffix(item.Name, \"_backup\"))\nlogger.debug(f\"Saving Changes... for {item.Name}\")\nself.save_changes()\nlogger.info(\"Name changes for Columns...\")\ndename(\n[\ncolumn\nfor column in backup.Columns.GetEnumerator()\nif column.Type != ColumnType.RowNumber\n]\n)\nlogger.info(\"Name changes for Partitions...\")\ndename(backup.Partitions.GetEnumerator())\nlogger.info(\"Name changes for Measures...\")\ndename(backup.Measures.GetEnumerator())\nlogger.info(\"Name changes for Hierarchies...\")\ndename(backup.Hierarchies.GetEnumerator())\nlogger.info(\"Name changes for Relationships...\")\ndename(backup_relationships)\nlogger.info(\"Name changes for Backup Table...\")\nbackup.RequestRename(remove_suffix(backup.Name, \"_backup\"))\nself.save_changes()\nreturn True\ndef query(\nself, query_str: str, effective_user: str = None\n) -&gt; Union[pd.DataFrame, str, int]:\n\"\"\"Executes query on model.\n        See `Connection().query()` for details on execution.\n        Args:\n            query_str (str): Query string to execute.\n            effective_user (str, optional): Pass through an effective user\n                    if desired. It will create and store a new `Connection()` class if need,\n                    which will help with speed if looping through multiple users in a row.\n                    Defaults to None.\n        Returns:\n            Union[pd.DataFrame, str, int]: _description_\n        \"\"\"\nif effective_user is None:\nreturn self.Adomd.query(query_str)\ntry:\n# This needs a public model with effective users to properly test\nconn = self.effective_users[effective_user]\nlogger.debug(f\"Effective user found querying as... {effective_user}\")\nexcept Exception:\nlogger.info(f\"Creating new connection with {effective_user}\")\nconn = Connection(self.Server, effective_user=effective_user)\nself.effective_users[effective_user] = conn\nreturn conn.query(query_str)\ndef analyze_bpa(\nself, tabular_editor_exe: str, best_practice_analyzer: str\n) -&gt; List[str]:\n\"\"\"Takes your Tabular Model and performs TE2s BPA. Runs through Command line.\n        Nothing fancy hear. Really just a simple wrapper so you could\n        call BPA in the same python script.\n        Args:\n                tabular_editor_exe (str): TE2 Exe File path.\n                        Feel free to use class TE2().EXE_Path or provide your own.\n                best_practice_analyzer (str): BPA json file path.\n                        Feel free to use class BPA().Location or provide your own.\n        Returns:\n                List[str]: Assuming no failure,\n                        will return list of BPA violations.\n                        Else will return error from command line.\n        \"\"\"\nlogger.debug(\"Beginning request to talk with TE2 &amp; Find BPA...\")\nbim_file_location = f\"{os.getcwd()}\\\\Model.bim\"\natexit.register(remove_file, bim_file_location)\ncmd = f'{tabular_editor_exe} \"Provider=MSOLAP;\\\n{self.Adomd.ConnectionString}\" {self.Database.Name} -B \"{bim_file_location}\" \\\n            -A {best_practice_analyzer} -V/?'\nlogger.debug(\"Command Generated\")\nlogger.debug(\"Submitting Command...\")\nsp = subprocess.Popen(\ncmd,\nshell=True,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\nuniversal_newlines=True,\n)\nraw_output, error = sp.communicate()\nif len(error) &gt; 0:\nreturn error\nelse:\nreturn [\noutput for output in raw_output.split(\"\\n\") if \"violates rule\" in output\n]\ndef create_table(self, df: pd.DataFrame, table_name: str) -&gt; bool:\n\"\"\"Creates table from pd.DataFrame to a table in your model.\n        It will convert the dataframe to M-Partition logic via the M query table constructor.\n        Then will run a refresh and update model.\n        Has some obvious limitations right now, because\n        the datframe values are hard coded into M-Partition,\n        which means you could hit limits with the size of your table.\n        Args:\n                df (pd.DataFrame): DataFrame to add to model.\n                table_name (str): Name of the table.\n        Returns:\n                bool: True if successful\n        \"\"\"\nlogger.debug(f\"Beginning to create table for {table_name}...\")\nnew_table = Table()\nnew_table.RequestRename(table_name)\nlogger.debug(\"Sorting through columns...\")\ndf_column_names = df.columns\ndtype_conversion = pandas_datatype_to_tabular_datatype(df)\nfor df_column_name in df_column_names:\nlogger.debug(f\"Adding {df_column_name} to Table...\")\ncolumn = DataColumn()\ncolumn.RequestRename(df_column_name)\ncolumn.set_SourceColumn(df_column_name)\ncolumn.set_DataType(dtype_conversion[df_column_name])\nnew_table.Columns.Add(column)\nlogger.debug(\"Expression String Created...\")\nlogger.debug(\"Creating MPartition...\")\npartition = Partition()\npartition.set_Source(MPartitionSource())\nlogger.debug(\"Setting MPartition Expression...\")\npartition.Source.set_Expression(pd_dataframe_to_m_expression(df))\nlogger.debug(\nf\"Adding partition: {partition.Name} to {self.Server.Name}\\\n                ::{self.Database.Name}::{self.Model.Name}\"\n)\nnew_table.Partitions.Add(partition)\nlogger.debug(\nf\"Adding table: {new_table.Name} to {self.Server.Name}\\\n                ::{self.Database.Name}::{self.Model.Name}\"\n)\nself.Model.Tables.Add(new_table)\nself.save_changes()\nself.reload_model_info()\nself.refresh(new_table.Name)\nreturn True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.__init__","title":"<code>__init__(connection_str)</code>","text":"<p>Connect to model. Just supply a solid connection string.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def __init__(self, connection_str: str):\n\"\"\"Connect to model. Just supply a solid connection string.\"\"\"\n# Connecting to model...\nlogger.debug(\"Initializing Tabular Class\")\nself.Server = Server()\nself.Server.Connect(connection_str)\nlogger.info(f\"Connected to Server - {self.Server.Name}\")\nself.Catalog = self.Server.ConnectionInfo.Catalog\nlogger.debug(f\"Received Catalog - {self.Catalog}\")\ntry:\nself.Database = [\ndatabase\nfor database in self.Server.Databases.GetEnumerator()\nif database.Name == self.Catalog or self.Catalog is None\n][0]\nexcept Exception:\nerr_msg = f\"Unable to find Database... {self.Catalog}\"\nlogger.error(err_msg)\nraise Exception(err_msg)\nlogger.info(f\"Connected to Database - {self.Database.Name}\")\nself.CompatibilityLevel: int = self.Database.CompatibilityLevel\nself.CompatibilityMode: int = self.Database.CompatibilityMode.value__\nself.Model = self.Database.Model\nlogger.info(f\"Connected to Model - {self.Model.Name}\")\nself.Adomd: Connection = Connection(self.Server)\nself.effective_users: dict = {}\nself.PyRefresh = PyRefresh\n# Build PyObjects\nself.reload_model_info()\n# Run subclass init\nsuper().__init__(self.Model)\n# Building rich table display for repr\nself._display.add_row(\n\"EstimatedSize\",\nf\"{round(self.Database.EstimatedSize / 1000000000, 2)} GB\",\nend_section=True,\n)\nself._display.add_row(\"# of Tables\", str(len(self.Tables)))\nself._display.add_row(\"# of Partitions\", str(len(self.Partitions)))\nself._display.add_row(\"# of Columns\", str(len(self.Columns)))\nself._display.add_row(\n\"# of Measures\", str(len(self.Measures)), end_section=True\n)\nself._display.add_row(\"Database\", self.Database.Name)\nself._display.add_row(\"Server\", self.Server.Name)\n# Finished and registering disconnect\nlogger.debug(\"Class Initialization Completed\")\nlogger.debug(\"Registering Disconnect on Termination...\")\natexit.register(self.disconnect)\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.reload_model_info","title":"<code>reload_model_info()</code>","text":"<p>Reload your model info into the <code>Tabular</code> class.</p> <p>Should be called after any model changes. Called in <code>save_changes()</code> and <code>__init__()</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def reload_model_info(self) -&gt; bool:\n\"\"\"Reload your model info into the `Tabular` class.\n    Should be called after any model changes.\n    Called in `save_changes()` and `__init__()`.\n    Returns:\n            bool: True if successful\n    \"\"\"\nself.Database.Refresh()\nself.Tables = PyTables(\n[PyTable(table, self) for table in self.Model.Tables.GetEnumerator()]\n)\nself.Relationships = PyRelationships(\n[\nPyRelationship(relationship, self)\nfor relationship in self.Model.Relationships.GetEnumerator()\n]\n)\nself.Partitions = PyPartitions(\n[partition for table in self.Tables for partition in table.Partitions]\n)\nself.Columns = PyColumns(\n[column for table in self.Tables for column in table.Columns]\n)\nself.Measures = PyMeasures(\n[measure for table in self.Tables for measure in table.Measures]\n)\nself.Cultures = PyCultures(\n[\nPyCulture(culture, self)\nfor culture in self.Model.Cultures.GetEnumerator()\n]\n)\nreturn True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.is_process","title":"<code>is_process()</code>","text":"<p>Run method to check if Processing is occurring.</p> <p>Will query DMV <code>$SYSTEM.DISCOVER_JOBS</code> to see if any processing is happening.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if DMV shows Process, False if not.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def is_process(self) -&gt; bool:\n\"\"\"Run method to check if Processing is occurring.\n    Will query DMV `$SYSTEM.DISCOVER_JOBS`\n    to see if any processing is happening.\n    Returns:\n            bool: True if DMV shows Process, False if not.\n    \"\"\"\n_jobs_df = self.query(\"select * from $SYSTEM.DISCOVER_JOBS\")\nreturn len(_jobs_df[_jobs_df[\"JOB_DESCRIPTION\"] == \"Process\"]) &gt; 0\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects from Model.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def disconnect(self) -&gt; None:\n\"\"\"Disconnects from Model.\"\"\"\nlogger.info(f\"Disconnecting from - {self.Server.Name}\")\natexit.unregister(self.disconnect)\nreturn self.Server.Disconnect()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.reconnect","title":"<code>reconnect()</code>","text":"<p>Reconnects to Model.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def reconnect(self) -&gt; None:\n\"\"\"Reconnects to Model.\"\"\"\nlogger.info(f\"Reconnecting to {self.Server.Name}\")\nreturn self.Server.Reconnect()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.refresh","title":"<code>refresh(*args, **kwargs)</code>","text":"<p><code>PyRefresh</code> class to handle refreshes of model.</p> <p>See the <code>PyRefresh()</code> class for more details on what you can do with this.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def refresh(self, *args, **kwargs) -&gt; pd.DataFrame:\n\"\"\"`PyRefresh` class to handle refreshes of model.\n    See the `PyRefresh()` class for more details on what you can do with this.\n    \"\"\"\nreturn self.PyRefresh(self, *args, **kwargs).run()\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.save_changes","title":"<code>save_changes()</code>","text":"<p>Called after refreshes or any model changes.</p> <p>Currently will return a named tuple of all changes detected. A ton of room for improvement on what gets returned here.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def save_changes(self):\n\"\"\"Called after refreshes or any model changes.\n    Currently will return a named tuple of all changes detected.\n    A ton of room for improvement on what gets returned here.\n    \"\"\"\nif self.Server.Connected is False:\nself.reconnect()\ndef property_changes(property_changes_var):\n\"\"\"Returns any property changes.\"\"\"\nproperty_change = namedtuple(\n\"property_change\",\n\"new_value object original_value property_name property_type\",\n)\nreturn [\nproperty_change(\nchange.NewValue,\nchange.Object,\nchange.OriginalValue,\nchange.PropertyName,\nchange.PropertyType,\n)\nfor change in property_changes_var.GetEnumerator()\n]\nlogger.info(\"Executing save_changes()...\")\nmodel_save_results = self.Model.SaveChanges()\nif isinstance(model_save_results.Impact, type(None)):\nlogger.warning(f\"No changes detected on save for {self.Server.Name}\")\nreturn None\nelse:\nproperty_changes_var = model_save_results.Impact.PropertyChanges\nadded_objects = model_save_results.Impact.AddedObjects\nadded_subtree_roots = model_save_results.Impact.AddedSubtreeRoots\nremoved_objects = model_save_results.Impact.RemovedObjects\nremoved_subtree_roots = model_save_results.Impact.RemovedSubtreeRoots\nxmla_results = model_save_results.XmlaResults\nchanges = namedtuple(\n\"changes\",\n\"property_changes added_objects added_subtree_roots \\\n                removed_objects removed_subtree_Roots xmla_results\",\n)\n[\nproperty_changes(property_changes_var),\nadded_objects,\nadded_subtree_roots,\nremoved_objects,\nremoved_subtree_roots,\nxmla_results,\n]\nself.reload_model_info()\nreturn changes(\nproperty_changes(property_changes_var),\nadded_objects,\nadded_subtree_roots,\nremoved_objects,\nremoved_subtree_roots,\nxmla_results,\n)\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.backup_table","title":"<code>backup_table(table_str)</code>","text":"<p>Will be removed.</p> <p>Used in conjunction with <code>revert_table()</code>.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def backup_table(self, table_str: str) -&gt; bool:\n\"\"\"Will be removed.\n    Used in conjunction with `revert_table()`.\n    \"\"\"\nlogger.info(\"Backup Beginning...\")\nlogger.debug(f\"Cloning {table_str}\")\ntable = self.Model.Tables.Find(table_str).Clone()\nlogger.info(\"Beginning Renames\")\ndef rename(items):\n\"\"\"Iterates through items and requests rename.\"\"\"\nfor item in items:\nitem.RequestRename(f\"{item.Name}_backup\")\nlogger.debug(f\"Renamed - {item.Name}\")\nlogger.info(\"Renaming Columns\")\nrename(table.Columns.GetEnumerator())\nlogger.info(\"Renaming Partitions\")\nrename(table.Partitions.GetEnumerator())\nlogger.info(\"Renaming Measures\")\nrename(table.Measures.GetEnumerator())\nlogger.info(\"Renaming Hierarchies\")\nrename(table.Hierarchies.GetEnumerator())\nlogger.info(\"Renaming Table\")\ntable.RequestRename(f\"{table.Name}_backup\")\nlogger.info(\"Adding Table to Model as backup\")\nself.Model.Tables.Add(table)\nlogger.info(\"Finding Necessary Relationships... Cloning...\")\nrelationships = [\nrelationship.Clone()\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\")\nor relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\")\n]\nlogger.info(\"Renaming Relationships\")\nrename(relationships)\nlogger.info(\"Switching Relationships to Clone Table &amp; Column\")\nfor relationship in relationships:\nlogger.debug(f\"Renaming - {relationship.Name}\")\nif relationship.ToTable.Name == remove_suffix(table.Name, \"_backup\"):\nrelationship.set_ToColumn(\ntable.Columns.find(f\"{relationship.ToColumn.Name}_backup\")\n)\nelif relationship.FromTable.Name == remove_suffix(table.Name, \"_backup\"):\nrelationship.set_FromColumn(\ntable.Columns.find(f\"{relationship.FromColumn.Name}_backup\")\n)\nlogger.debug(f\"Adding {relationship.Name} to {self.Model.Name}\")\nself.Model.Relationships.Add(relationship)\ndef clone_role_permissions():\n\"\"\"Clones the role permissions for table.\"\"\"\nlogger.info(\"Beginning to handle roles and permissions for table...\")\nlogger.debug(\"Finding Roles...\")\nroles = [\nrole\nfor role in self.Model.Roles.GetEnumerator()\nfor tablepermission in role.TablePermissions.GetEnumerator()\nif tablepermission.Name == table_str\n]\nfor role in roles:\nlogger.debug(f\"Role {role.Name} matched, looking into it...\")\nlogger.debug(\"Searching for table specific permissions\")\ntablepermissions = [\ntable.Clone()\nfor table in role.TablePermissions.GetEnumerator()\nif table.Name == table_str\n]\nfor tablepermission in tablepermissions:\nlogger.debug(\nf\"{tablepermission.Name} found... switching table to clone\"\n)\ntablepermission.set_Table(table)\nfor column in tablepermission.ColumnPermissions.GetEnumerator():\nlogger.debug(\nf\"Column - {column.Name} copying permissions to clone...\"\n)\ncolumn.set_Column(\nself.Model.Tables.find(table.Name).Columns.find(\nf\"{column.Name}_backup\"\n)\n)\nlogger.debug(f\"Adding {tablepermission.Name} to {role.Name}\")\nrole.TablePermissions.Add(tablepermission)\nreturn True\nclone_role_permissions()\nlogger.info(f\"Refreshing Clone... {table.Name}\")\nself.reload_model_info()\nself.refresh(table.Name, default_row_count_check=False)\nlogger.info(f\"Updating Model {self.Model.Name}\")\nself.save_changes()\nreturn True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.revert_table","title":"<code>revert_table(table_str)</code>","text":"<p>Will be removed.</p> <p>This is used in conjunction with <code>backup_table()</code>.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def revert_table(self, table_str: str) -&gt; bool:\n\"\"\"Will be removed.\n    This is used in conjunction with `backup_table()`.\n    \"\"\"\nlogger.info(f\"Beginning Revert for {table_str}\")\nlogger.debug(f\"Finding original {table_str}\")\nmain = self.Tables.find(table_str)[0]._object\nlogger.debug(f\"Finding backup {table_str}\")\nbackup = self.Tables.find(f\"{table_str}_backup\")[0]._object\nlogger.debug(\"Finding original relationships\")\nmain_relationships = [\nrelationship\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == main.Name\nor relationship.FromTable.Name == main.Name\n]\nlogger.debug(\"Finding backup relationships\")\nbackup_relationships = [\nrelationship\nfor relationship in self.Model.Relationships.GetEnumerator()\nif relationship.ToTable.Name == backup.Name\nor relationship.FromTable.Name == backup.Name\n]\ndef remove_role_permissions():\n\"\"\"Removes role permissions from table.\"\"\"\nlogger.debug(\nf\"Finding table and column permission in roles to remove from {table_str}\"\n)\nroles = [\nrole\nfor role in self.Model.Roles.GetEnumerator()\nfor tablepermission in role.TablePermissions.GetEnumerator()\nif tablepermission.Name == table_str\n]\nfor role in roles:\nlogger.debug(f\"Role {role.Name} Found\")\ntablepermissions = [\ntable\nfor table in role.TablePermissions.GetEnumerator()\nif table.Name == table_str\n]\nfor tablepermission in tablepermissions:\nlogger.debug(f\"Removing {tablepermission.Name} from {role.Name}\")\nrole.TablePermissions.Remove(tablepermission)\nfor relationship in main_relationships:\nlogger.debug(\"Cleaning relationships...\")\nif relationship.ToTable.Name == main.Name:\nlogger.debug(f\"Removing {relationship.Name}\")\nself.Model.Relationships.Remove(relationship)\nelif relationship.FromTable.Name == main.Name:\nlogger.debug(f\"Removing {relationship.Name}\")\nself.Model.Relationships.Remove(relationship)\nlogger.debug(f\"Removing Original Table {main.Name}\")\nself.Model.Tables.Remove(main)\nremove_role_permissions()\ndef dename(items):\n\"\"\"Denames all items.\"\"\"\nfor item in items:\nlogger.debug(f\"Removing Suffix for {item.Name}\")\nitem.RequestRename(remove_suffix(item.Name, \"_backup\"))\nlogger.debug(f\"Saving Changes... for {item.Name}\")\nself.save_changes()\nlogger.info(\"Name changes for Columns...\")\ndename(\n[\ncolumn\nfor column in backup.Columns.GetEnumerator()\nif column.Type != ColumnType.RowNumber\n]\n)\nlogger.info(\"Name changes for Partitions...\")\ndename(backup.Partitions.GetEnumerator())\nlogger.info(\"Name changes for Measures...\")\ndename(backup.Measures.GetEnumerator())\nlogger.info(\"Name changes for Hierarchies...\")\ndename(backup.Hierarchies.GetEnumerator())\nlogger.info(\"Name changes for Relationships...\")\ndename(backup_relationships)\nlogger.info(\"Name changes for Backup Table...\")\nbackup.RequestRename(remove_suffix(backup.Name, \"_backup\"))\nself.save_changes()\nreturn True\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.query","title":"<code>query(query_str, effective_user=None)</code>","text":"<p>Executes query on model.</p> <p>See <code>Connection().query()</code> for details on execution.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>Query string to execute.</p> required <code>effective_user</code> <code>str</code> <p>Pass through an effective user     if desired. It will create and store a new <code>Connection()</code> class if need,     which will help with speed if looping through multiple users in a row.     Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, str, int]</code> <p>Union[pd.DataFrame, str, int]: description</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def query(\nself, query_str: str, effective_user: str = None\n) -&gt; Union[pd.DataFrame, str, int]:\n\"\"\"Executes query on model.\n    See `Connection().query()` for details on execution.\n    Args:\n        query_str (str): Query string to execute.\n        effective_user (str, optional): Pass through an effective user\n                if desired. It will create and store a new `Connection()` class if need,\n                which will help with speed if looping through multiple users in a row.\n                Defaults to None.\n    Returns:\n        Union[pd.DataFrame, str, int]: _description_\n    \"\"\"\nif effective_user is None:\nreturn self.Adomd.query(query_str)\ntry:\n# This needs a public model with effective users to properly test\nconn = self.effective_users[effective_user]\nlogger.debug(f\"Effective user found querying as... {effective_user}\")\nexcept Exception:\nlogger.info(f\"Creating new connection with {effective_user}\")\nconn = Connection(self.Server, effective_user=effective_user)\nself.effective_users[effective_user] = conn\nreturn conn.query(query_str)\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.analyze_bpa","title":"<code>analyze_bpa(tabular_editor_exe, best_practice_analyzer)</code>","text":"<p>Takes your Tabular Model and performs TE2s BPA. Runs through Command line.</p> <p>Nothing fancy hear. Really just a simple wrapper so you could call BPA in the same python script.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_editor_exe</code> <code>str</code> <p>TE2 Exe File path. Feel free to use class TE2().EXE_Path or provide your own.</p> required <code>best_practice_analyzer</code> <code>str</code> <p>BPA json file path. Feel free to use class BPA().Location or provide your own.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Assuming no failure, will return list of BPA violations. Else will return error from command line.</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def analyze_bpa(\nself, tabular_editor_exe: str, best_practice_analyzer: str\n) -&gt; List[str]:\n\"\"\"Takes your Tabular Model and performs TE2s BPA. Runs through Command line.\n    Nothing fancy hear. Really just a simple wrapper so you could\n    call BPA in the same python script.\n    Args:\n            tabular_editor_exe (str): TE2 Exe File path.\n                    Feel free to use class TE2().EXE_Path or provide your own.\n            best_practice_analyzer (str): BPA json file path.\n                    Feel free to use class BPA().Location or provide your own.\n    Returns:\n            List[str]: Assuming no failure,\n                    will return list of BPA violations.\n                    Else will return error from command line.\n    \"\"\"\nlogger.debug(\"Beginning request to talk with TE2 &amp; Find BPA...\")\nbim_file_location = f\"{os.getcwd()}\\\\Model.bim\"\natexit.register(remove_file, bim_file_location)\ncmd = f'{tabular_editor_exe} \"Provider=MSOLAP;\\\n{self.Adomd.ConnectionString}\" {self.Database.Name} -B \"{bim_file_location}\" \\\n        -A {best_practice_analyzer} -V/?'\nlogger.debug(\"Command Generated\")\nlogger.debug(\"Submitting Command...\")\nsp = subprocess.Popen(\ncmd,\nshell=True,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\nuniversal_newlines=True,\n)\nraw_output, error = sp.communicate()\nif len(error) &gt; 0:\nreturn error\nelse:\nreturn [\noutput for output in raw_output.split(\"\\n\") if \"violates rule\" in output\n]\n</code></pre>"},{"location":"Tabular/#pytabular.pytabular.Tabular.create_table","title":"<code>create_table(df, table_name)</code>","text":"<p>Creates table from pd.DataFrame to a table in your model.</p> <p>It will convert the dataframe to M-Partition logic via the M query table constructor. Then will run a refresh and update model. Has some obvious limitations right now, because the datframe values are hard coded into M-Partition, which means you could hit limits with the size of your table.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>DataFrame to add to model.</p> required <code>table_name</code> <code>str</code> <p>Name of the table.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/pytabular.py</code> <pre><code>def create_table(self, df: pd.DataFrame, table_name: str) -&gt; bool:\n\"\"\"Creates table from pd.DataFrame to a table in your model.\n    It will convert the dataframe to M-Partition logic via the M query table constructor.\n    Then will run a refresh and update model.\n    Has some obvious limitations right now, because\n    the datframe values are hard coded into M-Partition,\n    which means you could hit limits with the size of your table.\n    Args:\n            df (pd.DataFrame): DataFrame to add to model.\n            table_name (str): Name of the table.\n    Returns:\n            bool: True if successful\n    \"\"\"\nlogger.debug(f\"Beginning to create table for {table_name}...\")\nnew_table = Table()\nnew_table.RequestRename(table_name)\nlogger.debug(\"Sorting through columns...\")\ndf_column_names = df.columns\ndtype_conversion = pandas_datatype_to_tabular_datatype(df)\nfor df_column_name in df_column_names:\nlogger.debug(f\"Adding {df_column_name} to Table...\")\ncolumn = DataColumn()\ncolumn.RequestRename(df_column_name)\ncolumn.set_SourceColumn(df_column_name)\ncolumn.set_DataType(dtype_conversion[df_column_name])\nnew_table.Columns.Add(column)\nlogger.debug(\"Expression String Created...\")\nlogger.debug(\"Creating MPartition...\")\npartition = Partition()\npartition.set_Source(MPartitionSource())\nlogger.debug(\"Setting MPartition Expression...\")\npartition.Source.set_Expression(pd_dataframe_to_m_expression(df))\nlogger.debug(\nf\"Adding partition: {partition.Name} to {self.Server.Name}\\\n            ::{self.Database.Name}::{self.Model.Name}\"\n)\nnew_table.Partitions.Add(partition)\nlogger.debug(\nf\"Adding table: {new_table.Name} to {self.Server.Name}\\\n            ::{self.Database.Name}::{self.Model.Name}\"\n)\nself.Model.Tables.Add(new_table)\nself.save_changes()\nself.reload_model_info()\nself.refresh(new_table.Name)\nreturn True\n</code></pre>"},{"location":"best_practice_analyzer/","title":"best_practice_analyzer","text":"<p>This is currently just a POC. Handle all BPA related items.</p> <p>You can call the <code>BPA()</code> class to download or specify your own BPA file. It is used with tabular_editor.py to run BPA. I did not want to re-invent the wheel, so just letting TE2 work it's magic.</p>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.BPA","title":"<code>BPA</code>","text":"<p>Setting BPA Class for future work...</p> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>class BPA:\n\"\"\"Setting BPA Class for future work...\"\"\"\ndef __init__(self, file_path: str = \"Default\") -&gt; None:\n\"\"\"BPA class to be used with the TE2 class.\n        You can create the BPA class without any arguments.\n        This doesn't do much right now...\n        BPA().location is where the file path is stored.\n        Args:\n            file_path (str, optional): See `Download_BPA_File()`. Defaults to \"Default\".\n        \"\"\"\nlogger.debug(f\"Initializing BPA Class:: {file_path}\")\nif file_path == \"Default\":\nself.location: str = download_bpa_file()\nelse:\nself.location: str = file_path\npass\n</code></pre>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.BPA.__init__","title":"<code>__init__(file_path='Default')</code>","text":"<p>BPA class to be used with the TE2 class.</p> <p>You can create the BPA class without any arguments. This doesn't do much right now... BPA().location is where the file path is stored.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>See <code>Download_BPA_File()</code>. Defaults to \"Default\".</p> <code>'Default'</code> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>def __init__(self, file_path: str = \"Default\") -&gt; None:\n\"\"\"BPA class to be used with the TE2 class.\n    You can create the BPA class without any arguments.\n    This doesn't do much right now...\n    BPA().location is where the file path is stored.\n    Args:\n        file_path (str, optional): See `Download_BPA_File()`. Defaults to \"Default\".\n    \"\"\"\nlogger.debug(f\"Initializing BPA Class:: {file_path}\")\nif file_path == \"Default\":\nself.location: str = download_bpa_file()\nelse:\nself.location: str = file_path\npass\n</code></pre>"},{"location":"best_practice_analyzer/#pytabular.best_practice_analyzer.download_bpa_file","title":"<code>download_bpa_file(download_location='https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json', folder='Best_Practice_Analyzer', auto_remove=True)</code>","text":"<p>Download a BPA file from local or web.</p> <p>Runs a request.get() to retrieve the json file from web. Will return and store in directory. Will also register the removal of the new directory and file when exiting program.</p> <p>Parameters:</p> Name Type Description Default <code>download_location</code> <code>str</code> <p>Defaults to [BPA]'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'.</p> <code>'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'</code> <code>folder</code> <code>str</code> <p>New folder string. Defaults to 'Best_Practice_Analyzer'.</p> <code>'Best_Practice_Analyzer'</code> <code>auto_remove</code> <code>bool</code> <p>Auto Remove when script exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>File path for the newly downloaded BPA.</p> Source code in <code>pytabular/best_practice_analyzer.py</code> <pre><code>def download_bpa_file(\ndownload_location: str = (\n\"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\"  # noqa: E501\n),\nfolder: str = \"Best_Practice_Analyzer\",\nauto_remove=True,\n) -&gt; str:\n\"\"\"Download a BPA file from local or web.\n    Runs a request.get() to retrieve the json file from web.\n    Will return and store in directory.\n    Will also register the removal of the new directory and file when exiting program.\n    Args:\n            download_location (str, optional):  Defaults to\n                    [BPA]'https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json'.\n            folder (str, optional): New folder string.\n                    Defaults to 'Best_Practice_Analyzer'.\n            auto_remove (bool, optional): Auto Remove when script exits. Defaults to True.\n    Returns:\n            str: File path for the newly downloaded BPA.\n    \"\"\"\nlogger.info(f\"Downloading BPA from {download_location}\")\nfolder_location = os.path.join(os.getcwd(), folder)\nif os.path.exists(folder_location) is False:\nos.makedirs(folder_location)\nresponse = r.get(download_location)\nfile_location = os.path.join(folder_location, download_location.split(\"/\")[-1])\nwith open(file_location, \"w\", encoding=\"utf-8\") as bpa:\njson.dump(response.json(), bpa, ensure_ascii=False, indent=4)\nif auto_remove:\nlogger.debug(f\"Registering removal on termination... For {folder_location}\")\natexit.register(remove_folder_and_contents, folder_location)\nreturn file_location\n</code></pre>"},{"location":"document/","title":"Documenting Model","text":"<p><code>document.py</code> is where a specific part of pytabular start.</p> <p>This module can generate pages in markdown for use in Docusaurus.</p>"},{"location":"document/#pytabular.document.ModelDocumenter","title":"<code>ModelDocumenter</code>","text":"<p>The ModelDocumenter class can generate documentation.</p> <p>This is based on the tabular object model and it will generate it suitable for docusaurus. TODO: Add a General Pages template with Roles and RLS Expressions. TODO: Create a Sub Page per table for all columns, instead of one big page? TODO: Add Depencies per Measure with correct links.</p> Source code in <code>pytabular/document.py</code> <pre><code>class ModelDocumenter:\n\"\"\"The ModelDocumenter class can generate documentation.\n    This is based on the tabular object model and it will generate it suitable for docusaurus.\n    TODO: Add a General Pages template with Roles and RLS Expressions.\n    TODO: Create a Sub Page per table for all columns, instead of one big page?\n    TODO: Add Depencies per Measure with correct links.\n    \"\"\"\ndef __init__(\nself,\nmodel: Tabular,\nfriendly_name: str = str(),\nsave_location: str = \"docs\",\ngeneral_page_url: str = \"index.md\",\nmeasure_page_url: str = \"measures.md\",\nroles_page_url: str = \"roles.md\",\ntable_folder: str = \"tables\",\n# table_page_url: str = \"3-tables.md\",\n# column_page_url: str = \"4-columns.md\",\n):\n\"\"\"Init will set attributes based on arguments given.\n        See `generate_documentation_pages()` and `save_documentation()`\n        for info on how to execute and retrieve documentation.\n        Args:\n            model (Tabular): Main `Tabular()` class to pull metadata from for documentation.\n            friendly_name (str, optional): Replaces the model name to a friendly string,\n                so it can be used in an URL. Defaults to `str()`.\n            save_location (str, optional): The save location where the files will be stored.\n                Defaults to \"docs\".\n            general_page_url (str, optional): Name of the `md` file for general information.\n                Defaults to \"index.md\".\n            measure_page_url (str, optional): Name of the `md` file for measures.\n                Defaults to \"measures.md\".\n            table_folder (str, optional): Name of the folder where columns info is stored.\n                Defaults to \"table_folder\".\n            roles_page_url (str, optional): Name of the `md` file for roles.\n                Defaults to \"roles.md\".\n        \"\"\"\nself.model = model\nself.model_name = friendly_name or model.Catalog or model.Database.Name\nself.friendly_name: str = str()\nself.save_path: Path\nself.save_location: str = save_location\n# Translation information\nself.culture_include: bool = False\nself.culture_selected: str = \"en-US\"\nself.culture_object: PyCulture\n# Documentation Parts\nself.general_page: str = str()\nself.general_page_url: str = general_page_url\nself.measure_page: str = str()\nself.measure_page_url: str = measure_page_url\nself.roles_page: str = str()\nself.roles_page_url: str = roles_page_url\nself.table_page: str = str()\nself.table_folder: str = table_folder\n# Generate an url friendly name for the model / folder\nself.friendly_name: str = self.set_url_friendly_name(self.model_name)\n# Initialize Save path so checks can be run against it.\nself.save_path = self.set_save_path()\ndef create_object_reference(self, object: str, object_parent: str) -&gt; str:\n\"\"\"Create a Custom ID for link sections in the docs.\n        This is based on the technical names in the model,\n        so not the once in the translations. This makes it\n        possible to link based on dependencies.\n        (Scope is only Docusaurus)\n        Args:\n            object (str): Object Name\n            object_parent (str): Object Parent (e.g. Table)\n        Returns:\n            str: String that can be used for custom linking\n        \"\"\"\nurl_reference = f\"{object_parent}-{object}\".replace(\" \", \"\")\nreturn f\"{{#{url_reference}}}\"\ndef generate_documentation_pages(self) -&gt; None:\n\"\"\"Generate Documentation for each specific part of the model.\"\"\"\nself.measure_page = self.generate_markdown_measure_page()\nself.table_page = self.generate_markdown_table_page()\nself.general_page = self.generate_general_info_file()\ndef get_object_caption(self, object_name: str, object_parent: str) -&gt; str:\n\"\"\"Retrieves the caption of an object, based on the translations in the culture.\n        If no culture is present, the object_name is returned.\n        Args:\n            object_name (str): Object Name\n            object_parent (str): Object Parent Name\n        Returns:\n            str: Translated object.\n        \"\"\"\nif self.culture_include:\nreturn str(\nself.culture_object.get_translation(\nobject_name=object_name, object_parent_name=object_parent\n).get(\"object_translation\")\n)\nreturn object_name\ndef set_translations(\nself, enable_translations: bool = False, culture: str = \"en-US\"\n) -&gt; None:\n\"\"\"Set translations to active or inactive, depending on the needs of the users.\n        Args:\n            enable_translations (bool, optional): Flag to enable or disable translations.\n                Defaults to False.\n            culture (str, optional): Set culture that needs to be used in the docs.\n                Defaults to \"en-US\".\n        \"\"\"\nlogger.info(f\"Using Translations set to &gt; {enable_translations}\")\nif enable_translations:\ntry:\nself.culture_object = self.model.Cultures[culture]\nself.culture_selected = culture\nself.culture_include = enable_translations\nexcept IndexError:\nself.culture_include = False\nlogger.warn(\n\"Culture not found, reverting back to orginal setting &gt; False\"\n)\nelse:\nlogger.info(f\"Setting culture to {self.culture_selected}\")\nelse:\nself.culture_include = enable_translations\ndef set_save_path(self) -&gt; Path:\n\"\"\"Set the location of the documentation.\n        Returns:\n            Path: Path where the docs are saved.\n        \"\"\"\nreturn Path(f\"{self.save_location}/{self.friendly_name}\")\ndef save_page(self, content: str, page_name: str, keep_file: bool = False) -&gt; None:\n\"\"\"Save the content of the documentation to a file.\n        Based on the class setup.\n        - Save Location\n        - Model Friendly Name\n        - Page to be written\n        Args:\n            content (str): File content to write to file.\n            page_name (str): Name of the file that will be used.\n            keep_file (bool): The file will only be overwritten if\n                the keep_file is set to False.\n        Returns:\n            None\n        \"\"\"\ntarget_file = self.save_path / page_name\nif target_file.parent.exists() is False:\ntarget_file.parent.mkdir(parents=True, exist_ok=True)\nif keep_file and target_file.exists():\nlogger.info(f\"{page_name} already exists -&gt; file will not overwritten.\")\nelse:\nlogger.info(f\"Results are written to -&gt; {page_name}.\")\nwith target_file.open(\"w\", encoding=\"utf-8\") as f:\nf.write(content)\nf.close()\ndef save_documentation(self) -&gt; None:\n\"\"\"Generate documentation of the model, based on the meta-data in the model definitions.\n        This first checks if the folder exists,\n        and then starts to export the files that are needed\n        for the documentatation.\n        - General Information Page -&gt; Free format page to create.\n        - Measure Page -&gt; Describes the measures in the model.\n        - Tables Page -&gt; Describes the tables in the model.\n        - Columns Page -&gt; Describes all columns in the model per table.\n        - Roles Page -&gt; Describes the roles in the model.\n        Args:\n            self (ModelDocumenter): Model object for documentation.\n        Returns:\n            None\n        \"\"\"\nif self.save_path.exists():\nlogger.info(\nf\"Path exists -&gt; Generating documentation for {self.friendly_name}\"\n)\nelse:\nlogger.info(\nf\"Path does not exist -&gt; Creating directory for {self.friendly_name}\"\n)\nself.save_path.mkdir(parents=True, exist_ok=True)\nif self.general_page:\nself.save_page(\ncontent=self.general_page,\nkeep_file=True,\npage_name=self.general_page_url,\n)\nif self.measure_page:\nself.save_page(\ncontent=self.measure_page,\nkeep_file=False,\npage_name=self.measure_page_url,\n)\nfor table in self.create_markdown_for_table_and_column():\ntable = table.items()\npage_name, page_content = list(table)[0]\nself.save_page(\ncontent=page_content,\nkeep_file=False,\npage_name=f\"{self.table_folder}/{page_name}\",\n)\nif self.roles_page:\nself.save_page(\ncontent=self.roles_page, keep_file=False, page_name=self.roles_page_url\n)\ndef create_markdown_for_measure(self, object: PyMeasure) -&gt; str:\n\"\"\"Create Markdown for a specific measure.\n        That can later on be used for generating the whole measure page.\n        Args:\n            object (PyMeasure): The measure to document.\n        Returns:\n            str: Markdown section for specific Measure\n        \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (object.Description or \"No Description available\").replace(\n\"\\\\n\", \"\"\n)\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\nobject_properties = [\n{\"Measure Name\": object.Name},\n{\"Display Folder\": object.DisplayFolder},\n{\"Format String\": object.FormatString},\n{\"Is Hidden\": \"Yes\" if object.IsHidden else \"No\"},\n]\nobj_text = [\nf\"### {object_caption}\",\n\"**Description**:\",\nf\"&gt; {obj_description}\",\n\"\",\n\"\" f\"{self.generate_object_properties(object_properties)}\" \"\",\nf'```dax title=\"Technical: {object.Name}\"',\nf\"  {object.Expression}\",\n\"```\",\n\"---\",\n]\nreturn \"\\n\".join(obj_text)\ndef generate_markdown_measure_page(self) -&gt; str:\n\"\"\"This function generates the meausure documation page.\n        Returns:\n            str: The full markdown text that is needed\n                make it compatible with Docusaurus.\n        \"\"\"\nprev_display_folder = \"\"\nmarkdown_template = [\n\"---\",\n\"sidebar_position: 1\",\n\"title: Measures\",\n\"description: This page contains all measures for \"\nf\"the {self.model.Name} model, including the description, \"\n\"format string, and other technical details.\",\n\"---\",\n\"\",\nf\"# Measures for {self.model.Name}\",\n]\nmeasures = sorted(\nself.model.Measures, key=lambda x: x.DisplayFolder, reverse=False\n)\nfor measure in measures:\nlogger.debug(f\"Creating docs for {measure.Name}\")\ndisplay_folder = measure.DisplayFolder or \"Other\"\ndisplay_folder = display_folder.split(\"\\\\\")[0]\nif prev_display_folder != display_folder:\nmarkdown_template.append(f\"\"\"## {display_folder}\"\"\")\nprev_display_folder = display_folder\nmarkdown_template.append(self.create_markdown_for_measure(measure))\nreturn \"\\n\".join(markdown_template)\ndef create_markdown_for_table_and_column(self) -&gt; list:\n\"\"\"Create Pages for Tables and Columns.\n        Based on the model this functions creates a general\n        overview pages for all tables and then with per\n        table a page with all column details.\n        Returns:\n            list: List of dicts per page.\n        Example:\n            ```\n                {\n                    \"Overview\": \"Content\",\n                    \"Table1\": \"Content\",\n                    \"Table2\": \"Content\",\n                }\n        \"\"\"\nobj_content = [{\"index.md\": self.generate_markdown_table_page()}]\nfor idx, table in enumerate(self.model.Tables):\nobj_caption = (\nself.get_object_caption(\nobject_name=table.Name, object_parent=table.Parent.Name\n)\nor table.Name\n)\nobj_caption = obj_caption.replace(\"[\", \"\").replace(\"]\", \"\")\nkey = f\"{self.set_url_friendly_name(obj_caption)}.md\"\nvalue = self.generate_markdown_column_page(\nobject=table, object_caption=obj_caption, page_index=idx + 2\n)\nobj_content.append({key: value})\nreturn obj_content\ndef create_markdown_for_table(self, object: PyTable) -&gt; str:\n\"\"\"This functions returns the markdown for a table.\n        Args:\n            object (PyTable): Based on the PyTabular Package.\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (object.Description or \"No Description available\").replace(\n\"\\\\n\", \"\"\n)\nobject_properties = [\n{\"Measures (#)\": len(object.Measures)},\n{\"Columns (#)\": len(object.Columns)},\n{\"Partiton (#)\": len(object.Partitions)},\n{\"Data Category\": object.DataCategory or \"Regular Table\"},\n{\"Is Hidden\": object.IsHidden},\n{\"Table Type\": object.Partitions[0].ObjectType},\n{\"Source Type\": object.Partitions[0].SourceType},\n]\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\npartition_type = \"\"\npartition_source = \"\"\nlogger.debug(f\"{object_caption} =&gt; {str(object.Partitions[0].SourceType)}\")\nif str(object.Partitions[0].SourceType) == \"Calculated\":\npartition_type = \"dax\"\npartition_source = object.Partitions[0].Source.Expression\nelif str(object.Partitions[0].SourceType) == \"M\":\npartition_type = \"powerquery\"\npartition_source = object.Partitions[0].Source.Expression\nelif str(object.Partitions[0].SourceType) == \"CalculationGroup\":\npartition_type = \"\"\npartition_source = \"\"\nelse:\npartition_type = \"sql\"\npartition_source = object.Partitions[0].Source.Query\nobj_text = [\nf\"### {object_caption}\",\n\"**Description**: \",\nf\"&gt; {obj_description}\",\n\"\",\nf\"{self.generate_object_properties(object_properties)}\",\n\"\",\nf'```{partition_type} title=\"Table Source: {object.Name}\"',\nf\"   {partition_source}\",\n\"```\",\n\"---\",\n]\nreturn \"\\n\".join(obj_text)\ndef generate_markdown_table_page(self) -&gt; str:\n\"\"\"This function generates the markdown for table documentation.\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\nmarkdown_template = [\n\"---\",\n\"sidebar_position: 2\",\n\"sidebar_label: Tables\",\n\"description: This page contains all columns with \"\nf\"tables for {self.model.Name}, including the description, \"\n\"and technical details.\",\n\"---\",\n\"\",\nf\"# Tables {self.model.Name}\",\n]\nmarkdown_template.extend(\nself.create_markdown_for_table(table) for table in self.model.Tables\n)\nreturn \"\\n\".join(markdown_template)\ndef create_markdown_for_column(self, object: PyColumn) -&gt; str:\n\"\"\"Generates the Markdown for a specifc column.\n        If a columns is calculated, then it also shows the expression for\n        that column in DAX.\n        Args:\n            object (PyColumn): Needs PyColumn objects input\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (\nobject.Description.replace(\"\\\\n\", \"\") or \"No Description available\"\n)\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\nobj_heading = f\"\"\"{object_caption}\"\"\"\nobject_properties = [\n{\"Column Name\": object.Name},\n{\"Object Type\": object.ObjectType},\n{\"Type\": object.Type},\n{\"Is Available In Excel\": object.IsAvailableInMDX},\n{\"Is Hidden\": object.IsHidden},\n{\"Data Category\": object.DataCategory},\n{\"Data Type\": object.DataType},\n{\"Display Folder\": object.DisplayFolder},\n]\nobj_text = [\nf\"### {obj_heading}\",\n\"**Description**:\",\nf\"&gt; {obj_description}\",\n\"\",\nf\"{self.generate_object_properties(object_properties)}\",\n]\nif str(object.Type) == \"Calculated\":\nobj_text.extend(\n(\nf'```dax title=\"Technical: {object.Name}\"',\nf\"  {object.Expression}\",\n\"```\",\n)\n)\nobj_text.append(\"---\")\nreturn \"\\n\".join(obj_text)\ndef generate_markdown_column_page(\nself, object: PyTable, object_caption: str, page_index: int = 2\n) -&gt; str:\n\"\"\"This function generates the markdown for the colums documentation.\n        Returns:\n            str: Will be appended to the page text.\n        \"\"\"\nmarkdown_template = [\n\"---\",\nf\"sidebar_position: {page_index}\",\nf\"sidebar_label: {object_caption}\",\nf\"title: {object_caption}\",\nf\"description: This page contains all columns with \"\nf\"Columns for {self.model.Name} \"\n\"including the description, format string, and other technical details.\",\n\"---\",\n\"\",\n]\nmarkdown_template.extend(\nself.create_markdown_for_column(column)\nfor column in object.Columns\nif \"RowNumber\" not in column.Name\n)\nreturn \"\\n\".join(markdown_template)\ndef generate_general_info_file(self) -&gt; str:\n\"\"\"Index.md file for the model.\n        Basic text for an introduction page.\n        Returns:\n            str: Markdown str for info page\n        \"\"\"\nreturn \"\\n\".join(\n[\n\"---\",\n\"sidebar_position: 1\",\nf\"title: {self.model_name}\",\n\"description: This page contains all measures for the Model model,\"\n\"including the description,\"\n\"format string, and other technical details.\",\n\"---\",\n\"\",\n\"## General information\",\n\"### Business Owners\",\n\"\",\n\"## Information Sources\",\n]\n)\n@staticmethod\ndef generate_object_properties(properties: List[Dict[str, str]]) -&gt; str:\n\"\"\"Generate the section for object properties.\n        You can select your own properties to display\n        by providing a the properties in a list of\n        dicts.\n        Args:\n            properties (dict): The ones you want to show.\n        Returns:\n            str: HTML used in the markdown.\n        Example:\n            ```python\n                [\n                    { \"Display Folder\": \"Sales Order Information\" },\n                    { \"Is Hidden\": \"False\" },\n                    { \"Format String\": \"#.###,## }\n                ]\n            ```\n            Returns:\n            ```\n            &lt;dl&gt;\n                &lt;dt&gt;Display Folder&lt;/dt&gt;\n                &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n                &lt;dt&gt;Is Hidden&lt;/dt&gt;\n                &lt;dd&gt;False&lt;/dd&gt;\n                &lt;dt&gt;Format String&lt;/dt&gt;\n                &lt;dd&gt;#.###,##&lt;/dd&gt;\n            &lt;/dl&gt;\n            ```\n        \"\"\"\nobj_text = [\"&lt;dl&gt;\"]\nfor obj_prop in properties:\nfor caption, text in obj_prop.items():\nsave_text = str(text).replace(\"\\\\\", \" &gt; \")\nobj_text.extend(\n(f\"  &lt;dt&gt;{caption}&lt;/dt&gt;\", f\"  &lt;dd&gt;{save_text}&lt;/dd&gt;\", \"\")\n)\nobj_text.extend((\"&lt;/dl&gt;\", \"\"))\nreturn \"\\n\".join(obj_text)\n@staticmethod\ndef set_url_friendly_name(page_name: str) -&gt; str:\n\"\"\"Replaces the model name to a friendly string, so it can be used in an URL.\n        Returns:\n            str: Friendly model name used in url for docs.\n        \"\"\"\n# return (self.model_name).replace(\" \", \"-\").replace(\"_\", \"-\").lower()\nreturn (\npage_name.replace(\" \", \"-\")\n.replace(\"_\", \"-\")\n.lower()\n.replace(\"[\", \"\")\n.replace(\"]\", \"\")\n)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.__init__","title":"<code>__init__(model, friendly_name=str(), save_location='docs', general_page_url='index.md', measure_page_url='measures.md', roles_page_url='roles.md', table_folder='tables')</code>","text":"<p>Init will set attributes based on arguments given.</p> <p>See <code>generate_documentation_pages()</code> and <code>save_documentation()</code> for info on how to execute and retrieve documentation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Tabular</code> <p>Main <code>Tabular()</code> class to pull metadata from for documentation.</p> required <code>friendly_name</code> <code>str</code> <p>Replaces the model name to a friendly string, so it can be used in an URL. Defaults to <code>str()</code>.</p> <code>str()</code> <code>save_location</code> <code>str</code> <p>The save location where the files will be stored. Defaults to \"docs\".</p> <code>'docs'</code> <code>general_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for general information. Defaults to \"index.md\".</p> <code>'index.md'</code> <code>measure_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for measures. Defaults to \"measures.md\".</p> <code>'measures.md'</code> <code>table_folder</code> <code>str</code> <p>Name of the folder where columns info is stored. Defaults to \"table_folder\".</p> <code>'tables'</code> <code>roles_page_url</code> <code>str</code> <p>Name of the <code>md</code> file for roles. Defaults to \"roles.md\".</p> <code>'roles.md'</code> Source code in <code>pytabular/document.py</code> <pre><code>def __init__(\nself,\nmodel: Tabular,\nfriendly_name: str = str(),\nsave_location: str = \"docs\",\ngeneral_page_url: str = \"index.md\",\nmeasure_page_url: str = \"measures.md\",\nroles_page_url: str = \"roles.md\",\ntable_folder: str = \"tables\",\n# table_page_url: str = \"3-tables.md\",\n# column_page_url: str = \"4-columns.md\",\n):\n\"\"\"Init will set attributes based on arguments given.\n    See `generate_documentation_pages()` and `save_documentation()`\n    for info on how to execute and retrieve documentation.\n    Args:\n        model (Tabular): Main `Tabular()` class to pull metadata from for documentation.\n        friendly_name (str, optional): Replaces the model name to a friendly string,\n            so it can be used in an URL. Defaults to `str()`.\n        save_location (str, optional): The save location where the files will be stored.\n            Defaults to \"docs\".\n        general_page_url (str, optional): Name of the `md` file for general information.\n            Defaults to \"index.md\".\n        measure_page_url (str, optional): Name of the `md` file for measures.\n            Defaults to \"measures.md\".\n        table_folder (str, optional): Name of the folder where columns info is stored.\n            Defaults to \"table_folder\".\n        roles_page_url (str, optional): Name of the `md` file for roles.\n            Defaults to \"roles.md\".\n    \"\"\"\nself.model = model\nself.model_name = friendly_name or model.Catalog or model.Database.Name\nself.friendly_name: str = str()\nself.save_path: Path\nself.save_location: str = save_location\n# Translation information\nself.culture_include: bool = False\nself.culture_selected: str = \"en-US\"\nself.culture_object: PyCulture\n# Documentation Parts\nself.general_page: str = str()\nself.general_page_url: str = general_page_url\nself.measure_page: str = str()\nself.measure_page_url: str = measure_page_url\nself.roles_page: str = str()\nself.roles_page_url: str = roles_page_url\nself.table_page: str = str()\nself.table_folder: str = table_folder\n# Generate an url friendly name for the model / folder\nself.friendly_name: str = self.set_url_friendly_name(self.model_name)\n# Initialize Save path so checks can be run against it.\nself.save_path = self.set_save_path()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_object_reference","title":"<code>create_object_reference(object, object_parent)</code>","text":"<p>Create a Custom ID for link sections in the docs.</p> <p>This is based on the technical names in the model, so not the once in the translations. This makes it possible to link based on dependencies. (Scope is only Docusaurus)</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>str</code> <p>Object Name</p> required <code>object_parent</code> <code>str</code> <p>Object Parent (e.g. Table)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String that can be used for custom linking</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_object_reference(self, object: str, object_parent: str) -&gt; str:\n\"\"\"Create a Custom ID for link sections in the docs.\n    This is based on the technical names in the model,\n    so not the once in the translations. This makes it\n    possible to link based on dependencies.\n    (Scope is only Docusaurus)\n    Args:\n        object (str): Object Name\n        object_parent (str): Object Parent (e.g. Table)\n    Returns:\n        str: String that can be used for custom linking\n    \"\"\"\nurl_reference = f\"{object_parent}-{object}\".replace(\" \", \"\")\nreturn f\"{{#{url_reference}}}\"\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_documentation_pages","title":"<code>generate_documentation_pages()</code>","text":"<p>Generate Documentation for each specific part of the model.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_documentation_pages(self) -&gt; None:\n\"\"\"Generate Documentation for each specific part of the model.\"\"\"\nself.measure_page = self.generate_markdown_measure_page()\nself.table_page = self.generate_markdown_table_page()\nself.general_page = self.generate_general_info_file()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.get_object_caption","title":"<code>get_object_caption(object_name, object_parent)</code>","text":"<p>Retrieves the caption of an object, based on the translations in the culture.</p> <p>If no culture is present, the object_name is returned.</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>Object Name</p> required <code>object_parent</code> <code>str</code> <p>Object Parent Name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Translated object.</p> Source code in <code>pytabular/document.py</code> <pre><code>def get_object_caption(self, object_name: str, object_parent: str) -&gt; str:\n\"\"\"Retrieves the caption of an object, based on the translations in the culture.\n    If no culture is present, the object_name is returned.\n    Args:\n        object_name (str): Object Name\n        object_parent (str): Object Parent Name\n    Returns:\n        str: Translated object.\n    \"\"\"\nif self.culture_include:\nreturn str(\nself.culture_object.get_translation(\nobject_name=object_name, object_parent_name=object_parent\n).get(\"object_translation\")\n)\nreturn object_name\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_translations","title":"<code>set_translations(enable_translations=False, culture='en-US')</code>","text":"<p>Set translations to active or inactive, depending on the needs of the users.</p> <p>Parameters:</p> Name Type Description Default <code>enable_translations</code> <code>bool</code> <p>Flag to enable or disable translations. Defaults to False.</p> <code>False</code> <code>culture</code> <code>str</code> <p>Set culture that needs to be used in the docs. Defaults to \"en-US\".</p> <code>'en-US'</code> Source code in <code>pytabular/document.py</code> <pre><code>def set_translations(\nself, enable_translations: bool = False, culture: str = \"en-US\"\n) -&gt; None:\n\"\"\"Set translations to active or inactive, depending on the needs of the users.\n    Args:\n        enable_translations (bool, optional): Flag to enable or disable translations.\n            Defaults to False.\n        culture (str, optional): Set culture that needs to be used in the docs.\n            Defaults to \"en-US\".\n    \"\"\"\nlogger.info(f\"Using Translations set to &gt; {enable_translations}\")\nif enable_translations:\ntry:\nself.culture_object = self.model.Cultures[culture]\nself.culture_selected = culture\nself.culture_include = enable_translations\nexcept IndexError:\nself.culture_include = False\nlogger.warn(\n\"Culture not found, reverting back to orginal setting &gt; False\"\n)\nelse:\nlogger.info(f\"Setting culture to {self.culture_selected}\")\nelse:\nself.culture_include = enable_translations\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_save_path","title":"<code>set_save_path()</code>","text":"<p>Set the location of the documentation.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path where the docs are saved.</p> Source code in <code>pytabular/document.py</code> <pre><code>def set_save_path(self) -&gt; Path:\n\"\"\"Set the location of the documentation.\n    Returns:\n        Path: Path where the docs are saved.\n    \"\"\"\nreturn Path(f\"{self.save_location}/{self.friendly_name}\")\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.save_page","title":"<code>save_page(content, page_name, keep_file=False)</code>","text":"<p>Save the content of the documentation to a file.</p> <p>Based on the class setup. - Save Location - Model Friendly Name - Page to be written</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>File content to write to file.</p> required <code>page_name</code> <code>str</code> <p>Name of the file that will be used.</p> required <code>keep_file</code> <code>bool</code> <p>The file will only be overwritten if the keep_file is set to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pytabular/document.py</code> <pre><code>def save_page(self, content: str, page_name: str, keep_file: bool = False) -&gt; None:\n\"\"\"Save the content of the documentation to a file.\n    Based on the class setup.\n    - Save Location\n    - Model Friendly Name\n    - Page to be written\n    Args:\n        content (str): File content to write to file.\n        page_name (str): Name of the file that will be used.\n        keep_file (bool): The file will only be overwritten if\n            the keep_file is set to False.\n    Returns:\n        None\n    \"\"\"\ntarget_file = self.save_path / page_name\nif target_file.parent.exists() is False:\ntarget_file.parent.mkdir(parents=True, exist_ok=True)\nif keep_file and target_file.exists():\nlogger.info(f\"{page_name} already exists -&gt; file will not overwritten.\")\nelse:\nlogger.info(f\"Results are written to -&gt; {page_name}.\")\nwith target_file.open(\"w\", encoding=\"utf-8\") as f:\nf.write(content)\nf.close()\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.save_documentation","title":"<code>save_documentation()</code>","text":"<p>Generate documentation of the model, based on the meta-data in the model definitions.</p> <p>This first checks if the folder exists, and then starts to export the files that are needed for the documentatation. - General Information Page -&gt; Free format page to create. - Measure Page -&gt; Describes the measures in the model. - Tables Page -&gt; Describes the tables in the model. - Columns Page -&gt; Describes all columns in the model per table. - Roles Page -&gt; Describes the roles in the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ModelDocumenter</code> <p>Model object for documentation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pytabular/document.py</code> <pre><code>def save_documentation(self) -&gt; None:\n\"\"\"Generate documentation of the model, based on the meta-data in the model definitions.\n    This first checks if the folder exists,\n    and then starts to export the files that are needed\n    for the documentatation.\n    - General Information Page -&gt; Free format page to create.\n    - Measure Page -&gt; Describes the measures in the model.\n    - Tables Page -&gt; Describes the tables in the model.\n    - Columns Page -&gt; Describes all columns in the model per table.\n    - Roles Page -&gt; Describes the roles in the model.\n    Args:\n        self (ModelDocumenter): Model object for documentation.\n    Returns:\n        None\n    \"\"\"\nif self.save_path.exists():\nlogger.info(\nf\"Path exists -&gt; Generating documentation for {self.friendly_name}\"\n)\nelse:\nlogger.info(\nf\"Path does not exist -&gt; Creating directory for {self.friendly_name}\"\n)\nself.save_path.mkdir(parents=True, exist_ok=True)\nif self.general_page:\nself.save_page(\ncontent=self.general_page,\nkeep_file=True,\npage_name=self.general_page_url,\n)\nif self.measure_page:\nself.save_page(\ncontent=self.measure_page,\nkeep_file=False,\npage_name=self.measure_page_url,\n)\nfor table in self.create_markdown_for_table_and_column():\ntable = table.items()\npage_name, page_content = list(table)[0]\nself.save_page(\ncontent=page_content,\nkeep_file=False,\npage_name=f\"{self.table_folder}/{page_name}\",\n)\nif self.roles_page:\nself.save_page(\ncontent=self.roles_page, keep_file=False, page_name=self.roles_page_url\n)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_measure","title":"<code>create_markdown_for_measure(object)</code>","text":"<p>Create Markdown for a specific measure.</p> <p>That can later on be used for generating the whole measure page.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyMeasure</code> <p>The measure to document.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Markdown section for specific Measure</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_measure(self, object: PyMeasure) -&gt; str:\n\"\"\"Create Markdown for a specific measure.\n    That can later on be used for generating the whole measure page.\n    Args:\n        object (PyMeasure): The measure to document.\n    Returns:\n        str: Markdown section for specific Measure\n    \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (object.Description or \"No Description available\").replace(\n\"\\\\n\", \"\"\n)\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\nobject_properties = [\n{\"Measure Name\": object.Name},\n{\"Display Folder\": object.DisplayFolder},\n{\"Format String\": object.FormatString},\n{\"Is Hidden\": \"Yes\" if object.IsHidden else \"No\"},\n]\nobj_text = [\nf\"### {object_caption}\",\n\"**Description**:\",\nf\"&gt; {obj_description}\",\n\"\",\n\"\" f\"{self.generate_object_properties(object_properties)}\" \"\",\nf'```dax title=\"Technical: {object.Name}\"',\nf\"  {object.Expression}\",\n\"```\",\n\"---\",\n]\nreturn \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_measure_page","title":"<code>generate_markdown_measure_page()</code>","text":"<p>This function generates the meausure documation page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full markdown text that is needed make it compatible with Docusaurus.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_measure_page(self) -&gt; str:\n\"\"\"This function generates the meausure documation page.\n    Returns:\n        str: The full markdown text that is needed\n            make it compatible with Docusaurus.\n    \"\"\"\nprev_display_folder = \"\"\nmarkdown_template = [\n\"---\",\n\"sidebar_position: 1\",\n\"title: Measures\",\n\"description: This page contains all measures for \"\nf\"the {self.model.Name} model, including the description, \"\n\"format string, and other technical details.\",\n\"---\",\n\"\",\nf\"# Measures for {self.model.Name}\",\n]\nmeasures = sorted(\nself.model.Measures, key=lambda x: x.DisplayFolder, reverse=False\n)\nfor measure in measures:\nlogger.debug(f\"Creating docs for {measure.Name}\")\ndisplay_folder = measure.DisplayFolder or \"Other\"\ndisplay_folder = display_folder.split(\"\\\\\")[0]\nif prev_display_folder != display_folder:\nmarkdown_template.append(f\"\"\"## {display_folder}\"\"\")\nprev_display_folder = display_folder\nmarkdown_template.append(self.create_markdown_for_measure(measure))\nreturn \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_table_and_column","title":"<code>create_markdown_for_table_and_column()</code>","text":"<p>Create Pages for Tables and Columns.</p> <p>Based on the model this functions creates a general overview pages for all tables and then with per table a page with all column details.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of dicts per page.</p> Example <p>```     {         \"Overview\": \"Content\",         \"Table1\": \"Content\",         \"Table2\": \"Content\",     }</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_table_and_column(self) -&gt; list:\n\"\"\"Create Pages for Tables and Columns.\n    Based on the model this functions creates a general\n    overview pages for all tables and then with per\n    table a page with all column details.\n    Returns:\n        list: List of dicts per page.\n    Example:\n        ```\n            {\n                \"Overview\": \"Content\",\n                \"Table1\": \"Content\",\n                \"Table2\": \"Content\",\n            }\n    \"\"\"\nobj_content = [{\"index.md\": self.generate_markdown_table_page()}]\nfor idx, table in enumerate(self.model.Tables):\nobj_caption = (\nself.get_object_caption(\nobject_name=table.Name, object_parent=table.Parent.Name\n)\nor table.Name\n)\nobj_caption = obj_caption.replace(\"[\", \"\").replace(\"]\", \"\")\nkey = f\"{self.set_url_friendly_name(obj_caption)}.md\"\nvalue = self.generate_markdown_column_page(\nobject=table, object_caption=obj_caption, page_index=idx + 2\n)\nobj_content.append({key: value})\nreturn obj_content\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_table","title":"<code>create_markdown_for_table(object)</code>","text":"<p>This functions returns the markdown for a table.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyTable</code> <p>Based on the PyTabular Package.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_table(self, object: PyTable) -&gt; str:\n\"\"\"This functions returns the markdown for a table.\n    Args:\n        object (PyTable): Based on the PyTabular Package.\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (object.Description or \"No Description available\").replace(\n\"\\\\n\", \"\"\n)\nobject_properties = [\n{\"Measures (#)\": len(object.Measures)},\n{\"Columns (#)\": len(object.Columns)},\n{\"Partiton (#)\": len(object.Partitions)},\n{\"Data Category\": object.DataCategory or \"Regular Table\"},\n{\"Is Hidden\": object.IsHidden},\n{\"Table Type\": object.Partitions[0].ObjectType},\n{\"Source Type\": object.Partitions[0].SourceType},\n]\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\npartition_type = \"\"\npartition_source = \"\"\nlogger.debug(f\"{object_caption} =&gt; {str(object.Partitions[0].SourceType)}\")\nif str(object.Partitions[0].SourceType) == \"Calculated\":\npartition_type = \"dax\"\npartition_source = object.Partitions[0].Source.Expression\nelif str(object.Partitions[0].SourceType) == \"M\":\npartition_type = \"powerquery\"\npartition_source = object.Partitions[0].Source.Expression\nelif str(object.Partitions[0].SourceType) == \"CalculationGroup\":\npartition_type = \"\"\npartition_source = \"\"\nelse:\npartition_type = \"sql\"\npartition_source = object.Partitions[0].Source.Query\nobj_text = [\nf\"### {object_caption}\",\n\"**Description**: \",\nf\"&gt; {obj_description}\",\n\"\",\nf\"{self.generate_object_properties(object_properties)}\",\n\"\",\nf'```{partition_type} title=\"Table Source: {object.Name}\"',\nf\"   {partition_source}\",\n\"```\",\n\"---\",\n]\nreturn \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_table_page","title":"<code>generate_markdown_table_page()</code>","text":"<p>This function generates the markdown for table documentation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_table_page(self) -&gt; str:\n\"\"\"This function generates the markdown for table documentation.\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\nmarkdown_template = [\n\"---\",\n\"sidebar_position: 2\",\n\"sidebar_label: Tables\",\n\"description: This page contains all columns with \"\nf\"tables for {self.model.Name}, including the description, \"\n\"and technical details.\",\n\"---\",\n\"\",\nf\"# Tables {self.model.Name}\",\n]\nmarkdown_template.extend(\nself.create_markdown_for_table(table) for table in self.model.Tables\n)\nreturn \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.create_markdown_for_column","title":"<code>create_markdown_for_column(object)</code>","text":"<p>Generates the Markdown for a specifc column.</p> <p>If a columns is calculated, then it also shows the expression for that column in DAX.</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>PyColumn</code> <p>Needs PyColumn objects input</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def create_markdown_for_column(self, object: PyColumn) -&gt; str:\n\"\"\"Generates the Markdown for a specifc column.\n    If a columns is calculated, then it also shows the expression for\n    that column in DAX.\n    Args:\n        object (PyColumn): Needs PyColumn objects input\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\nobject_caption = (\nself.get_object_caption(\nobject_name=object.Name, object_parent=object.Parent.Name\n)\nor object.Name\n)\nobj_description = (\nobject.Description.replace(\"\\\\n\", \"\") or \"No Description available\"\n)\nobj_description = obj_description.replace(\"&lt;&gt;\", \"not equal to \")\nobj_heading = f\"\"\"{object_caption}\"\"\"\nobject_properties = [\n{\"Column Name\": object.Name},\n{\"Object Type\": object.ObjectType},\n{\"Type\": object.Type},\n{\"Is Available In Excel\": object.IsAvailableInMDX},\n{\"Is Hidden\": object.IsHidden},\n{\"Data Category\": object.DataCategory},\n{\"Data Type\": object.DataType},\n{\"Display Folder\": object.DisplayFolder},\n]\nobj_text = [\nf\"### {obj_heading}\",\n\"**Description**:\",\nf\"&gt; {obj_description}\",\n\"\",\nf\"{self.generate_object_properties(object_properties)}\",\n]\nif str(object.Type) == \"Calculated\":\nobj_text.extend(\n(\nf'```dax title=\"Technical: {object.Name}\"',\nf\"  {object.Expression}\",\n\"```\",\n)\n)\nobj_text.append(\"---\")\nreturn \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_markdown_column_page","title":"<code>generate_markdown_column_page(object, object_caption, page_index=2)</code>","text":"<p>This function generates the markdown for the colums documentation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Will be appended to the page text.</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_markdown_column_page(\nself, object: PyTable, object_caption: str, page_index: int = 2\n) -&gt; str:\n\"\"\"This function generates the markdown for the colums documentation.\n    Returns:\n        str: Will be appended to the page text.\n    \"\"\"\nmarkdown_template = [\n\"---\",\nf\"sidebar_position: {page_index}\",\nf\"sidebar_label: {object_caption}\",\nf\"title: {object_caption}\",\nf\"description: This page contains all columns with \"\nf\"Columns for {self.model.Name} \"\n\"including the description, format string, and other technical details.\",\n\"---\",\n\"\",\n]\nmarkdown_template.extend(\nself.create_markdown_for_column(column)\nfor column in object.Columns\nif \"RowNumber\" not in column.Name\n)\nreturn \"\\n\".join(markdown_template)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_general_info_file","title":"<code>generate_general_info_file()</code>","text":"<p>Index.md file for the model.</p> <p>Basic text for an introduction page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Markdown str for info page</p> Source code in <code>pytabular/document.py</code> <pre><code>def generate_general_info_file(self) -&gt; str:\n\"\"\"Index.md file for the model.\n    Basic text for an introduction page.\n    Returns:\n        str: Markdown str for info page\n    \"\"\"\nreturn \"\\n\".join(\n[\n\"---\",\n\"sidebar_position: 1\",\nf\"title: {self.model_name}\",\n\"description: This page contains all measures for the Model model,\"\n\"including the description,\"\n\"format string, and other technical details.\",\n\"---\",\n\"\",\n\"## General information\",\n\"### Business Owners\",\n\"\",\n\"## Information Sources\",\n]\n)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.generate_object_properties","title":"<code>generate_object_properties(properties)</code>  <code>staticmethod</code>","text":"<p>Generate the section for object properties.</p> <p>You can select your own properties to display by providing a the properties in a list of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>dict</code> <p>The ones you want to show.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>HTML used in the markdown.</p> Example <p><pre><code>    [\n{ \"Display Folder\": \"Sales Order Information\" },\n{ \"Is Hidden\": \"False\" },\n{ \"Format String\": \"#.###,## }\n]\n</code></pre> Returns: <pre><code>&lt;dl&gt;\n    &lt;dt&gt;Display Folder&lt;/dt&gt;\n    &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n\n    &lt;dt&gt;Is Hidden&lt;/dt&gt;\n    &lt;dd&gt;False&lt;/dd&gt;\n\n    &lt;dt&gt;Format String&lt;/dt&gt;\n    &lt;dd&gt;#.###,##&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre></p> Source code in <code>pytabular/document.py</code> <pre><code>@staticmethod\ndef generate_object_properties(properties: List[Dict[str, str]]) -&gt; str:\n\"\"\"Generate the section for object properties.\n    You can select your own properties to display\n    by providing a the properties in a list of\n    dicts.\n    Args:\n        properties (dict): The ones you want to show.\n    Returns:\n        str: HTML used in the markdown.\n    Example:\n        ```python\n            [\n                { \"Display Folder\": \"Sales Order Information\" },\n                { \"Is Hidden\": \"False\" },\n                { \"Format String\": \"#.###,## }\n            ]\n        ```\n        Returns:\n        ```\n        &lt;dl&gt;\n            &lt;dt&gt;Display Folder&lt;/dt&gt;\n            &lt;dd&gt;Sales Order Information&lt;/dd&gt;\n            &lt;dt&gt;Is Hidden&lt;/dt&gt;\n            &lt;dd&gt;False&lt;/dd&gt;\n            &lt;dt&gt;Format String&lt;/dt&gt;\n            &lt;dd&gt;#.###,##&lt;/dd&gt;\n        &lt;/dl&gt;\n        ```\n    \"\"\"\nobj_text = [\"&lt;dl&gt;\"]\nfor obj_prop in properties:\nfor caption, text in obj_prop.items():\nsave_text = str(text).replace(\"\\\\\", \" &gt; \")\nobj_text.extend(\n(f\"  &lt;dt&gt;{caption}&lt;/dt&gt;\", f\"  &lt;dd&gt;{save_text}&lt;/dd&gt;\", \"\")\n)\nobj_text.extend((\"&lt;/dl&gt;\", \"\"))\nreturn \"\\n\".join(obj_text)\n</code></pre>"},{"location":"document/#pytabular.document.ModelDocumenter.set_url_friendly_name","title":"<code>set_url_friendly_name(page_name)</code>  <code>staticmethod</code>","text":"<p>Replaces the model name to a friendly string, so it can be used in an URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Friendly model name used in url for docs.</p> Source code in <code>pytabular/document.py</code> <pre><code>@staticmethod\ndef set_url_friendly_name(page_name: str) -&gt; str:\n\"\"\"Replaces the model name to a friendly string, so it can be used in an URL.\n    Returns:\n        str: Friendly model name used in url for docs.\n    \"\"\"\n# return (self.model_name).replace(\" \", \"-\").replace(\"_\", \"-\").lower()\nreturn (\npage_name.replace(\" \", \"-\")\n.replace(\"_\", \"-\")\n.lower()\n.replace(\"[\", \"\")\n.replace(\"]\", \"\")\n)\n</code></pre>"},{"location":"logic_utils/","title":"logic_utils","text":"<p><code>logic_utils</code> used to store multiple functions that are used in many different files.</p>"},{"location":"logic_utils/#pytabular.logic_utils.ticks_to_datetime","title":"<code>ticks_to_datetime(ticks)</code>","text":"<p>Converts a C# system datetime tick into a python datatime.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>C# DateTime Tick.</p> required <p>Returns:</p> Type Description <code>datetime.datetime</code> <p>datetime.datetime: datetime of tick.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def ticks_to_datetime(ticks: int) -&gt; datetime.datetime:\n\"\"\"Converts a C# system datetime tick into a python datatime.\n    Args:\n            ticks (int): C# DateTime Tick.\n    Returns:\n            datetime.datetime: datetime of tick.\n    \"\"\"\nreturn datetime.datetime(1, 1, 1) + datetime.timedelta(microseconds=ticks // 10)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.pandas_datatype_to_tabular_datatype","title":"<code>pandas_datatype_to_tabular_datatype(df)</code>","text":"<p>Takes dataframe columns and gets respective tabular column datatype.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Pandas DataFrame</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>dictionary with results.</p> Example <pre><code>{\n    'col1': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9700&gt;,\n    'col2': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC8840&gt;,\n    'col3': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9800&gt;\n}\n</code></pre> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def pandas_datatype_to_tabular_datatype(df: pd.DataFrame) -&gt; Dict:\n\"\"\"Takes dataframe columns and gets respective tabular column datatype.\n    Args:\n            df (pd.DataFrame): Pandas DataFrame\n    Returns:\n            Dict: dictionary with results.\n    Example:\n        ```\n        {\n            'col1': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9700&gt;,\n            'col2': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC8840&gt;,\n            'col3': &lt;Microsoft.AnalysisServices.Tabular.DataType object at 0x0000023BFFBC9800&gt;\n        }\n        ```\n    \"\"\"\nlogger.info(\"Getting DF Column Dtypes to Tabular Dtypes...\")\ntabular_datatype_mapping_key = {\n\"b\": DataType.Boolean,\n\"i\": DataType.Int64,\n\"u\": DataType.Int64,\n\"f\": DataType.Double,\n\"c\": DataType.Double,\n\"m\": DataType.DateTime,\n\"M\": DataType.DateTime,\n\"O\": DataType.String,\n\"S\": DataType.String,\n\"U\": DataType.String,\n\"V\": DataType.String,\n}\nreturn {\ncolumn: tabular_datatype_mapping_key[df[column].dtype.kind]\nfor column in df.columns\n}\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.pd_dataframe_to_m_expression","title":"<code>pd_dataframe_to_m_expression(df)</code>","text":"<p>This will take a pandas dataframe and convert to an m expression.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Pandas DataFrame</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Currently only returning string values in your tabular model.</p> Example <p><pre><code>col1  col2\n0   1     3\n1   2     4\n</code></pre> converts to <pre><code>Source=#table({\"col1\",\"col2\"},\n{\n{\"1\",\"3\"},{\"2\",\"4\"}\n})\nin\nSource\n</code></pre></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def pd_dataframe_to_m_expression(df: pd.DataFrame) -&gt; str:\n\"\"\"This will take a pandas dataframe and convert to an m expression.\n    Args:\n            df (pd.DataFrame): Pandas DataFrame\n    Returns:\n            str: Currently only returning string values in your tabular model.\n    Example:\n        ```\n        col1  col2\n        0   1     3\n        1   2     4\n        ```\n        converts to\n        ```\n        Source=#table({\"col1\",\"col2\"},\n        {\n        {\"1\",\"3\"},{\"2\",\"4\"}\n        })\n        in\n        Source\n        ```\n    \"\"\"\ndef m_list_expression_generator(list_of_strings: List[str]) -&gt; str:\n\"\"\"Takes a python list of strings and converts to power query m expression list format.\n        Ex: `[\"item1\",\"item2\",\"item3\"]` --&gt; `{\"item1\",\"item2\",\"item3\"}`\n        Codepoint reference --&gt; `\\u007b` == `{` and `\\u007d` == `}`\n        \"\"\"\nstring_components = \",\".join(\n[f'\"{string_value}\"' for string_value in list_of_strings]\n)\nreturn f\"\\u007b{string_components}\\u007d\"\nlogger.debug(f\"Executing m_list_generator()... for {df.columns}\")\ncolumns = m_list_expression_generator(df.columns)\nexpression_str = f\"let\\nSource=#table({columns},\\n\"\nlogger.debug(\nf\"Iterating through rows to build expression... df has {len(df)} rows...\"\n)\nexpression_list_rows = []\nfor _, row in df.iterrows():\nexpression_list_rows += [m_list_expression_generator(row.to_list())]\nexpression_str += f\"\\u007b\\n{','.join(expression_list_rows)}\\n\\u007d)\\nin\\nSource\"\nreturn expression_str\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_folder_and_contents","title":"<code>remove_folder_and_contents(folder_location)</code>","text":"<p>Internal used in tabular_editor.py and best_practice_analyzer.py.</p> <p>Parameters:</p> Name Type Description Default <code>folder_location</code> <code>str</code> <p>Folder path to remove directory and contents.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_folder_and_contents(folder_location):\n\"\"\"Internal used in tabular_editor.py and best_practice_analyzer.py.\n    Args:\n            folder_location (str): Folder path to remove directory and contents.\n    \"\"\"\nimport shutil\nif os.path.exists(folder_location):\nlogger.info(f\"Removing Dir and Contents -&gt; {folder_location}\")\nshutil.rmtree(folder_location)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_file","title":"<code>remove_file(file_path)</code>","text":"<p>Just <code>os.remove()</code> but wanted a <code>logger.info()</code> with it.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_file(file_path):\n\"\"\"Just `os.remove()` but wanted a `logger.info()` with it.\"\"\"\nlogger.info(f\"Removing file - {file_path}\")\nos.remove(file_path)\npass\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.remove_suffix","title":"<code>remove_suffix(input_string, suffix)</code>","text":"<p>Adding for &lt;3.9 compatiblity.</p> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>str</code> <p>input string to remove suffix from.</p> required <code>suffix</code> <code>str</code> <p>suffix to be removed.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def remove_suffix(input_string, suffix):\n\"\"\"Adding for &lt;3.9 compatiblity.\n    Args:\n            input_string (str): input string to remove suffix from.\n            suffix (str): suffix to be removed.\n    \"\"\"\n# [Stackoverflow Answer](https://stackoverflow.com/questions/66683630/removesuffix-returns-error-str-object-has-no-attribute-removesuffix)  # noqa: E501\noutput = (\ninput_string[: -len(suffix)]\nif suffix and input_string.endswith(suffix)\nelse input_string\n)\nreturn output\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.get_sub_list","title":"<code>get_sub_list(lst, n)</code>","text":"<p>Nest list by n amount.</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list</code> <p>List to nest.</p> required <code>n</code> <code>int</code> <p>Amount to nest list.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Nested list.</p> Example <p><code>get_sub_list([1,2,3,4,5,6],2) == [[1,2],[3,4],[5,6]]</code></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def get_sub_list(lst: list, n: int) -&gt; list:\n\"\"\"Nest list by n amount.\n    Args:\n        lst (list): List to nest.\n        n (int): Amount to nest list.\n    Returns:\n        list: Nested list.\n    Example:\n        `get_sub_list([1,2,3,4,5,6],2) == [[1,2],[3,4],[5,6]]`\n    \"\"\"\nreturn [lst[i : i + n] for i in range(0, len(lst), n)]\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.get_value_to_df","title":"<code>get_value_to_df(query, index)</code>","text":"<p>Gets the values from the AdomdDataReader to convert to python df.</p> <p>Lots of room for improvement on this one.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>AdomdDataReader</code> <p>The AdomdDataReader .Net object.</p> required <code>index</code> <code>int</code> <p>Index of the value to perform the logic on.</p> required Source code in <code>pytabular/logic_utils.py</code> <pre><code>def get_value_to_df(query: AdomdDataReader, index: int):\n\"\"\"Gets the values from the AdomdDataReader to convert to python df.\n    Lots of room for improvement on this one.\n    Args:\n        query (AdomdDataReader): The AdomdDataReader .Net object.\n        index (int): Index of the value to perform the logic on.\n    \"\"\"\nif (\nquery.GetDataTypeName((index)) in (\"Decimal\")\nand query.GetValue(index) is not None\n):\nreturn query.GetValue(index).ToDouble(query.GetValue(index))\nelse:\nreturn query.GetValue(index)\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.dataframe_to_dict","title":"<code>dataframe_to_dict(df)</code>","text":"<p>Convert to Dataframe to dictionary and alter columns names with it.</p> <p>Will convert the underscores (_) to spaces, and all strings are converted to Title Case.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Original table that needs to be converted to a list with dicts.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>list of dictionaries.</p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def dataframe_to_dict(df: pd.DataFrame) -&gt; List[dict]:\n\"\"\"Convert to Dataframe to dictionary and alter columns names with it.\n    Will convert the underscores (_) to spaces,\n    and all strings are converted to Title Case.\n    Args:\n        df (pd.DataFrame): Original table that needs to be converted\n            to a list with dicts.\n    Returns:\n        list of dictionaries.\n    \"\"\"\nlist_of_dicts = df.to_dict(\"records\")\nreturn [\n{k.replace(\"_\", \" \").title(): v for k, v in dict.items()}\nfor dict in list_of_dicts\n]\n</code></pre>"},{"location":"logic_utils/#pytabular.logic_utils.dict_to_markdown_table","title":"<code>dict_to_markdown_table(list_of_dicts, columns_to_include=None)</code>","text":"<p>Generate a Markdown table based on a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>list_of_dicts</code> <code>list</code> <p>List of Dictionaries that need to be converted to a markdown table.</p> required <code>columns_to_include</code> <code>list</code> <p>Default = None, and all colums are included. If a list is supplied, those columns will be included.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>String that will represent a table in Markdown.</p> Example <p><pre><code>    columns = ['Referenced Object Type', 'Referenced Table', 'Referenced Object']\ndict_to_markdown_table(dependancies, columns)\n</code></pre> Returns: <pre><code>    | Referenced Object Type | Referenced Table | Referenced Object               |\n    | ---------------------- | ---------------- | ------------------------------- |\n    | TABLE                  | Cases            | Cases                           |\n    | COLUMN                 | Cases            | IsClosed                        |\n    | CALC_COLUMN            | Cases            | Resolution Time (Working Hours) |\n</code></pre></p> Source code in <code>pytabular/logic_utils.py</code> <pre><code>def dict_to_markdown_table(list_of_dicts: list, columns_to_include: list = None) -&gt; str:\n\"\"\"Generate a Markdown table based on a list of dictionaries.\n    Args:\n        list_of_dicts (list): List of Dictionaries that need to be converted\n            to a markdown table.\n        columns_to_include (list): Default = None, and all colums are included.\n            If a list is supplied, those columns will be included.\n    Returns:\n        String that will represent a table in Markdown.\n    Example:\n        ```python\n            columns = ['Referenced Object Type', 'Referenced Table', 'Referenced Object']\n            dict_to_markdown_table(dependancies, columns)\n        ```\n        Returns:\n        ```\n            | Referenced Object Type | Referenced Table | Referenced Object               |\n            | ---------------------- | ---------------- | ------------------------------- |\n            | TABLE                  | Cases            | Cases                           |\n            | COLUMN                 | Cases            | IsClosed                        |\n            | CALC_COLUMN            | Cases            | Resolution Time (Working Hours) |\n        ```\n    \"\"\"\nkeys = set().union(*[set(d.keys()) for d in list_of_dicts])\nif columns_to_include is not None:\nkeys = list(keys.intersection(columns_to_include))\ntable_header = f\"| {' | '.join(map(str, keys))} |\"\ntable_header_separator = \"|-----\" * len(keys) + \"|\"\nmarkdown_table = [table_header, table_header_separator]\nfor row in list_of_dicts:\ntable_row = f\"| {' | '.join(str(row.get(key, '')) for key in keys)} |\"\nmarkdown_table.append(table_row)\nreturn \"\\n\".join(markdown_table)\n</code></pre>"},{"location":"pbi_helper/","title":"pbi_helper","text":"<p><code>pbi_helper.py</code> was reverse engineered from DaxStudio <code>PowerBiHelper.cs</code>.</p> <p>So all credit and genius should go to DaxStudio. I just wanted it in python... The main function is <code>find_local_pbi_instances()</code>. It will find any open PBIX files on your computer and spit out a connection string for you.</p>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_msmdsrv","title":"<code>get_msmdsrv()</code>","text":"<p>Runs powershel command to retrieve the ProcessId.</p> <p>Uses <code>Get-CimInstance</code> where <code>Name == 'msmdsrv.exe'</code>.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>returns ProcessId(s) in list. Formatted to account for multiple PBIX files open at the same time.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_msmdsrv() -&gt; list:\n\"\"\"Runs powershel command to retrieve the ProcessId.\n    Uses `Get-CimInstance` where `Name == 'msmdsrv.exe'`.\n    Returns:\n        list: returns ProcessId(s) in list.\n            Formatted to account for multiple PBIX files open at the same time.\n    \"\"\"\np.logger.debug(\"Retrieving msmdsrv.exe(s)\")\ntry:\nmsmdsrv = subprocess.check_output(\n[\n\"powershell\",\n\"\"\"Get-CimInstance -ClassName Win32_Process \\\n                    -Property * -Filter \"Name = 'msmdsrv.exe'\" | \\\n                    Select-Object -Property ProcessId -ExpandProperty ProcessId\"\"\",\n]\n)\nmsmdsrv_id = msmdsrv.decode().strip().splitlines()\np.logger.debug(f\"ProcessId for msmdsrv.exe {msmdsrv_id}\")\nreturn msmdsrv_id\nexcept subprocess.CalledProcessError as e:\np.logger.error(\nf\"command '{e.cmd}' return with error (code {e.returncode}): {e.output}\"\n)\np.logger.warn(\n\"Check if powershell is availabe in the PATH environment variables.\"\n)\nraise RuntimeError(\nf\"command '{e.cmd}' return with error (code {e.returncode}): {e.output}\"\n) from e\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_port_number","title":"<code>get_port_number(msmdsrv)</code>","text":"<p>Gets the local port number of given msmdsrv ProcessId. Via PowerShell.</p> <p>Parameters:</p> Name Type Description Default <code>msmdsrv</code> <code>str</code> <p>A ProcessId returned from <code>get_msmdsrv()</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p><code>LocalPort</code> returned for specific ProcessId.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_port_number(msmdsrv: str) -&gt; str:\n\"\"\"Gets the local port number of given msmdsrv ProcessId. Via PowerShell.\n    Args:\n        msmdsrv (str): A ProcessId returned from `get_msmdsrv()`.\n    Returns:\n        str: `LocalPort` returned for specific ProcessId.\n    \"\"\"\nport = subprocess.check_output(\n[\n\"powershell\",\nf\"Get-NetTCPConnection -State Listen \\\n                -OwningProcess {msmdsrv} | Select-Object \\\n                -Property LocalPort -First 1 -ExpandProperty LocalPort\",\n]\n)\nport_number = port.decode().strip()\np.logger.debug(f\"Listening port - {port_number} for msmdsrv.exe - {msmdsrv}\")\nreturn port_number\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_parent_id","title":"<code>get_parent_id(msmdsrv)</code>","text":"<p>Gets ParentProcessId via PowerShell from the msmdsrv ProcessId.</p> <p>Parameters:</p> Name Type Description Default <code>msmdsrv</code> <code>str</code> <p>A ProcessId returned from <code>get_msmdsrv()</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Returns ParentProcessId in <code>str</code> format.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_parent_id(msmdsrv: str) -&gt; str:\n\"\"\"Gets ParentProcessId via PowerShell from the msmdsrv ProcessId.\n    Args:\n        msmdsrv (str):  A ProcessId returned from `get_msmdsrv()`.\n    Returns:\n        str: Returns ParentProcessId in `str` format.\n    \"\"\"\nparent = subprocess.check_output(\n[\n\"powershell\",\nf'Get-CimInstance -ClassName Win32_Process -Property * \\\n                -Filter \"ProcessId = {msmdsrv}\" | \\\n                Select-Object -Property ParentProcessId -ExpandProperty ParentProcessId',\n]\n)\nparent_id = parent.decode().strip()\np.logger.debug(f\"ProcessId - {parent_id} for parent of msmdsrv.exe - {msmdsrv}\")\nreturn parent_id\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.get_parent_title","title":"<code>get_parent_title(parent_id)</code>","text":"<p>Takes the ParentProcessId and gets the name of the PBIX file.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>Takes ParentProcessId which can be retrieved from <code>get_parent_id(msmdsrv)</code></p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Returns str of title of PBIX file.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def get_parent_title(parent_id: str) -&gt; str:\n\"\"\"Takes the ParentProcessId and gets the name of the PBIX file.\n    Args:\n        parent_id (str): Takes ParentProcessId which can be retrieved from `get_parent_id(msmdsrv)`\n    Returns:\n        str: Returns str of title of PBIX file.\n    \"\"\"\npbi_title_suffixes: list = [\n\" \\u002D Power BI Desktop\",  # Dash Punctuation - minus hyphen\n\" \\u2212 Power BI Desktop\",  # Math Symbol - minus sign\n\" \\u2011 Power BI Desktop\",  # Dash Punctuation - non-breaking hyphen\n\" \\u2013 Power BI Desktop\",  # Dash Punctuation - en dash\n\" \\u2014 Power BI Desktop\",  # Dash Punctuation - em dash\n\" \\u2015 Power BI Desktop\",  # Dash Punctuation - horizontal bar\n]\ntitle = subprocess.check_output(\n[\"powershell\", f\"\"\"(Get-Process -Id {parent_id}).MainWindowTitle\"\"\"]\n)\ntitle_name = title.decode().strip()\nfor suffix in pbi_title_suffixes:\ntitle_name = title_name.replace(suffix, \"\")\np.logger.debug(f\"Title - {title_name} for {parent_id}\")\nreturn title_name\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.create_connection_str","title":"<code>create_connection_str(port_number)</code>","text":"<p>This takes the port number and adds to connection string.</p> <p>This is pretty bland right now, may improve later.</p> <p>Parameters:</p> Name Type Description Default <code>port_number</code> <code>str</code> <p>port number retrieved from <code>get_port_number(msmdsrv)</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>port number as string.</p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def create_connection_str(port_number: str) -&gt; str:\n\"\"\"This takes the port number and adds to connection string.\n    This is pretty bland right now, may improve later.\n    Args:\n        port_number (str): port number retrieved from `get_port_number(msmdsrv)`.\n    Returns:\n        str: port number as string.\n    \"\"\"\nconnection_str = f\"Data Source=localhost:{port_number}\"\np.logger.debug(f\"Local Connection Str - {connection_str}\")\nreturn connection_str\n</code></pre>"},{"location":"pbi_helper/#pytabular.pbi_helper.find_local_pbi_instances","title":"<code>find_local_pbi_instances()</code>","text":"<p>The real genius is from Dax Studio.</p> <p>I just wanted it in python not C#, so reverse engineered what DaxStudio did. It will run some powershell scripts to pull the appropriate info. Then will spit out a list with tuples inside. You can use the connection string to connect to your model with pytabular. Dax Studio.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>EX <code>[('PBI File Name1','localhost:{port}'),('PBI File Name2','localhost:{port}')]</code></p> Source code in <code>pytabular/pbi_helper.py</code> <pre><code>def find_local_pbi_instances() -&gt; list:\n\"\"\"The real genius is from Dax Studio.\n    I just wanted it in python not C#, so reverse engineered what DaxStudio did.\n    It will run some powershell scripts to pull the appropriate info.\n    Then will spit out a list with tuples inside.\n    You can use the connection string to connect to your model with pytabular.\n    [Dax Studio](https://github.com/DaxStudio/DaxStudio/blob/master/src/DaxStudio.UI/Utils/PowerBIHelper.cs).\n    Returns:\n        list: EX `[('PBI File Name1','localhost:{port}'),('PBI File Name2','localhost:{port}')]`\n    \"\"\"  # noqa: E501\ninstances = get_msmdsrv()\npbi_instances = []\nfor instance in instances:\np.logger.debug(f\"Building connection for {instance}\")\nport = get_port_number(instance)\nparent = get_parent_id(instance)\ntitle = get_parent_title(parent)\nconnect_str = create_connection_str(port)\npbi_instances += [(title, connect_str)]\nreturn pbi_instances\n</code></pre>"},{"location":"query/","title":"Query Model","text":"<p><code>query.py</code> houses a custom <code>Connection</code> class that uses the .Net AdomdConnection.</p> <p><code>Connection</code> is created automatically when connecting to your model.</p>"},{"location":"query/#pytabular.query.Connection","title":"<code>Connection</code>","text":"<p>         Bases: <code>AdomdConnection</code></p> <p>Connection class creates an AdomdConnection.</p> <p>Mainly used for the <code>query()</code> method. The <code>query()</code> method in the Tabular class is just a wrapper for this class. But you can pass through your <code>effective_user</code> more efficiently, so use that instead.</p> Source code in <code>pytabular/query.py</code> <pre><code>class Connection(AdomdConnection):\n\"\"\"Connection class creates an AdomdConnection.\n    Mainly used for the `query()` method. The `query()`\n    method in the Tabular class is just a wrapper for this class.\n    But you can pass through your `effective_user` more efficiently,\n    so use that instead.\n    \"\"\"\ndef __init__(self, server, effective_user=None) -&gt; None:\n\"\"\"Init creates the connection.\n        Args:\n            server (Server): The server that you are connecting to.\n            effective_user (str, optional): Pass through an effective user\n                to query as somebody else. Defaults to None.\n        \"\"\"\nsuper().__init__()\nif server.ConnectionInfo.Password is None:\nconnection_string = server.ConnectionString\nelse:\nconnection_string = (\nf\"{server.ConnectionString}Password='{server.ConnectionInfo.Password}'\"\n)\nlogger.debug(f\"{connection_string}\")\nif effective_user is not None:\nconnection_string += f\";EffectiveUserName={effective_user}\"\nself.ConnectionString = connection_string\ndef query(self, query_str: str) -&gt; Union[pd.DataFrame, str, int]:\n\"\"\"Executes query on Model and returns results in Pandas DataFrame.\n        Iterates through results of `AdomdCommmand().ExecuteReader()`\n        in the .Net library. If result is a single value, it will\n        return that single value instead of DataFrame.\n        Args:\n            query_str (str): Dax Query. Note, needs full syntax\n                (ex: `EVALUATE`). See [DAX](https://docs.microsoft.com/en-us/dax/dax-queries).\n                Will check if query string is a file.\n                If it is, then it will perform a query\n                on whatever is read from the file.\n                It is also possible to query DMV.\n                For example.\n                `query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")`.\n        Returns:\n            pd.DataFrame: Returns dataframe with results.\n        \"\"\"\ntry:\nis_file = os.path.isfile(query_str)\nexcept Exception:\nis_file = False\nif is_file:\nlogger.debug(\nf\"File path detected, reading file... -&gt; {query_str}\",\n)\nwith open(query_str, \"r\") as file:\nquery_str = str(file.read())\nif str(self.get_State()) != \"Open\":\n# Works for now, need to update to handle different types of conneciton properties\n# https://learn.microsoft.com/en-us/dotnet/api/system.data.connectionstate?view=net-7.0\nlogger.info(\"Checking initial Adomd Connection...\")\nself.Open()\nlogger.info(f\"Connected! Session ID - {self.SessionID}\")\nlogger.debug(\"Querying Model...\")\nlogger.debug(query_str)\nquery = AdomdCommand(query_str, self).ExecuteReader()\ncolumn_headers = [\n(index, query.GetName(index)) for index in range(0, query.FieldCount)\n]\nresults = list()\nwhile query.Read():\nresults.append(\n[\nget_value_to_df(query, index)\nfor index in range(0, len(column_headers))\n]\n)\nquery.Close()\nlogger.debug(\"Data retrieved... reading...\")\ndf = pd.DataFrame(results, columns=[value for _, value in column_headers])\nif len(df) == 1 and len(df.columns) == 1:\nreturn df.iloc[0][df.columns[0]]\nreturn df\n</code></pre>"},{"location":"query/#pytabular.query.Connection.__init__","title":"<code>__init__(server, effective_user=None)</code>","text":"<p>Init creates the connection.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>Server</code> <p>The server that you are connecting to.</p> required <code>effective_user</code> <code>str</code> <p>Pass through an effective user to query as somebody else. Defaults to None.</p> <code>None</code> Source code in <code>pytabular/query.py</code> <pre><code>def __init__(self, server, effective_user=None) -&gt; None:\n\"\"\"Init creates the connection.\n    Args:\n        server (Server): The server that you are connecting to.\n        effective_user (str, optional): Pass through an effective user\n            to query as somebody else. Defaults to None.\n    \"\"\"\nsuper().__init__()\nif server.ConnectionInfo.Password is None:\nconnection_string = server.ConnectionString\nelse:\nconnection_string = (\nf\"{server.ConnectionString}Password='{server.ConnectionInfo.Password}'\"\n)\nlogger.debug(f\"{connection_string}\")\nif effective_user is not None:\nconnection_string += f\";EffectiveUserName={effective_user}\"\nself.ConnectionString = connection_string\n</code></pre>"},{"location":"query/#pytabular.query.Connection.query","title":"<code>query(query_str)</code>","text":"<p>Executes query on Model and returns results in Pandas DataFrame.</p> <p>Iterates through results of <code>AdomdCommmand().ExecuteReader()</code> in the .Net library. If result is a single value, it will return that single value instead of DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>Dax Query. Note, needs full syntax (ex: <code>EVALUATE</code>). See DAX. Will check if query string is a file. If it is, then it will perform a query on whatever is read from the file. It is also possible to query DMV. For example. <code>query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")</code>.</p> required <p>Returns:</p> Type Description <code>Union[pd.DataFrame, str, int]</code> <p>pd.DataFrame: Returns dataframe with results.</p> Source code in <code>pytabular/query.py</code> <pre><code>def query(self, query_str: str) -&gt; Union[pd.DataFrame, str, int]:\n\"\"\"Executes query on Model and returns results in Pandas DataFrame.\n    Iterates through results of `AdomdCommmand().ExecuteReader()`\n    in the .Net library. If result is a single value, it will\n    return that single value instead of DataFrame.\n    Args:\n        query_str (str): Dax Query. Note, needs full syntax\n            (ex: `EVALUATE`). See [DAX](https://docs.microsoft.com/en-us/dax/dax-queries).\n            Will check if query string is a file.\n            If it is, then it will perform a query\n            on whatever is read from the file.\n            It is also possible to query DMV.\n            For example.\n            `query(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")`.\n    Returns:\n        pd.DataFrame: Returns dataframe with results.\n    \"\"\"\ntry:\nis_file = os.path.isfile(query_str)\nexcept Exception:\nis_file = False\nif is_file:\nlogger.debug(\nf\"File path detected, reading file... -&gt; {query_str}\",\n)\nwith open(query_str, \"r\") as file:\nquery_str = str(file.read())\nif str(self.get_State()) != \"Open\":\n# Works for now, need to update to handle different types of conneciton properties\n# https://learn.microsoft.com/en-us/dotnet/api/system.data.connectionstate?view=net-7.0\nlogger.info(\"Checking initial Adomd Connection...\")\nself.Open()\nlogger.info(f\"Connected! Session ID - {self.SessionID}\")\nlogger.debug(\"Querying Model...\")\nlogger.debug(query_str)\nquery = AdomdCommand(query_str, self).ExecuteReader()\ncolumn_headers = [\n(index, query.GetName(index)) for index in range(0, query.FieldCount)\n]\nresults = list()\nwhile query.Read():\nresults.append(\n[\nget_value_to_df(query, index)\nfor index in range(0, len(column_headers))\n]\n)\nquery.Close()\nlogger.debug(\"Data retrieved... reading...\")\ndf = pd.DataFrame(results, columns=[value for _, value in column_headers])\nif len(df) == 1 and len(df.columns) == 1:\nreturn df.iloc[0][df.columns[0]]\nreturn df\n</code></pre>"},{"location":"refresh/","title":"Refresh Model","text":"<p><code>refresh.py</code> is the main file to handle all the components of refreshing your model.</p> <p>See the <code>PyTable(s)</code> and <code>PyPartition(s)</code> classes. Use the <code>refresh</code> method from their.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck","title":"<code>RefreshCheck</code>","text":"<p>         Bases: <code>ABC</code></p> <p><code>RefreshCheck</code> is an test you run after your refreshes.</p> <p>It will run the given <code>function</code> before and after refreshes, then run the assertion of before and after. The default given in a refresh is to check row count. It will check row count before, and row count after. Then fail if row count after is zero.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class RefreshCheck(ABC):\n\"\"\"`RefreshCheck` is an test you run after your refreshes.\n    It will run the given `function` before and after refreshes,\n    then run the assertion of before and after.\n    The default given in a refresh is to check row count.\n    It will check row count before, and row count after.\n    Then fail if row count after is zero.\n    \"\"\"\ndef __init__(self, name: str, function, assertion=None) -&gt; None:\n\"\"\"Sets the necessary components to perform a refresh check.\n        Args:\n            name (str): Name of refresh check.\n            function (Callable): Function to run on pre and post checks.\n                    For example, a dax query. readme has examples of this.\n            assertion (Callable, optional): A function that can be run.\n                    Supply the assertion function with 2 arguments. The first one\n                    for your 'pre' results from the `function` argument. The second\n                    for your `post` results from the`function` argument.\n                    Return `True` or `False` depending on the comparison of the two arguments\n                    to determine a pass or fail status of your refresh.\n                    Defaults to None.\n        \"\"\"\nsuper().__init__()\nself._name = name\nself._function = function\nself._assertion = assertion\nself._pre = None\nself._post = None\ndef __repr__(self) -&gt; str:\n\"\"\"`__repre__` that returns details on `RefreshCheck`.\"\"\"\nreturn f\"{self.name} - {self.pre} - {self.post} - {str(self.function)}\"\n@property\ndef name(self):\n\"\"\"Get your custom name of refresh check.\"\"\"\nreturn self._name\n@name.setter\ndef name(self, name):\nself._name = name\n@name.deleter\ndef name(self):\ndel self._name\n@property\ndef function(self):\n\"\"\"Get the function that is used to run a pre and post check.\"\"\"\nreturn self._function\n@function.setter\ndef function(self, func):\nself._function = func\n@function.deleter\ndef function(self):\ndel self._function\n@property\ndef pre(self):\n\"\"\"Get the pre value that is the result from the pre refresh check.\"\"\"\nreturn self._pre\n@pre.setter\ndef pre(self, pre):\nself._pre = pre\n@pre.deleter\ndef pre(self):\ndel self._pre\n@property\ndef post(self):\n\"\"\"Get the post value that is the result from the post refresh check.\"\"\"\nreturn self._post\n@post.setter\ndef post(self, post):\nself._post = post\n@post.deleter\ndef post(self):\ndel self._post\n@property\ndef assertion(self):\n\"\"\"Get the assertion that is the result from the post refresh check.\"\"\"\nreturn self._assertion\n@assertion.setter\ndef assertion(self, assertion):\nself._assertion = assertion\n@assertion.deleter\ndef assertion(self):\ndel self._assertion\ndef _check(self, stage: str):\n\"\"\"Runs the given function and stores results.\n        Stored in either `self.pre` or `self.post` depending on `stage`.\n        Args:\n            stage (str): Either 'Pre' or 'Post'\n        Returns:\n            object: Returns the results of the pre or post check.\n        \"\"\"\nlogger.debug(f\"Running {stage}-Check for {self.name}\")\nresults = self.function()\nif stage == \"Pre\":\nself.pre = results\nelse:\nself.post = results\nlogger.info(f\"{stage}-Check results for {self.name} - {results}\")\nreturn results\ndef pre_check(self):\n\"\"\"Runs `self._check(\"Pre\")`.\"\"\"\nself._check(\"Pre\")\npass\ndef post_check(self):\n\"\"\"Runs `self._check(\"Post\")` then `self.assertion_run()`.\"\"\"\nself._check(\"Post\")\nself.assertion_run()\npass\ndef assertion_run(self):\n\"\"\"Runs the given self.assertion function with `self.pre` and `self.post`.\n        So, `self.assertion_run(self.pre, self.post)`.\n        \"\"\"\nif self.assertion is None:\nlogger.debug(\"Skipping assertion none given\")\nelse:\ntest = self.assertion(self.pre, self.post)\nassert_str = f\"Test {self.name} - {test} - Pre Results - {self.pre} | Post Results {self.post}\"  # noqa: E501\nif test:\nlogger.info(assert_str)\nelse:\nlogger.critical(assert_str)\nassert (\ntest\n), f\"Test failed! Pre Results - {self.pre} | Post Results {self.post}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.name","title":"<code>name</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get your custom name of refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.function","title":"<code>function</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the function that is used to run a pre and post check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.pre","title":"<code>pre</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the pre value that is the result from the pre refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.post","title":"<code>post</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the post value that is the result from the post refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.assertion","title":"<code>assertion</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Get the assertion that is the result from the post refresh check.</p>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.__init__","title":"<code>__init__(name, function, assertion=None)</code>","text":"<p>Sets the necessary components to perform a refresh check.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of refresh check.</p> required <code>function</code> <code>Callable</code> <p>Function to run on pre and post checks.     For example, a dax query. readme has examples of this.</p> required <code>assertion</code> <code>Callable</code> <p>A function that can be run.     Supply the assertion function with 2 arguments. The first one     for your 'pre' results from the <code>function</code> argument. The second     for your <code>post</code> results from the<code>function</code> argument.     Return <code>True</code> or <code>False</code> depending on the comparison of the two arguments     to determine a pass or fail status of your refresh.     Defaults to None.</p> <code>None</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(self, name: str, function, assertion=None) -&gt; None:\n\"\"\"Sets the necessary components to perform a refresh check.\n    Args:\n        name (str): Name of refresh check.\n        function (Callable): Function to run on pre and post checks.\n                For example, a dax query. readme has examples of this.\n        assertion (Callable, optional): A function that can be run.\n                Supply the assertion function with 2 arguments. The first one\n                for your 'pre' results from the `function` argument. The second\n                for your `post` results from the`function` argument.\n                Return `True` or `False` depending on the comparison of the two arguments\n                to determine a pass or fail status of your refresh.\n                Defaults to None.\n    \"\"\"\nsuper().__init__()\nself._name = name\nself._function = function\nself._assertion = assertion\nself._pre = None\nself._post = None\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.__repr__","title":"<code>__repr__()</code>","text":"<p><code>__repre__</code> that returns details on <code>RefreshCheck</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"`__repre__` that returns details on `RefreshCheck`.\"\"\"\nreturn f\"{self.name} - {self.pre} - {self.post} - {str(self.function)}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.pre_check","title":"<code>pre_check()</code>","text":"<p>Runs <code>self._check(\"Pre\")</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def pre_check(self):\n\"\"\"Runs `self._check(\"Pre\")`.\"\"\"\nself._check(\"Pre\")\npass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.post_check","title":"<code>post_check()</code>","text":"<p>Runs <code>self._check(\"Post\")</code> then <code>self.assertion_run()</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def post_check(self):\n\"\"\"Runs `self._check(\"Post\")` then `self.assertion_run()`.\"\"\"\nself._check(\"Post\")\nself.assertion_run()\npass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheck.assertion_run","title":"<code>assertion_run()</code>","text":"<p>Runs the given self.assertion function with <code>self.pre</code> and <code>self.post</code>.</p> <p>So, <code>self.assertion_run(self.pre, self.post)</code>.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def assertion_run(self):\n\"\"\"Runs the given self.assertion function with `self.pre` and `self.post`.\n    So, `self.assertion_run(self.pre, self.post)`.\n    \"\"\"\nif self.assertion is None:\nlogger.debug(\"Skipping assertion none given\")\nelse:\ntest = self.assertion(self.pre, self.post)\nassert_str = f\"Test {self.name} - {test} - Pre Results - {self.pre} | Post Results {self.post}\"  # noqa: E501\nif test:\nlogger.info(assert_str)\nelse:\nlogger.critical(assert_str)\nassert (\ntest\n), f\"Test failed! Pre Results - {self.pre} | Post Results {self.post}\"\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection","title":"<code>RefreshCheckCollection</code>","text":"<p>Groups together your <code>RefreshChecks</code>.</p> <p>Used to handle multiple types of checks in a single refresh.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class RefreshCheckCollection:\n\"\"\"Groups together your `RefreshChecks`.\n    Used to handle multiple types of checks in a single refresh.\n    \"\"\"\ndef __init__(self, refresh_checks: RefreshCheck = []) -&gt; None:\n\"\"\"Init to supply RefreshChecks.\n        Args:\n            refresh_checks (RefreshCheck, optional): Defaults to [].\n        \"\"\"\nself._refreshchecks = refresh_checks\npass\ndef __iter__(self):\n\"\"\"Basic iteration through the different `RefreshCheck`(s).\"\"\"\nfor refresh_check in self._refreshchecks:\nyield refresh_check\ndef add_refresh_check(self, refresh_check: RefreshCheck):\n\"\"\"Add a RefreshCheck.\n        Supply the `RefreshCheck` to add.\n        Args:\n            refresh_check (RefreshCheck): `RefreshCheck` class.\n        \"\"\"\nself._refreshchecks.append(refresh_check)\ndef remove_refresh_check(self, refresh_check: RefreshCheck):\n\"\"\"Remove a RefreshCheck.\n        Supply the `RefreshCheck` to remove.\n        Args:\n            refresh_check (RefreshCheck): `RefreshCheck` class.\n        \"\"\"\nself._refreshchecks.remove(refresh_check)\ndef clear_refresh_checks(self):\n\"\"\"Clear Refresh Checks.\"\"\"\nself._refreshchecks.clear()\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.__init__","title":"<code>__init__(refresh_checks=[])</code>","text":"<p>Init to supply RefreshChecks.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_checks</code> <code>RefreshCheck</code> <p>Defaults to [].</p> <code>[]</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(self, refresh_checks: RefreshCheck = []) -&gt; None:\n\"\"\"Init to supply RefreshChecks.\n    Args:\n        refresh_checks (RefreshCheck, optional): Defaults to [].\n    \"\"\"\nself._refreshchecks = refresh_checks\npass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.__iter__","title":"<code>__iter__()</code>","text":"<p>Basic iteration through the different <code>RefreshCheck</code>(s).</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def __iter__(self):\n\"\"\"Basic iteration through the different `RefreshCheck`(s).\"\"\"\nfor refresh_check in self._refreshchecks:\nyield refresh_check\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.add_refresh_check","title":"<code>add_refresh_check(refresh_check)</code>","text":"<p>Add a RefreshCheck.</p> <p>Supply the <code>RefreshCheck</code> to add.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_check</code> <code>RefreshCheck</code> <p><code>RefreshCheck</code> class.</p> required Source code in <code>pytabular/refresh.py</code> <pre><code>def add_refresh_check(self, refresh_check: RefreshCheck):\n\"\"\"Add a RefreshCheck.\n    Supply the `RefreshCheck` to add.\n    Args:\n        refresh_check (RefreshCheck): `RefreshCheck` class.\n    \"\"\"\nself._refreshchecks.append(refresh_check)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.remove_refresh_check","title":"<code>remove_refresh_check(refresh_check)</code>","text":"<p>Remove a RefreshCheck.</p> <p>Supply the <code>RefreshCheck</code> to remove.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_check</code> <code>RefreshCheck</code> <p><code>RefreshCheck</code> class.</p> required Source code in <code>pytabular/refresh.py</code> <pre><code>def remove_refresh_check(self, refresh_check: RefreshCheck):\n\"\"\"Remove a RefreshCheck.\n    Supply the `RefreshCheck` to remove.\n    Args:\n        refresh_check (RefreshCheck): `RefreshCheck` class.\n    \"\"\"\nself._refreshchecks.remove(refresh_check)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.RefreshCheckCollection.clear_refresh_checks","title":"<code>clear_refresh_checks()</code>","text":"<p>Clear Refresh Checks.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def clear_refresh_checks(self):\n\"\"\"Clear Refresh Checks.\"\"\"\nself._refreshchecks.clear()\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh","title":"<code>PyRefresh</code>","text":"<p>PyRefresh Class to handle refreshes of model.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>class PyRefresh:\n\"\"\"PyRefresh Class to handle refreshes of model.\"\"\"\ndef __init__(\nself,\nmodel,\nobject: Union[str, PyTable, PyPartition, Dict[str, Any]],\ntrace: BaseTrace = RefreshTrace,\nrefresh_checks: RefreshCheckCollection = RefreshCheckCollection(),\ndefault_row_count_check: bool = True,\nrefresh_type: RefreshType = RefreshType.Full,\n) -&gt; None:\n\"\"\"Init when a refresh is requested.\n        Runs through requested tables and partitions\n        to make sure they are in model.\n        Then will run pre checks on the requested objects.\n        Args:\n            model (Tabular): Tabular model.\n            object (Union[str, PyTable, PyPartition, Dict[str, Any]]): The objects\n                that you are wanting to refresh. Can be a `PyTable`, `PyPartition`,\n                `TABLE_NAME` string, or a dict with `{TABLE_REFERENCE:PARTITION_REFERENCE}`\n            trace (BaseTrace, optional): Defaults to RefreshTrace.\n            refresh_checks (RefreshCheckCollection, optional): Defaults to RefreshCheckCollection().\n            default_row_count_check (bool, optional): Defaults to True.\n            refresh_type (RefreshType, optional): Defaults to RefreshType.Full.\n        \"\"\"\nself.model = model\nself.object = object\nself.trace = trace\nself.default_row_count_check = default_row_count_check\nself.refresh_type = refresh_type\nself._objects_to_refresh = []\nself._request_refresh(self.object)\nself._checks = refresh_checks\nself._pre_checks()\nlogger.info(\"Refresh Request Completed!\")\npass\ndef _pre_checks(self):\n\"\"\"Checks if any `BaseTrace` classes are needed from `tabular_tracing.py`.\n        Then checks if any `RefreshChecks` are needed, along with the default `row_count` check.\n        \"\"\"\nlogger.debug(\"Running Pre-checks\")\nif self.trace is not None:\nlogger.debug(\"Getting Trace\")\nself.trace = self._get_trace()\nif self.default_row_count_check:\nlogger.debug(\nf\"Running default row count check - {self.default_row_count_check}\"\n)\ntables = [\ntable\nfor refresh_dict in self._objects_to_refresh\nfor table in refresh_dict.keys()\n]\ndef row_count_assertion(pre, post):\n\"\"\"Checks if table refreshed zero rows.\"\"\"\npost = 0 if post is None else post\nreturn post &gt; 0\nfor table in set(tables):\ncheck = RefreshCheck(\nf\"{table.Name} Row Count\", table.row_count, row_count_assertion\n)\nself._checks.add_refresh_check(check)\nfor check in self._checks:\ncheck.pre_check()\npass\ndef _post_checks(self):\n\"\"\"If traces are running it Stops and Drops it.\n        Runs through any `post_checks()` in `RefreshChecks`.\n        \"\"\"\nif self.trace is not None:\nself.trace.stop()\nself.trace.drop()\nfor check in self._checks:\ncheck.post_check()\n# self._checks.remove_refresh_check(check)\nself._checks.clear_refresh_checks()\npass\ndef _get_trace(self) -&gt; BaseTrace:\n\"\"\"Creates Trace and creates it in model.\"\"\"\nreturn self.trace(self.model)\ndef _find_table(self, table_str: str) -&gt; Table:\n\"\"\"Finds table in `PyTables` class.\"\"\"\ntry:\nresult = self.model.Tables[table_str]\nexcept Exception:\nraise Exception(f\"Unable to find table! from {table_str}\")\nlogger.debug(f\"Found table {result.Name}\")\nreturn result\ndef _find_partition(self, table: Table, partition_str: str) -&gt; Partition:\n\"\"\"Finds partition in `PyPartitions` class.\"\"\"\ntry:\nresult = table.Partitions[partition_str]\nexcept Exception:\nraise Exception(f\"Unable to find partition! {table.Name}|{partition_str}\")\nlogger.debug(f\"Found partition {result.Table.Name}|{result.Name}\")\nreturn result\ndef _refresh_table(self, table: PyTable) -&gt; None:\n\"\"\"Runs .Net `RequestRefresh()` on table.\"\"\"\nlogging.info(f\"Requesting refresh for {table.Name}\")\nself._objects_to_refresh += [\n{table: [partition for partition in table.Partitions]}\n]\ntable.RequestRefresh(self.refresh_type)\ndef _refresh_partition(self, partition: PyPartition) -&gt; None:\n\"\"\"Runs .Net `RequestRefresh()` on partition.\"\"\"\nlogging.info(f\"Requesting refresh for {partition.Table.Name}|{partition.Name}\")\nself._objects_to_refresh += [{partition.Table: [partition]}]\npartition.RequestRefresh(self.refresh_type)\ndef _refresh_dict(self, partition_dict: Dict) -&gt; None:\n\"\"\"Handles refreshes if argument given was a dictionary.\"\"\"\nfor table in partition_dict.keys():\ntable_object = self._find_table(table) if isinstance(table, str) else table\ndef handle_partitions(object):\n\"\"\"Figures out if partition argument given is a str or an actual `PyPartition`.\n                Then will run `self._refresh_partition()` appropriately.\n                \"\"\"\nif isinstance(object, str):\nself._refresh_partition(self._find_partition(table_object, object))\nelif isinstance(object, PyPartition):\nself._refresh_partition(object)\nelse:\n[handle_partitions(obj) for obj in object]\nhandle_partitions(partition_dict[table])\ndef _request_refresh(self, object):\n\"\"\"Base method to parse through argument and figure out what needs to be refreshed.\n        Someone please make this better...\n        \"\"\"\nlogger.debug(f\"Requesting Refresh for {object}\")\nif isinstance(object, str):\nself._refresh_table(self._find_table(object))\nelif isinstance(object, PyTables):\n[self._refresh_table(table) for table in object]\nelif isinstance(object, Dict):\nself._refresh_dict(object)\nelif isinstance(object, PyTable):\nself._refresh_table(object)\nelif isinstance(object, PyPartition):\nself._refresh_partition(object)\nelse:\n[self._request_refresh(obj) for obj in object]\ndef _refresh_report(self, property_changes) -&gt; pd.DataFrame:\n\"\"\"Builds a DataFrame that displays details on the refresh.\n        Args:\n            Property_Changes: Which is returned from `model.save_changes()`\n        Returns:\n            pd.DataFrame: DataFrame of refresh details.\n        \"\"\"\nlogger.debug(\"Running Refresh Report...\")\nrefresh_data = []\nfor property_change in property_changes:\nif (\nisinstance(property_change.object, Partition)\nand property_change.property_name == \"RefreshedTime\"\n):\ntable, partition, refreshed_time = (\nproperty_change.object.Table.Name,\nproperty_change.object.Name,\nticks_to_datetime(property_change.new_value.Ticks),\n)\nlogger.info(\nf'{table} - {partition} Refreshed! - {refreshed_time.strftime(\"%m/%d/%Y, %H:%M:%S\")}'  # noqa: E501\n)\nrefresh_data += [[table, partition, refreshed_time]]\nreturn pd.DataFrame(\nrefresh_data, columns=[\"Table\", \"Partition\", \"Refreshed Time\"]\n)\ndef run(self) -&gt; pd.DataFrame:\n\"\"\"When ready, execute to start the refresh process.\n        First checks if connected and reconnects if needed.\n        Then starts the trace if needed.\n        Next will execute `save_changes()`\n        and run the post checks after that.\n        Last will return a `pd.DataFrame` of refresh results.\n        \"\"\"\nif self.model.Server.Connected is False:\nlogger.info(f\"{self.Server.Name} - Reconnecting...\")\nself.model.reconnect()\nif self.trace is not None:\nself.trace.start()\nsave_changes = self.model.save_changes()\nself._post_checks()\nreturn self._refresh_report(save_changes.property_changes)\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh.__init__","title":"<code>__init__(model, object, trace=RefreshTrace, refresh_checks=RefreshCheckCollection(), default_row_count_check=True, refresh_type=RefreshType.Full)</code>","text":"<p>Init when a refresh is requested.</p> <p>Runs through requested tables and partitions to make sure they are in model. Then will run pre checks on the requested objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Tabular</code> <p>Tabular model.</p> required <code>object</code> <code>Union[str, PyTable, PyPartition, Dict[str, Any]]</code> <p>The objects that you are wanting to refresh. Can be a <code>PyTable</code>, <code>PyPartition</code>, <code>TABLE_NAME</code> string, or a dict with <code>{TABLE_REFERENCE:PARTITION_REFERENCE}</code></p> required <code>trace</code> <code>BaseTrace</code> <p>Defaults to RefreshTrace.</p> <code>RefreshTrace</code> <code>refresh_checks</code> <code>RefreshCheckCollection</code> <p>Defaults to RefreshCheckCollection().</p> <code>RefreshCheckCollection()</code> <code>default_row_count_check</code> <code>bool</code> <p>Defaults to True.</p> <code>True</code> <code>refresh_type</code> <code>RefreshType</code> <p>Defaults to RefreshType.Full.</p> <code>RefreshType.Full</code> Source code in <code>pytabular/refresh.py</code> <pre><code>def __init__(\nself,\nmodel,\nobject: Union[str, PyTable, PyPartition, Dict[str, Any]],\ntrace: BaseTrace = RefreshTrace,\nrefresh_checks: RefreshCheckCollection = RefreshCheckCollection(),\ndefault_row_count_check: bool = True,\nrefresh_type: RefreshType = RefreshType.Full,\n) -&gt; None:\n\"\"\"Init when a refresh is requested.\n    Runs through requested tables and partitions\n    to make sure they are in model.\n    Then will run pre checks on the requested objects.\n    Args:\n        model (Tabular): Tabular model.\n        object (Union[str, PyTable, PyPartition, Dict[str, Any]]): The objects\n            that you are wanting to refresh. Can be a `PyTable`, `PyPartition`,\n            `TABLE_NAME` string, or a dict with `{TABLE_REFERENCE:PARTITION_REFERENCE}`\n        trace (BaseTrace, optional): Defaults to RefreshTrace.\n        refresh_checks (RefreshCheckCollection, optional): Defaults to RefreshCheckCollection().\n        default_row_count_check (bool, optional): Defaults to True.\n        refresh_type (RefreshType, optional): Defaults to RefreshType.Full.\n    \"\"\"\nself.model = model\nself.object = object\nself.trace = trace\nself.default_row_count_check = default_row_count_check\nself.refresh_type = refresh_type\nself._objects_to_refresh = []\nself._request_refresh(self.object)\nself._checks = refresh_checks\nself._pre_checks()\nlogger.info(\"Refresh Request Completed!\")\npass\n</code></pre>"},{"location":"refresh/#pytabular.refresh.PyRefresh.run","title":"<code>run()</code>","text":"<p>When ready, execute to start the refresh process.</p> <p>First checks if connected and reconnects if needed. Then starts the trace if needed. Next will execute <code>save_changes()</code> and run the post checks after that. Last will return a <code>pd.DataFrame</code> of refresh results.</p> Source code in <code>pytabular/refresh.py</code> <pre><code>def run(self) -&gt; pd.DataFrame:\n\"\"\"When ready, execute to start the refresh process.\n    First checks if connected and reconnects if needed.\n    Then starts the trace if needed.\n    Next will execute `save_changes()`\n    and run the post checks after that.\n    Last will return a `pd.DataFrame` of refresh results.\n    \"\"\"\nif self.model.Server.Connected is False:\nlogger.info(f\"{self.Server.Name} - Reconnecting...\")\nself.model.reconnect()\nif self.trace is not None:\nself.trace.start()\nsave_changes = self.model.save_changes()\nself._post_checks()\nreturn self._refresh_report(save_changes.property_changes)\n</code></pre>"},{"location":"tabular_editor/","title":"tabular_editor","text":"<p>This has a <code>Tabular_Editor</code> class which will download TE2 from a default location.</p> <p>Or you can input your own location.</p>"},{"location":"tabular_editor/#pytabular.tabular_editor.TabularEditor","title":"<code>TabularEditor</code>","text":"<p>Setting Tabular_Editor Class for future work.</p> <p>Mainly runs <code>download_tabular_editor()</code></p> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>class TabularEditor:\n\"\"\"Setting Tabular_Editor Class for future work.\n    Mainly runs `download_tabular_editor()`\n    \"\"\"\ndef __init__(self, exe_file_path: str = \"Default\") -&gt; None:\n\"\"\"Init for `TabularEditor()` class.\n        This is mostly a placeholder right now.\n        But useful if you want an easy way to download TE2.\n        Args:\n            exe_file_path (str, optional): File path where TE2 lives. Defaults to \"Default\".\n                If \"Default\", it will run `download_tabular_editor()`\n                and download from github.\n        \"\"\"\nlogger.debug(f\"Initializing Tabular Editor Class:: {exe_file_path}\")\nif exe_file_path == \"Default\":\nself.exe: str = download_tabular_editor()\nelse:\nself.exe: str = exe_file_path\npass\n</code></pre>"},{"location":"tabular_editor/#pytabular.tabular_editor.TabularEditor.__init__","title":"<code>__init__(exe_file_path='Default')</code>","text":"<p>Init for <code>TabularEditor()</code> class.</p> <p>This is mostly a placeholder right now. But useful if you want an easy way to download TE2.</p> <p>Parameters:</p> Name Type Description Default <code>exe_file_path</code> <code>str</code> <p>File path where TE2 lives. Defaults to \"Default\". If \"Default\", it will run <code>download_tabular_editor()</code> and download from github.</p> <code>'Default'</code> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>def __init__(self, exe_file_path: str = \"Default\") -&gt; None:\n\"\"\"Init for `TabularEditor()` class.\n    This is mostly a placeholder right now.\n    But useful if you want an easy way to download TE2.\n    Args:\n        exe_file_path (str, optional): File path where TE2 lives. Defaults to \"Default\".\n            If \"Default\", it will run `download_tabular_editor()`\n            and download from github.\n    \"\"\"\nlogger.debug(f\"Initializing Tabular Editor Class:: {exe_file_path}\")\nif exe_file_path == \"Default\":\nself.exe: str = download_tabular_editor()\nelse:\nself.exe: str = exe_file_path\npass\n</code></pre>"},{"location":"tabular_editor/#pytabular.tabular_editor.download_tabular_editor","title":"<code>download_tabular_editor(download_location='https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip', folder='Tabular_Editor_2', auto_remove=True)</code>","text":"<p>Runs a request.get() to retrieve the zip file from web.</p> <p>Will unzip response and store in directory. Will also register the removal of the new directory and files when exiting program.</p> <p>Parameters:</p> Name Type Description Default <code>download_location</code> <code>str</code> <p>File path for zip of Tabular Editor 2. See code args for default download url.</p> <code>'https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip'</code> <code>folder</code> <code>str</code> <p>New Folder Location. Defaults to \"Tabular_Editor_2\".</p> <code>'Tabular_Editor_2'</code> <code>auto_remove</code> <code>bool</code> <p>Boolean to determine auto removal of files once script exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>File path of TabularEditor.exe</p> Source code in <code>pytabular/tabular_editor.py</code> <pre><code>def download_tabular_editor(\ndownload_location: str = (\n\"https://github.com/TabularEditor/TabularEditor/releases/download/2.16.7/TabularEditor.Portable.zip\"  # noqa: E501\n),\nfolder: str = \"Tabular_Editor_2\",\nauto_remove=True,\n) -&gt; str:\n\"\"\"Runs a request.get() to retrieve the zip file from web.\n    Will unzip response and store in directory.\n    Will also register the removal of the new directory\n    and files when exiting program.\n    Args:\n            download_location (str, optional): File path for zip of Tabular Editor 2.\n                    See code args for default download url.\n            folder (str, optional): New Folder Location. Defaults to \"Tabular_Editor_2\".\n            auto_remove (bool, optional): Boolean to determine auto\n                    removal of files once script exits. Defaults to True.\n    Returns:\n            str: File path of TabularEditor.exe\n    \"\"\"\nlogger.info(\"Downloading Tabular Editor 2...\")\nlogger.info(f\"From... {download_location}\")\nfolder_location = os.path.join(os.getcwd(), folder)\nresponse = r.get(download_location)\nfile_location = f\"{os.getcwd()}\\\\{download_location.split('/')[-1]}\"\nwith open(file_location, \"wb\") as te2_zip:\nte2_zip.write(response.content)\nwith z.ZipFile(file_location) as zipper:\nzipper.extractall(path=folder_location)\nlogger.debug(\"Removing Zip File...\")\nos.remove(file_location)\nlogger.info(f\"Tabular Editor Downloaded and Extracted to {folder_location}\")\nif auto_remove:\nlogger.debug(f\"Registering removal on termination... For {folder_location}\")\natexit.register(remove_folder_and_contents, folder_location)\nreturn f\"{folder_location}\\\\TabularEditor.exe\"\n</code></pre>"},{"location":"tabular_tracing/","title":"Running Traces","text":"<p><code>tabular_tracing.py</code> handles all tracing capabilities in your model.</p> <p>It also includes some pre built traces to make life easier. Feel free to build your own.</p> Example Monitor Queries<pre><code>import pytabular as p\nimport logging as l\nmodel = p.Tabular(CONNECTION_STR)\nquery_trace = p.QueryMonitor(model)\nquery_trace.start() # (1)\n###\np.logger.setLevel(l.DEBUG) # (2)\n###\nquery_trace.stop()\nquery_trace.drop() # (3)\n</code></pre> <ol> <li>You will now start to see query traces on your model get outputed to your console.</li> <li>If you want to see the FULL query then set logging to DEBUG.</li> <li>You can drop on your own, or will get dropped on script exit.</li> </ol>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace","title":"<code>BaseTrace</code>","text":"<p>Generates trace to be run on Server.</p> <p>This is the base class to customize the type of Trace you are looking for. It's recommended to use the out of the box traces built. It's on the roadmap to have an intuitive way to build traces for users.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class BaseTrace:\n\"\"\"Generates trace to be run on Server.\n    This is the base class to customize the type of Trace you are looking for.\n    It's recommended to use the out of the box traces built.\n    It's on the roadmap to have an intuitive way to build traces for users.\n    \"\"\"\ndef __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent],\ntrace_event_columns: List[TraceColumn],\nhandler: Callable,\n) -&gt; None:\n\"\"\"This will `build()`, `add()`, and `update()` the trace to model.\n        It will also register the dropping on the trace on exiting python.\n        Args:\n            tabular_class (Tabular): The model you want the trace for.\n            trace_events (List[TraceEvent]): The TraceEvents you want have in your trace.\n                From Microsoft.AnalysisServices.TraceEventClass.\n            trace_event_columns (List[TraceColumn]): The trace event columns you want in your trace.\n                From Microsoft.AnalysisServices.TraceColumn.\n            handler (Callable): The `handler` is a function that will take in two args.\n                The first arg is `source` and it is currently unused.\n                The second is arg is `args` and here\n                is where you can access the results of the trace.\n        \"\"\"\nlogger.debug(\"Trace Base Class initializing...\")\nself.Name = \"PyTabular_\" + \"\".join(\nrandom.SystemRandom().choices(\n[str(x) for x in [y for y in range(0, 10)]], k=10\n)\n)\nself.ID = self.Name.replace(\"PyTabular_\", \"\")\nself.Trace = Trace(self.Name, self.ID)\nlogger.debug(f\"Trace {self.Trace.Name} created...\")\nself.tabular_class = tabular_class\nself.Event_Categories = self._query_dmv_for_event_categories()\nself.trace_events = trace_events\nself.trace_event_columns = trace_event_columns\nself.handler = handler\nself.build()\nself.add()\nself.update()\natexit.register(self.drop)\ndef build(self) -&gt; bool:\n\"\"\"Run on init.\n        This will take the inputed arguments for the class\n        and attempt to build the Trace.\n        Returns:\n                bool: True if successful\n        \"\"\"\nlogger.info(f\"Building Trace {self.Name}\")\nte = [TraceEvent(trace_event) for trace_event in self.trace_events]\nlogger.debug(f\"Adding Events to... {self.Trace.Name}\")\n[self.Trace.get_Events().Add(t) for t in te]\ndef add_column(trace_event, trace_event_column):\n\"\"\"Adds the column to trace event.\"\"\"\ntry:\ntrace_event.Columns.Add(trace_event_column)\nexcept Exception:\nlogger.warning(f\"{trace_event} - {trace_event_column} Skipped\")\npass\nlogger.debug(\"Adding Trace Event Columns...\")\n[\nadd_column(trace_event, trace_event_column)\nfor trace_event_column in self.trace_event_columns\nfor trace_event in te\nif str(trace_event_column.value__)\nin self.Event_Categories[str(trace_event.EventID.value__)]\n]\nlogger.debug(\"Adding Handler to Trace...\")\nself.handler = TraceEventHandler(self.handler)\nself.Trace.OnEvent += self.handler\nreturn True\ndef add(self) -&gt; int:\n\"\"\"Runs on init. Adds built trace to the Server.\n        Returns:\n                int: Return int of placement in Server.Traces.get_Item(int).\n        \"\"\"\nlogger.info(f\"Adding {self.Name} to {self.tabular_class.Server.Name}\")\nreturn self.tabular_class.Server.Traces.Add(self.Trace)\ndef update(self) -&gt; None:\n\"\"\"Runs on init. Syncs with Server.\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\nlogger.info(f\"Updating {self.Name} in {self.tabular_class.Server.Name}\")\nif self.tabular_class.Server.Connected is False:\nself.tabular_class.reconnect()\nreturn self.Trace.Update()\ndef start(self) -&gt; None:\n\"\"\"Call when you want to start the trace.\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\nlogger.info(f\"Starting {self.Name} in {self.tabular_class.Server.Name}\")\nreturn self.Trace.Start()\ndef stop(self) -&gt; None:\n\"\"\"Call when you want to stop the trace.\n        Returns:\n            None: Returns None.\n                Unless unsuccessful then it will return the error from Server.\n        \"\"\"\nlogger.info(f\"Stopping {self.Name} in {self.tabular_class.Server.Name}\")\nreturn self.Trace.Stop()\ndef drop(self) -&gt; None:\n\"\"\"Call when you want to drop the trace.\n        Returns:\n            None: Returns None. Unless unsuccessful,\n                then it will return the error from Server.\n        \"\"\"\nlogger.info(f\"Dropping {self.Name} in {self.tabular_class.Server.Name}\")\natexit.unregister(self.drop)\nreturn self.Trace.Drop()\ndef _query_dmv_for_event_categories(self):\n\"\"\"Internal use. Called during the building process of a refresh.\n        It is used to locate allowed columns for event categories.\n        This is done by executing a `Tabular().Query()`\n        on the `DISCOVER_EVENT_CATEGORIES` table in the DMV.\n        Then the function will parse the results,\n        as it is xml inside of rows.\n        \"\"\"\nevent_categories = {}\nevents = []\nlogger.debug(\"Querying DMV for columns rules...\")\nlogger.debug(\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\")\ndf = self.tabular_class.query(\n\"select * from $SYSTEM.DISCOVER_TRACE_EVENT_CATEGORIES\"\n)\nfor index, row in df.iterrows():\nxml_data = xmltodict.parse(row.Data)\nif type(xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"]) == list:\nevents += [\nevent for event in xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"]\n]\nelse:\nevents += [xml_data[\"EVENTCATEGORY\"][\"EVENTLIST\"][\"EVENT\"]]\nfor event in events:\nevent_categories[event[\"ID\"]] = [\ncolumn[\"ID\"] for column in event[\"EVENTCOLUMNLIST\"][\"EVENTCOLUMN\"]\n]\nreturn event_categories\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.__init__","title":"<code>__init__(tabular_class, trace_events, trace_event_columns, handler)</code>","text":"<p>This will <code>build()</code>, <code>add()</code>, and <code>update()</code> the trace to model.</p> <p>It will also register the dropping on the trace on exiting python.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>The model you want the trace for.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>The TraceEvents you want have in your trace. From Microsoft.AnalysisServices.TraceEventClass.</p> required <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>The trace event columns you want in your trace. From Microsoft.AnalysisServices.TraceColumn.</p> required <code>handler</code> <code>Callable</code> <p>The <code>handler</code> is a function that will take in two args. The first arg is <code>source</code> and it is currently unused. The second is arg is <code>args</code> and here is where you can access the results of the trace.</p> required Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent],\ntrace_event_columns: List[TraceColumn],\nhandler: Callable,\n) -&gt; None:\n\"\"\"This will `build()`, `add()`, and `update()` the trace to model.\n    It will also register the dropping on the trace on exiting python.\n    Args:\n        tabular_class (Tabular): The model you want the trace for.\n        trace_events (List[TraceEvent]): The TraceEvents you want have in your trace.\n            From Microsoft.AnalysisServices.TraceEventClass.\n        trace_event_columns (List[TraceColumn]): The trace event columns you want in your trace.\n            From Microsoft.AnalysisServices.TraceColumn.\n        handler (Callable): The `handler` is a function that will take in two args.\n            The first arg is `source` and it is currently unused.\n            The second is arg is `args` and here\n            is where you can access the results of the trace.\n    \"\"\"\nlogger.debug(\"Trace Base Class initializing...\")\nself.Name = \"PyTabular_\" + \"\".join(\nrandom.SystemRandom().choices(\n[str(x) for x in [y for y in range(0, 10)]], k=10\n)\n)\nself.ID = self.Name.replace(\"PyTabular_\", \"\")\nself.Trace = Trace(self.Name, self.ID)\nlogger.debug(f\"Trace {self.Trace.Name} created...\")\nself.tabular_class = tabular_class\nself.Event_Categories = self._query_dmv_for_event_categories()\nself.trace_events = trace_events\nself.trace_event_columns = trace_event_columns\nself.handler = handler\nself.build()\nself.add()\nself.update()\natexit.register(self.drop)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.build","title":"<code>build()</code>","text":"<p>Run on init.</p> <p>This will take the inputed arguments for the class and attempt to build the Trace.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def build(self) -&gt; bool:\n\"\"\"Run on init.\n    This will take the inputed arguments for the class\n    and attempt to build the Trace.\n    Returns:\n            bool: True if successful\n    \"\"\"\nlogger.info(f\"Building Trace {self.Name}\")\nte = [TraceEvent(trace_event) for trace_event in self.trace_events]\nlogger.debug(f\"Adding Events to... {self.Trace.Name}\")\n[self.Trace.get_Events().Add(t) for t in te]\ndef add_column(trace_event, trace_event_column):\n\"\"\"Adds the column to trace event.\"\"\"\ntry:\ntrace_event.Columns.Add(trace_event_column)\nexcept Exception:\nlogger.warning(f\"{trace_event} - {trace_event_column} Skipped\")\npass\nlogger.debug(\"Adding Trace Event Columns...\")\n[\nadd_column(trace_event, trace_event_column)\nfor trace_event_column in self.trace_event_columns\nfor trace_event in te\nif str(trace_event_column.value__)\nin self.Event_Categories[str(trace_event.EventID.value__)]\n]\nlogger.debug(\"Adding Handler to Trace...\")\nself.handler = TraceEventHandler(self.handler)\nself.Trace.OnEvent += self.handler\nreturn True\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.add","title":"<code>add()</code>","text":"<p>Runs on init. Adds built trace to the Server.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Return int of placement in Server.Traces.get_Item(int).</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def add(self) -&gt; int:\n\"\"\"Runs on init. Adds built trace to the Server.\n    Returns:\n            int: Return int of placement in Server.Traces.get_Item(int).\n    \"\"\"\nlogger.info(f\"Adding {self.Name} to {self.tabular_class.Server.Name}\")\nreturn self.tabular_class.Server.Traces.Add(self.Trace)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.update","title":"<code>update()</code>","text":"<p>Runs on init. Syncs with Server.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def update(self) -&gt; None:\n\"\"\"Runs on init. Syncs with Server.\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\nlogger.info(f\"Updating {self.Name} in {self.tabular_class.Server.Name}\")\nif self.tabular_class.Server.Connected is False:\nself.tabular_class.reconnect()\nreturn self.Trace.Update()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.start","title":"<code>start()</code>","text":"<p>Call when you want to start the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Call when you want to start the trace.\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\nlogger.info(f\"Starting {self.Name} in {self.tabular_class.Server.Name}\")\nreturn self.Trace.Start()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.stop","title":"<code>stop()</code>","text":"<p>Call when you want to stop the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Call when you want to stop the trace.\n    Returns:\n        None: Returns None.\n            Unless unsuccessful then it will return the error from Server.\n    \"\"\"\nlogger.info(f\"Stopping {self.Name} in {self.tabular_class.Server.Name}\")\nreturn self.Trace.Stop()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.BaseTrace.drop","title":"<code>drop()</code>","text":"<p>Call when you want to drop the trace.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Returns None. Unless unsuccessful, then it will return the error from Server.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def drop(self) -&gt; None:\n\"\"\"Call when you want to drop the trace.\n    Returns:\n        None: Returns None. Unless unsuccessful,\n            then it will return the error from Server.\n    \"\"\"\nlogger.info(f\"Dropping {self.Name} in {self.tabular_class.Server.Name}\")\natexit.unregister(self.drop)\nreturn self.Trace.Drop()\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.RefreshTrace","title":"<code>RefreshTrace</code>","text":"<p>         Bases: <code>BaseTrace</code></p> <p>Subclass of <code>BaseTrace()</code>. Usefull for monitoring refreshes.</p> <p>This is the default trace that is run on refreshes. It will output all the various details into <code>logger()</code>. See <code>_refresh_handler()</code> for more details on what gets put into <code>logger()</code>.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class RefreshTrace(BaseTrace):\n\"\"\"Subclass of `BaseTrace()`. Usefull for monitoring refreshes.\n    This is the default trace that is run on refreshes.\n    It will output all the various details into `logger()`.\n    See `_refresh_handler()` for more details on what gets\n    put into `logger()`.\n    \"\"\"\ndef __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent] = [\nTraceEventClass.ProgressReportBegin,\nTraceEventClass.ProgressReportCurrent,\nTraceEventClass.ProgressReportEnd,\nTraceEventClass.ProgressReportError,\n],\ntrace_event_columns: List[TraceColumn] = [\nTraceColumn.EventSubclass,\nTraceColumn.CurrentTime,\nTraceColumn.ObjectName,\nTraceColumn.ObjectPath,\nTraceColumn.DatabaseName,\nTraceColumn.SessionID,\nTraceColumn.TextData,\nTraceColumn.EventClass,\nTraceColumn.ProgressTotal,\n],\nhandler: Callable = _refresh_handler,\n) -&gt; None:\n\"\"\"Init will extend through `BaseTrace()`. But pass through specific params.\n        Args:\n            tabular_class (Tabular): This is your `Tabular()` class.\n            trace_events (List[TraceEvent], optional): Defaults to [\n                TraceEventClass.ProgressReportBegin,\n                TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd,\n                TraceEventClass.ProgressReportError, ].\n            trace_event_columns (List[TraceColumn], optional): Defaults to\n                [ TraceColumn.EventSubclass, TraceColumn.CurrentTime,\n                TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName,\n                TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass,\n                TraceColumn.ProgressTotal, ].\n            handler (Callable, optional): _description_. Defaults to _refresh_handler.\n        \"\"\"\nsuper().__init__(tabular_class, trace_events, trace_event_columns, handler)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.RefreshTrace.__init__","title":"<code>__init__(tabular_class, trace_events=[TraceEventClass.ProgressReportBegin, TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd, TraceEventClass.ProgressReportError], trace_event_columns=[TraceColumn.EventSubclass, TraceColumn.CurrentTime, TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName, TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass, TraceColumn.ProgressTotal], handler=_refresh_handler)</code>","text":"<p>Init will extend through <code>BaseTrace()</code>. But pass through specific params.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>This is your <code>Tabular()</code> class.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>Defaults to [ TraceEventClass.ProgressReportBegin, TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd, TraceEventClass.ProgressReportError, ].</p> <code>[TraceEventClass.ProgressReportBegin, TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd, TraceEventClass.ProgressReportError]</code> <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>Defaults to [ TraceColumn.EventSubclass, TraceColumn.CurrentTime, TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName, TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass, TraceColumn.ProgressTotal, ].</p> <code>[TraceColumn.EventSubclass, TraceColumn.CurrentTime, TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName, TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass, TraceColumn.ProgressTotal]</code> <code>handler</code> <code>Callable</code> <p>description. Defaults to _refresh_handler.</p> <code>_refresh_handler</code> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent] = [\nTraceEventClass.ProgressReportBegin,\nTraceEventClass.ProgressReportCurrent,\nTraceEventClass.ProgressReportEnd,\nTraceEventClass.ProgressReportError,\n],\ntrace_event_columns: List[TraceColumn] = [\nTraceColumn.EventSubclass,\nTraceColumn.CurrentTime,\nTraceColumn.ObjectName,\nTraceColumn.ObjectPath,\nTraceColumn.DatabaseName,\nTraceColumn.SessionID,\nTraceColumn.TextData,\nTraceColumn.EventClass,\nTraceColumn.ProgressTotal,\n],\nhandler: Callable = _refresh_handler,\n) -&gt; None:\n\"\"\"Init will extend through `BaseTrace()`. But pass through specific params.\n    Args:\n        tabular_class (Tabular): This is your `Tabular()` class.\n        trace_events (List[TraceEvent], optional): Defaults to [\n            TraceEventClass.ProgressReportBegin,\n            TraceEventClass.ProgressReportCurrent, TraceEventClass.ProgressReportEnd,\n            TraceEventClass.ProgressReportError, ].\n        trace_event_columns (List[TraceColumn], optional): Defaults to\n            [ TraceColumn.EventSubclass, TraceColumn.CurrentTime,\n            TraceColumn.ObjectName, TraceColumn.ObjectPath, TraceColumn.DatabaseName,\n            TraceColumn.SessionID, TraceColumn.TextData, TraceColumn.EventClass,\n            TraceColumn.ProgressTotal, ].\n        handler (Callable, optional): _description_. Defaults to _refresh_handler.\n    \"\"\"\nsuper().__init__(tabular_class, trace_events, trace_event_columns, handler)\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.QueryMonitor","title":"<code>QueryMonitor</code>","text":"<p>         Bases: <code>BaseTrace</code></p> <p>Subclass of <code>BaseTrace()</code>. Usefull for monitoring queries.</p> <p>The default handler for <code>QueryMonitor()</code> shows full query in <code>logger.debug()</code>. So you will need to set your logger to <code>debug()</code> if you would like to see them. Otherwise, will show basic info on who/what is querying.</p> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>class QueryMonitor(BaseTrace):\n\"\"\"Subclass of `BaseTrace()`. Usefull for monitoring queries.\n    The default handler for `QueryMonitor()` shows full query in `logger.debug()`.\n    So you will need to set your logger to `debug()` if you would like to see them.\n    Otherwise, will show basic info on who/what is querying.\n    \"\"\"\ndef __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent] = [TraceEventClass.QueryEnd],\ntrace_event_columns: List[TraceColumn] = [\nTraceColumn.EventSubclass,\nTraceColumn.StartTime,\nTraceColumn.EndTime,\nTraceColumn.Duration,\nTraceColumn.Severity,\nTraceColumn.Error,\nTraceColumn.NTUserName,\nTraceColumn.DatabaseName,\nTraceColumn.ApplicationName,\nTraceColumn.TextData,\n],\nhandler: Callable = _query_monitor_handler,\n) -&gt; None:\n\"\"\"Init will extend through to BaseTrace, but pass through specific params.\n        Args:\n            tabular_class (Tabular): This is your `Tabular()` class.\n                All that will need to provided to successfully init.\n            trace_events (List[TraceEvent], optional): Defaults to [TraceEventClass.QueryEnd].\n            trace_event_columns (List[TraceColumn], optional): Defaults to\n                [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime,\n                TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error,\n                TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName,\n                TraceColumn.TextData, ].\n            handler (Callable, optional): Defaults to `_query_monitor_handler()`.\n        \"\"\"\nsuper().__init__(tabular_class, trace_events, trace_event_columns, handler)\nlogger.info(\"Query text lives in DEBUG, adjust logging to see query text.\")\n</code></pre>"},{"location":"tabular_tracing/#pytabular.tabular_tracing.QueryMonitor.__init__","title":"<code>__init__(tabular_class, trace_events=[TraceEventClass.QueryEnd], trace_event_columns=[TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime, TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error, TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName, TraceColumn.TextData], handler=_query_monitor_handler)</code>","text":"<p>Init will extend through to BaseTrace, but pass through specific params.</p> <p>Parameters:</p> Name Type Description Default <code>tabular_class</code> <code>Tabular</code> <p>This is your <code>Tabular()</code> class. All that will need to provided to successfully init.</p> required <code>trace_events</code> <code>List[TraceEvent]</code> <p>Defaults to [TraceEventClass.QueryEnd].</p> <code>[TraceEventClass.QueryEnd]</code> <code>trace_event_columns</code> <code>List[TraceColumn]</code> <p>Defaults to [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime, TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error, TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName, TraceColumn.TextData, ].</p> <code>[TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime, TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error, TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName, TraceColumn.TextData]</code> <code>handler</code> <code>Callable</code> <p>Defaults to <code>_query_monitor_handler()</code>.</p> <code>_query_monitor_handler</code> Source code in <code>pytabular/tabular_tracing.py</code> <pre><code>def __init__(\nself,\ntabular_class,\ntrace_events: List[TraceEvent] = [TraceEventClass.QueryEnd],\ntrace_event_columns: List[TraceColumn] = [\nTraceColumn.EventSubclass,\nTraceColumn.StartTime,\nTraceColumn.EndTime,\nTraceColumn.Duration,\nTraceColumn.Severity,\nTraceColumn.Error,\nTraceColumn.NTUserName,\nTraceColumn.DatabaseName,\nTraceColumn.ApplicationName,\nTraceColumn.TextData,\n],\nhandler: Callable = _query_monitor_handler,\n) -&gt; None:\n\"\"\"Init will extend through to BaseTrace, but pass through specific params.\n    Args:\n        tabular_class (Tabular): This is your `Tabular()` class.\n            All that will need to provided to successfully init.\n        trace_events (List[TraceEvent], optional): Defaults to [TraceEventClass.QueryEnd].\n        trace_event_columns (List[TraceColumn], optional): Defaults to\n            [ TraceColumn.EventSubclass, TraceColumn.StartTime, TraceColumn.EndTime,\n            TraceColumn.Duration, TraceColumn.Severity, TraceColumn.Error,\n            TraceColumn.NTUserName, TraceColumn.DatabaseName, TraceColumn.ApplicationName,\n            TraceColumn.TextData, ].\n        handler (Callable, optional): Defaults to `_query_monitor_handler()`.\n    \"\"\"\nsuper().__init__(tabular_class, trace_events, trace_event_columns, handler)\nlogger.info(\"Query text lives in DEBUG, adjust logging to see query text.\")\n</code></pre>"}]}